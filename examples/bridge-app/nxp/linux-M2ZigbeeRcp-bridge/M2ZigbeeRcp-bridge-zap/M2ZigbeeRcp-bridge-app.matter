// This IDL was generated automatically by ZAP.
// It is for view/code review purposes only.

enum AreaTypeTag : enum8 {
  kAisle = 0;
  kAttic = 1;
  kBackDoor = 2;
  kBackYard = 3;
  kBalcony = 4;
  kBallroom = 5;
  kBathroom = 6;
  kBedroom = 7;
  kBorder = 8;
  kBoxroom = 9;
  kBreakfastRoom = 10;
  kCarport = 11;
  kCellar = 12;
  kCloakroom = 13;
  kCloset = 14;
  kConservatory = 15;
  kCorridor = 16;
  kCraftRoom = 17;
  kCupboard = 18;
  kDeck = 19;
  kDen = 20;
  kDining = 21;
  kDrawingRoom = 22;
  kDressingRoom = 23;
  kDriveway = 24;
  kElevator = 25;
  kEnsuite = 26;
  kEntrance = 27;
  kEntryway = 28;
  kFamilyRoom = 29;
  kFoyer = 30;
  kFrontDoor = 31;
  kFrontYard = 32;
  kGameRoom = 33;
  kGarage = 34;
  kGarageDoor = 35;
  kGarden = 36;
  kGardenDoor = 37;
  kGuestBathroom = 38;
  kGuestBedroom = 39;
  kGuestRestroom = 40;
  kGuestRoom = 41;
  kGym = 42;
  kHallway = 43;
  kHearthRoom = 44;
  kKidsRoom = 45;
  kKidsBedroom = 46;
  kKitchen = 47;
  kLarder = 48;
  kLaundryRoom = 49;
  kLawn = 50;
  kLibrary = 51;
  kLivingRoom = 52;
  kLounge = 53;
  kMediaTVRoom = 54;
  kMudRoom = 55;
  kMusicRoom = 56;
  kNursery = 57;
  kOffice = 58;
  kOutdoorKitchen = 59;
  kOutside = 60;
  kPantry = 61;
  kParkingLot = 62;
  kParlor = 63;
  kPatio = 64;
  kPlayRoom = 65;
  kPoolRoom = 66;
  kPorch = 67;
  kPrimaryBathroom = 68;
  kPrimaryBedroom = 69;
  kRamp = 70;
  kReceptionRoom = 71;
  kRecreationRoom = 72;
  kRestroom = 73;
  kRoof = 74;
  kSauna = 75;
  kScullery = 76;
  kSewingRoom = 77;
  kShed = 78;
  kSideDoor = 79;
  kSideYard = 80;
  kSittingRoom = 81;
  kSnug = 82;
  kSpa = 83;
  kStaircase = 84;
  kSteamRoom = 85;
  kStorageRoom = 86;
  kStudio = 87;
  kStudy = 88;
  kSunRoom = 89;
  kSwimmingPool = 90;
  kTerrace = 91;
  kUtilityRoom = 92;
  kWard = 93;
  kWorkshop = 94;
}

enum AtomicRequestTypeEnum : enum8 {
  kBeginWrite = 0;
  kCommitWrite = 1;
  kRollbackWrite = 2;
}

enum FloorSurfaceTag : enum8 {
  kCarpet = 0;
  kCeramic = 1;
  kConcrete = 2;
  kCork = 3;
  kDeepCarpet = 4;
  kDirt = 5;
  kEngineeredWood = 6;
  kGlass = 7;
  kGrass = 8;
  kHardwood = 9;
  kLaminate = 10;
  kLinoleum = 11;
  kMat = 12;
  kMetal = 13;
  kPlastic = 14;
  kPolishedConcrete = 15;
  kRubber = 16;
  kRug = 17;
  kSand = 18;
  kStone = 19;
  kTatami = 20;
  kTerrazzo = 21;
  kTile = 22;
  kVinyl = 23;
}

enum LandmarkTag : enum8 {
  kAirConditioner = 0;
  kAirPurifier = 1;
  kBackDoor = 2;
  kBarStool = 3;
  kBathMat = 4;
  kBathtub = 5;
  kBed = 6;
  kBookshelf = 7;
  kChair = 8;
  kChristmasTree = 9;
  kCoatRack = 10;
  kCoffeeTable = 11;
  kCookingRange = 12;
  kCouch = 13;
  kCountertop = 14;
  kCradle = 15;
  kCrib = 16;
  kDesk = 17;
  kDiningTable = 18;
  kDishwasher = 19;
  kDoor = 20;
  kDresser = 21;
  kLaundryDryer = 22;
  kFan = 23;
  kFireplace = 24;
  kFreezer = 25;
  kFrontDoor = 26;
  kHighChair = 27;
  kKitchenIsland = 28;
  kLamp = 29;
  kLitterBox = 30;
  kMirror = 31;
  kNightstand = 32;
  kOven = 33;
  kPetBed = 34;
  kPetBowl = 35;
  kPetCrate = 36;
  kRefrigerator = 37;
  kScratchingPost = 38;
  kShoeRack = 39;
  kShower = 40;
  kSideDoor = 41;
  kSink = 42;
  kSofa = 43;
  kStove = 44;
  kTable = 45;
  kToilet = 46;
  kTrashCan = 47;
  kLaundryWasher = 48;
  kWindow = 49;
  kWineCooler = 50;
}

enum PositionTag : enum8 {
  kLeft = 0;
  kRight = 1;
  kTop = 2;
  kBottom = 3;
  kMiddle = 4;
  kRow = 5;
  kColumn = 6;
}

enum RelativePositionTag : enum8 {
  kUnder = 0;
  kNextTo = 1;
  kAround = 2;
  kOn = 3;
  kAbove = 4;
  kFrontOf = 5;
  kBehind = 6;
}

enum TestGlobalEnum : enum8 {
  kSomeValue = 0;
  kSomeOtherValue = 1;
  kFinalValue = 2;
}

enum ThreeLevelAutoEnum : enum8 {
  kLow = 0;
  kMedium = 1;
  kHigh = 2;
  kAutomatic = 3;
}

bitmap TestGlobalBitmap : bitmap32 {
  kFirstBit = 0x1;
  kSecondBit = 0x2;
}

struct TestGlobalStruct {
  char_string<128> name = 0;
  nullable TestGlobalBitmap myBitmap = 1;
  optional nullable TestGlobalEnum myEnum = 2;
}

struct LocationDescriptorStruct {
  char_string<128> locationName = 0;
  nullable int16s floorNumber = 1;
  nullable AreaTypeTag areaType = 2;
}

struct AtomicAttributeStatusStruct {
  attrib_id attributeID = 0;
  status statusCode = 1;
}

/** Attributes and commands for putting a device into Identification mode (e.g. flashing a light). */
cluster Identify = 3 {
  revision 4;

  enum EffectIdentifierEnum : enum8 {
    kBlink = 0;
    kBreathe = 1;
    kOkay = 2;
    kChannelChange = 11;
    kFinishEffect = 254;
    kStopEffect = 255;
  }

  enum EffectVariantEnum : enum8 {
    kDefault = 0;
  }

  enum IdentifyTypeEnum : enum8 {
    kNone = 0;
    kLightOutput = 1;
    kVisibleIndicator = 2;
    kAudibleBeep = 3;
    kDisplay = 4;
    kActuator = 5;
  }

  attribute int16u identifyTime = 0;
  readonly attribute IdentifyTypeEnum identifyType = 1;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct IdentifyRequest {
    int16u identifyTime = 0;
  }

  request struct TriggerEffectRequest {
    EffectIdentifierEnum effectIdentifier = 0;
    EffectVariantEnum effectVariant = 1;
  }

  /** Command description for Identify */
  command access(invoke: manage) Identify(IdentifyRequest): DefaultSuccess = 0;
  /** Command description for TriggerEffect */
  command access(invoke: manage) TriggerEffect(TriggerEffectRequest): DefaultSuccess = 64;
}

/** Attributes and commands for group configuration and manipulation. */
cluster Groups = 4 {
  revision 4;

  bitmap Feature : bitmap32 {
    kGroupNames = 0x1;
  }

  bitmap NameSupportBitmap : bitmap8 {
    kGroupNames = 0x80;
  }

  readonly attribute NameSupportBitmap nameSupport = 0;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct AddGroupRequest {
    group_id groupID = 0;
    char_string<16> groupName = 1;
  }

  response struct AddGroupResponse = 0 {
    enum8 status = 0;
    group_id groupID = 1;
  }

  request struct ViewGroupRequest {
    group_id groupID = 0;
  }

  response struct ViewGroupResponse = 1 {
    enum8 status = 0;
    group_id groupID = 1;
    char_string<16> groupName = 2;
  }

  request struct GetGroupMembershipRequest {
    group_id groupList[] = 0;
  }

  response struct GetGroupMembershipResponse = 2 {
    nullable int8u capacity = 0;
    group_id groupList[] = 1;
  }

  request struct RemoveGroupRequest {
    group_id groupID = 0;
  }

  response struct RemoveGroupResponse = 3 {
    enum8 status = 0;
    group_id groupID = 1;
  }

  request struct AddGroupIfIdentifyingRequest {
    group_id groupID = 0;
    char_string<16> groupName = 1;
  }

  /** Command description for AddGroup */
  fabric command access(invoke: manage) AddGroup(AddGroupRequest): AddGroupResponse = 0;
  /** Command description for ViewGroup */
  fabric command ViewGroup(ViewGroupRequest): ViewGroupResponse = 1;
  /** Command description for GetGroupMembership */
  fabric command GetGroupMembership(GetGroupMembershipRequest): GetGroupMembershipResponse = 2;
  /** Command description for RemoveGroup */
  fabric command access(invoke: manage) RemoveGroup(RemoveGroupRequest): RemoveGroupResponse = 3;
  /** Command description for RemoveAllGroups */
  fabric command access(invoke: manage) RemoveAllGroups(): DefaultSuccess = 4;
  /** Command description for AddGroupIfIdentifying */
  fabric command access(invoke: manage) AddGroupIfIdentifying(AddGroupIfIdentifyingRequest): DefaultSuccess = 5;
}

/** Attributes and commands for switching devices between 'On' and 'Off' states. */
cluster OnOff = 6 {
  revision 6;

  enum DelayedAllOffEffectVariantEnum : enum8 {
    kDelayedOffFastFade = 0;
    kNoFade = 1;
    kDelayedOffSlowFade = 2;
  }

  enum DyingLightEffectVariantEnum : enum8 {
    kDyingLightFadeOff = 0;
  }

  enum EffectIdentifierEnum : enum8 {
    kDelayedAllOff = 0;
    kDyingLight = 1;
  }

  enum StartUpOnOffEnum : enum8 {
    kOff = 0;
    kOn = 1;
    kToggle = 2;
  }

  bitmap Feature : bitmap32 {
    kLighting = 0x1;
    kDeadFrontBehavior = 0x2;
    kOffOnly = 0x4;
  }

  bitmap OnOffControlBitmap : bitmap8 {
    kAcceptOnlyWhenOn = 0x1;
  }

  readonly attribute boolean onOff = 0;
  readonly attribute optional boolean globalSceneControl = 16384;
  attribute optional int16u onTime = 16385;
  attribute optional int16u offWaitTime = 16386;
  attribute access(write: manage) optional nullable StartUpOnOffEnum startUpOnOff = 16387;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct OffWithEffectRequest {
    EffectIdentifierEnum effectIdentifier = 0;
    enum8 effectVariant = 1;
  }

  request struct OnWithTimedOffRequest {
    OnOffControlBitmap onOffControl = 0;
    int16u onTime = 1;
    int16u offWaitTime = 2;
  }

  /** On receipt of this command, a device SHALL enter its ‘Off’ state. This state is device dependent, but it is recommended that it is used for power off or similar functions. On receipt of the Off command, the OnTime attribute SHALL be set to 0. */
  command Off(): DefaultSuccess = 0;
  /** On receipt of this command, a device SHALL enter its ‘On’ state. This state is device dependent, but it is recommended that it is used for power on or similar functions. On receipt of the On command, if the value of the OnTime attribute is equal to 0, the device SHALL set the OffWaitTime attribute to 0. */
  command On(): DefaultSuccess = 1;
  /** On receipt of this command, if a device is in its ‘Off’ state it SHALL enter its ‘On’ state. Otherwise, if it is in its ‘On’ state it SHALL enter its ‘Off’ state. On receipt of the Toggle command, if the value of the OnOff attribute is equal to FALSE and if the value of the OnTime attribute is equal to 0, the device SHALL set the OffWaitTime attribute to 0. If the value of the OnOff attribute is equal to TRUE, the OnTime attribute SHALL be set to 0. */
  command Toggle(): DefaultSuccess = 2;
  /** The OffWithEffect command allows devices to be turned off using enhanced ways of fading. */
  command OffWithEffect(OffWithEffectRequest): DefaultSuccess = 64;
  /** The OnWithRecallGlobalScene command allows the recall of the settings when the device was turned off. */
  command OnWithRecallGlobalScene(): DefaultSuccess = 65;
  /** The OnWithTimedOff command allows devices to be turned on for a specific duration with a guarded off duration so that SHOULD the device be subsequently switched off, further OnWithTimedOff commands, received during this time, are prevented from turning the devices back on. */
  command OnWithTimedOff(OnWithTimedOffRequest): DefaultSuccess = 66;
}

/** Attributes and commands for controlling devices that can be set to a level between fully 'On' and fully 'Off.' */
cluster LevelControl = 8 {
  revision 6;

  enum MoveModeEnum : enum8 {
    kUp = 0;
    kDown = 1;
  }

  enum StepModeEnum : enum8 {
    kUp = 0;
    kDown = 1;
  }

  bitmap Feature : bitmap32 {
    kOnOff = 0x1;
    kLighting = 0x2;
    kFrequency = 0x4;
  }

  bitmap OptionsBitmap : bitmap8 {
    kExecuteIfOff = 0x1;
    kCoupleColorTempToLevel = 0x2;
  }

  readonly attribute nullable int8u currentLevel = 0;
  readonly attribute optional int16u remainingTime = 1;
  readonly attribute optional int8u minLevel = 2;
  readonly attribute optional int8u maxLevel = 3;
  readonly attribute optional int16u currentFrequency = 4;
  readonly attribute optional int16u minFrequency = 5;
  readonly attribute optional int16u maxFrequency = 6;
  attribute OptionsBitmap options = 15;
  attribute optional int16u onOffTransitionTime = 16;
  attribute nullable int8u onLevel = 17;
  attribute optional nullable int16u onTransitionTime = 18;
  attribute optional nullable int16u offTransitionTime = 19;
  attribute optional nullable int8u defaultMoveRate = 20;
  attribute access(write: manage) optional nullable int8u startUpCurrentLevel = 16384;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct MoveToLevelRequest {
    int8u level = 0;
    nullable int16u transitionTime = 1;
    OptionsBitmap optionsMask = 2;
    OptionsBitmap optionsOverride = 3;
  }

  request struct MoveRequest {
    MoveModeEnum moveMode = 0;
    nullable int8u rate = 1;
    OptionsBitmap optionsMask = 2;
    OptionsBitmap optionsOverride = 3;
  }

  request struct StepRequest {
    StepModeEnum stepMode = 0;
    int8u stepSize = 1;
    nullable int16u transitionTime = 2;
    OptionsBitmap optionsMask = 3;
    OptionsBitmap optionsOverride = 4;
  }

  request struct StopRequest {
    OptionsBitmap optionsMask = 0;
    OptionsBitmap optionsOverride = 1;
  }

  request struct MoveToLevelWithOnOffRequest {
    int8u level = 0;
    nullable int16u transitionTime = 1;
    OptionsBitmap optionsMask = 2;
    OptionsBitmap optionsOverride = 3;
  }

  request struct MoveWithOnOffRequest {
    MoveModeEnum moveMode = 0;
    nullable int8u rate = 1;
    OptionsBitmap optionsMask = 2;
    OptionsBitmap optionsOverride = 3;
  }

  request struct StepWithOnOffRequest {
    StepModeEnum stepMode = 0;
    int8u stepSize = 1;
    nullable int16u transitionTime = 2;
    OptionsBitmap optionsMask = 3;
    OptionsBitmap optionsOverride = 4;
  }

  request struct StopWithOnOffRequest {
    OptionsBitmap optionsMask = 0;
    OptionsBitmap optionsOverride = 1;
  }

  request struct MoveToClosestFrequencyRequest {
    int16u frequency = 0;
  }

  /** Command description for MoveToLevel */
  command MoveToLevel(MoveToLevelRequest): DefaultSuccess = 0;
  /** Command description for Move */
  command Move(MoveRequest): DefaultSuccess = 1;
  /** Command description for Step */
  command Step(StepRequest): DefaultSuccess = 2;
  /** Command description for Stop */
  command Stop(StopRequest): DefaultSuccess = 3;
  /** Command description for MoveToLevelWithOnOff */
  command MoveToLevelWithOnOff(MoveToLevelWithOnOffRequest): DefaultSuccess = 4;
  /** Command description for MoveWithOnOff */
  command MoveWithOnOff(MoveWithOnOffRequest): DefaultSuccess = 5;
  /** Command description for StepWithOnOff */
  command StepWithOnOff(StepWithOnOffRequest): DefaultSuccess = 6;
  /** Command description for StopWithOnOff */
  command StopWithOnOff(StopWithOnOffRequest): DefaultSuccess = 7;
  /** Change the currrent frequency to the provided one, or a close
        approximation if the exact provided one is not possible. */
  command MoveToClosestFrequency(MoveToClosestFrequencyRequest): DefaultSuccess = 8;
}

/** The Descriptor Cluster is meant to replace the support from the Zigbee Device Object (ZDO) for describing a node, its endpoints and clusters. */
cluster Descriptor = 29 {
  revision 2;

  bitmap Feature : bitmap32 {
    kTagList = 0x1;
  }

  struct DeviceTypeStruct {
    devtype_id deviceType = 0;
    int16u revision = 1;
  }

  struct SemanticTagStruct {
    nullable vendor_id mfgCode = 0;
    enum8 namespaceID = 1;
    enum8 tag = 2;
    optional nullable char_string label = 3;
  }

  readonly attribute DeviceTypeStruct deviceTypeList[] = 0;
  readonly attribute cluster_id serverList[] = 1;
  readonly attribute cluster_id clientList[] = 2;
  readonly attribute endpoint_no partsList[] = 3;
  readonly attribute optional SemanticTagStruct tagList[] = 4;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** The Binding Cluster is meant to replace the support from the Zigbee Device Object (ZDO) for supporting the binding table. */
cluster Binding = 30 {
  revision 1; // NOTE: Default/not specifically set

  fabric_scoped struct TargetStruct {
    optional node_id node = 1;
    optional group_id group = 2;
    optional endpoint_no endpoint = 3;
    optional cluster_id cluster = 4;
    fabric_idx fabricIndex = 254;
  }

  attribute access(write: manage) TargetStruct binding[] = 0;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** The Binding Cluster is meant to replace the support from the Zigbee Device Object (ZDO) for supporting the binding table. */
cluster Binding = 30 {
  revision 1; // NOTE: Default/not specifically set

  fabric_scoped struct TargetStruct {
    optional node_id node = 1;
    optional group_id group = 2;
    optional endpoint_no endpoint = 3;
    optional cluster_id cluster = 4;
    fabric_idx fabricIndex = 254;
  }

  attribute access(write: manage) TargetStruct binding[] = 0;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** The Access Control Cluster exposes a data model view of a
      Node's Access Control List (ACL), which codifies the rules used to manage
      and enforce Access Control for the Node's endpoints and their associated
      cluster instances. */
cluster AccessControl = 31 {
  revision 2;

  enum AccessControlEntryAuthModeEnum : enum8 {
    kPASE = 1;
    kCASE = 2;
    kGroup = 3;
  }

  enum AccessControlEntryPrivilegeEnum : enum8 {
    kView = 1;
    kProxyView = 2;
    kOperate = 3;
    kManage = 4;
    kAdminister = 5;
  }

  enum AccessRestrictionTypeEnum : enum8 {
    kAttributeAccessForbidden = 0;
    kAttributeWriteForbidden = 1;
    kCommandForbidden = 2;
    kEventForbidden = 3;
  }

  enum ChangeTypeEnum : enum8 {
    kChanged = 0;
    kAdded = 1;
    kRemoved = 2;
  }

  bitmap Feature : bitmap32 {
    kExtension = 0x1;
    kManagedDevice = 0x2;
  }

  struct AccessRestrictionStruct {
    AccessRestrictionTypeEnum type = 0;
    nullable int32u id = 1;
  }

  struct CommissioningAccessRestrictionEntryStruct {
    endpoint_no endpoint = 0;
    cluster_id cluster = 1;
    AccessRestrictionStruct restrictions[] = 2;
  }

  fabric_scoped struct AccessRestrictionEntryStruct {
    fabric_sensitive endpoint_no endpoint = 0;
    fabric_sensitive cluster_id cluster = 1;
    fabric_sensitive AccessRestrictionStruct restrictions[] = 2;
    fabric_idx fabricIndex = 254;
  }

  struct AccessControlTargetStruct {
    nullable cluster_id cluster = 0;
    nullable endpoint_no endpoint = 1;
    nullable devtype_id deviceType = 2;
  }

  fabric_scoped struct AccessControlEntryStruct {
    fabric_sensitive AccessControlEntryPrivilegeEnum privilege = 1;
    fabric_sensitive AccessControlEntryAuthModeEnum authMode = 2;
    nullable fabric_sensitive int64u subjects[] = 3;
    nullable fabric_sensitive AccessControlTargetStruct targets[] = 4;
    fabric_idx fabricIndex = 254;
  }

  fabric_scoped struct AccessControlExtensionStruct {
    fabric_sensitive octet_string<128> data = 1;
    fabric_idx fabricIndex = 254;
  }

  fabric_sensitive info event access(read: administer) AccessControlEntryChanged = 0 {
    nullable node_id adminNodeID = 1;
    nullable int16u adminPasscodeID = 2;
    ChangeTypeEnum changeType = 3;
    nullable AccessControlEntryStruct latestValue = 4;
    fabric_idx fabricIndex = 254;
  }

  fabric_sensitive info event access(read: administer) AccessControlExtensionChanged = 1 {
    nullable node_id adminNodeID = 1;
    nullable int16u adminPasscodeID = 2;
    ChangeTypeEnum changeType = 3;
    nullable AccessControlExtensionStruct latestValue = 4;
    fabric_idx fabricIndex = 254;
  }

  fabric_sensitive info event access(read: administer) FabricRestrictionReviewUpdate = 2 {
    int64u token = 0;
    optional long_char_string instruction = 1;
    optional long_char_string ARLRequestFlowUrl = 2;
    fabric_idx fabricIndex = 254;
  }

  attribute access(read: administer, write: administer) AccessControlEntryStruct acl[] = 0;
  attribute access(read: administer, write: administer) optional AccessControlExtensionStruct extension[] = 1;
  readonly attribute int16u subjectsPerAccessControlEntry = 2;
  readonly attribute int16u targetsPerAccessControlEntry = 3;
  readonly attribute int16u accessControlEntriesPerFabric = 4;
  readonly attribute optional CommissioningAccessRestrictionEntryStruct commissioningARL[] = 5;
  readonly attribute optional AccessRestrictionEntryStruct arl[] = 6;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct ReviewFabricRestrictionsRequest {
    CommissioningAccessRestrictionEntryStruct arl[] = 0;
  }

  response struct ReviewFabricRestrictionsResponse = 1 {
    int64u token = 0;
  }

  /** This command signals to the service associated with the device vendor that the fabric administrator would like a review of the current restrictions on the accessing fabric. */
  fabric command access(invoke: administer) ReviewFabricRestrictions(ReviewFabricRestrictionsRequest): ReviewFabricRestrictionsResponse = 0;
}

/** The Access Control Cluster exposes a data model view of a
      Node's Access Control List (ACL), which codifies the rules used to manage
      and enforce Access Control for the Node's endpoints and their associated
      cluster instances. */
cluster AccessControl = 31 {
  revision 2;

  enum AccessControlEntryAuthModeEnum : enum8 {
    kPASE = 1;
    kCASE = 2;
    kGroup = 3;
  }

  enum AccessControlEntryPrivilegeEnum : enum8 {
    kView = 1;
    kProxyView = 2;
    kOperate = 3;
    kManage = 4;
    kAdminister = 5;
  }

  enum AccessRestrictionTypeEnum : enum8 {
    kAttributeAccessForbidden = 0;
    kAttributeWriteForbidden = 1;
    kCommandForbidden = 2;
    kEventForbidden = 3;
  }

  enum ChangeTypeEnum : enum8 {
    kChanged = 0;
    kAdded = 1;
    kRemoved = 2;
  }

  bitmap Feature : bitmap32 {
    kExtension = 0x1;
    kManagedDevice = 0x2;
  }

  struct AccessRestrictionStruct {
    AccessRestrictionTypeEnum type = 0;
    nullable int32u id = 1;
  }

  struct CommissioningAccessRestrictionEntryStruct {
    endpoint_no endpoint = 0;
    cluster_id cluster = 1;
    AccessRestrictionStruct restrictions[] = 2;
  }

  fabric_scoped struct AccessRestrictionEntryStruct {
    fabric_sensitive endpoint_no endpoint = 0;
    fabric_sensitive cluster_id cluster = 1;
    fabric_sensitive AccessRestrictionStruct restrictions[] = 2;
    fabric_idx fabricIndex = 254;
  }

  struct AccessControlTargetStruct {
    nullable cluster_id cluster = 0;
    nullable endpoint_no endpoint = 1;
    nullable devtype_id deviceType = 2;
  }

  fabric_scoped struct AccessControlEntryStruct {
    fabric_sensitive AccessControlEntryPrivilegeEnum privilege = 1;
    fabric_sensitive AccessControlEntryAuthModeEnum authMode = 2;
    nullable fabric_sensitive int64u subjects[] = 3;
    nullable fabric_sensitive AccessControlTargetStruct targets[] = 4;
    fabric_idx fabricIndex = 254;
  }

  fabric_scoped struct AccessControlExtensionStruct {
    fabric_sensitive octet_string<128> data = 1;
    fabric_idx fabricIndex = 254;
  }

  fabric_sensitive info event access(read: administer) AccessControlEntryChanged = 0 {
    nullable node_id adminNodeID = 1;
    nullable int16u adminPasscodeID = 2;
    ChangeTypeEnum changeType = 3;
    nullable AccessControlEntryStruct latestValue = 4;
    fabric_idx fabricIndex = 254;
  }

  fabric_sensitive info event access(read: administer) AccessControlExtensionChanged = 1 {
    nullable node_id adminNodeID = 1;
    nullable int16u adminPasscodeID = 2;
    ChangeTypeEnum changeType = 3;
    nullable AccessControlExtensionStruct latestValue = 4;
    fabric_idx fabricIndex = 254;
  }

  fabric_sensitive info event access(read: administer) FabricRestrictionReviewUpdate = 2 {
    int64u token = 0;
    optional long_char_string instruction = 1;
    optional long_char_string ARLRequestFlowUrl = 2;
    fabric_idx fabricIndex = 254;
  }

  attribute access(read: administer, write: administer) AccessControlEntryStruct acl[] = 0;
  attribute access(read: administer, write: administer) optional AccessControlExtensionStruct extension[] = 1;
  readonly attribute int16u subjectsPerAccessControlEntry = 2;
  readonly attribute int16u targetsPerAccessControlEntry = 3;
  readonly attribute int16u accessControlEntriesPerFabric = 4;
  readonly attribute optional CommissioningAccessRestrictionEntryStruct commissioningARL[] = 5;
  readonly attribute optional AccessRestrictionEntryStruct arl[] = 6;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct ReviewFabricRestrictionsRequest {
    CommissioningAccessRestrictionEntryStruct arl[] = 0;
  }

  response struct ReviewFabricRestrictionsResponse = 1 {
    int64u token = 0;
  }

  /** This command signals to the service associated with the device vendor that the fabric administrator would like a review of the current restrictions on the accessing fabric. */
  fabric command access(invoke: administer) ReviewFabricRestrictions(ReviewFabricRestrictionsRequest): ReviewFabricRestrictionsResponse = 0;
}

/** This cluster provides a standardized way for a Node (typically a Bridge, but could be any Node) to expose action information. */
cluster Actions = 37 {
  revision 1; // NOTE: Default/not specifically set

  enum ActionErrorEnum : enum8 {
    kUnknown = 0;
    kInterrupted = 1;
  }

  enum ActionStateEnum : enum8 {
    kInactive = 0;
    kActive = 1;
    kPaused = 2;
    kDisabled = 3;
  }

  enum ActionTypeEnum : enum8 {
    kOther = 0;
    kScene = 1;
    kSequence = 2;
    kAutomation = 3;
    kException = 4;
    kNotification = 5;
    kAlarm = 6;
  }

  enum EndpointListTypeEnum : enum8 {
    kOther = 0;
    kRoom = 1;
    kZone = 2;
  }

  bitmap CommandBits : bitmap16 {
    kInstantAction = 0x1;
    kInstantActionWithTransition = 0x2;
    kStartAction = 0x4;
    kStartActionWithDuration = 0x8;
    kStopAction = 0x10;
    kPauseAction = 0x20;
    kPauseActionWithDuration = 0x40;
    kResumeAction = 0x80;
    kEnableAction = 0x100;
    kEnableActionWithDuration = 0x200;
    kDisableAction = 0x400;
    kDisableActionWithDuration = 0x800;
  }

  struct ActionStruct {
    int16u actionID = 0;
    char_string<32> name = 1;
    ActionTypeEnum type = 2;
    int16u endpointListID = 3;
    CommandBits supportedCommands = 4;
    ActionStateEnum state = 5;
  }

  struct EndpointListStruct {
    int16u endpointListID = 0;
    char_string<32> name = 1;
    EndpointListTypeEnum type = 2;
    endpoint_no endpoints[] = 3;
  }

  info event StateChanged = 0 {
    int16u actionID = 0;
    int32u invokeID = 1;
    ActionStateEnum newState = 2;
  }

  info event ActionFailed = 1 {
    int16u actionID = 0;
    int32u invokeID = 1;
    ActionStateEnum newState = 2;
    ActionErrorEnum error = 3;
  }

  readonly attribute ActionStruct actionList[] = 0;
  readonly attribute EndpointListStruct endpointLists[] = 1;
  readonly attribute optional long_char_string<512> setupURL = 2;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct InstantActionRequest {
    int16u actionID = 0;
    optional int32u invokeID = 1;
  }

  request struct InstantActionWithTransitionRequest {
    int16u actionID = 0;
    optional int32u invokeID = 1;
    int16u transitionTime = 2;
  }

  request struct StartActionRequest {
    int16u actionID = 0;
    optional int32u invokeID = 1;
  }

  request struct StartActionWithDurationRequest {
    int16u actionID = 0;
    optional int32u invokeID = 1;
    int32u duration = 2;
  }

  request struct StopActionRequest {
    int16u actionID = 0;
    optional int32u invokeID = 1;
  }

  request struct PauseActionRequest {
    int16u actionID = 0;
    optional int32u invokeID = 1;
  }

  request struct PauseActionWithDurationRequest {
    int16u actionID = 0;
    optional int32u invokeID = 1;
    int32u duration = 2;
  }

  request struct ResumeActionRequest {
    int16u actionID = 0;
    optional int32u invokeID = 1;
  }

  request struct EnableActionRequest {
    int16u actionID = 0;
    optional int32u invokeID = 1;
  }

  request struct EnableActionWithDurationRequest {
    int16u actionID = 0;
    optional int32u invokeID = 1;
    int32u duration = 2;
  }

  request struct DisableActionRequest {
    int16u actionID = 0;
    optional int32u invokeID = 1;
  }

  request struct DisableActionWithDurationRequest {
    int16u actionID = 0;
    optional int32u invokeID = 1;
    int32u duration = 2;
  }

  /** This command triggers an action (state change) on the involved endpoints. */
  command InstantAction(InstantActionRequest): DefaultSuccess = 0;
  /** This command triggers an action (state change) on the involved endpoints, with a specified time to transition from the current state to the new state. */
  command InstantActionWithTransition(InstantActionWithTransitionRequest): DefaultSuccess = 1;
  /** This command triggers the commencement of an action on the involved endpoints. */
  command StartAction(StartActionRequest): DefaultSuccess = 2;
  /** This command triggers the commencement of an action (with a duration) on the involved endpoints. */
  command StartActionWithDuration(StartActionWithDurationRequest): DefaultSuccess = 3;
  /** This command stops the ongoing action on the involved endpoints. */
  command StopAction(StopActionRequest): DefaultSuccess = 4;
  /** This command pauses an ongoing action. */
  command PauseAction(PauseActionRequest): DefaultSuccess = 5;
  /** This command pauses an ongoing action with a duration. */
  command PauseActionWithDuration(PauseActionWithDurationRequest): DefaultSuccess = 6;
  /** This command resumes a previously paused action. */
  command ResumeAction(ResumeActionRequest): DefaultSuccess = 7;
  /** This command enables a certain action or automation. */
  command EnableAction(EnableActionRequest): DefaultSuccess = 8;
  /** This command enables a certain action or automation with a duration. */
  command EnableActionWithDuration(EnableActionWithDurationRequest): DefaultSuccess = 9;
  /** This command disables a certain action or automation. */
  command DisableAction(DisableActionRequest): DefaultSuccess = 10;
  /** This command disables a certain action or automation with a duration. */
  command DisableActionWithDuration(DisableActionWithDurationRequest): DefaultSuccess = 11;
}

/** This cluster provides attributes and events for determining basic information about Nodes, which supports both
      Commissioning and operational determination of Node characteristics, such as Vendor ID, Product ID and serial number,
      which apply to the whole Node. Also allows setting user device information such as location. */
cluster BasicInformation = 40 {
  revision 3;

  enum ColorEnum : enum8 {
    kBlack = 0;
    kNavy = 1;
    kGreen = 2;
    kTeal = 3;
    kMaroon = 4;
    kPurple = 5;
    kOlive = 6;
    kGray = 7;
    kBlue = 8;
    kLime = 9;
    kAqua = 10;
    kRed = 11;
    kFuchsia = 12;
    kYellow = 13;
    kWhite = 14;
    kNickel = 15;
    kChrome = 16;
    kBrass = 17;
    kCopper = 18;
    kSilver = 19;
    kGold = 20;
  }

  enum ProductFinishEnum : enum8 {
    kOther = 0;
    kMatte = 1;
    kSatin = 2;
    kPolished = 3;
    kRugged = 4;
    kFabric = 5;
  }

  struct CapabilityMinimaStruct {
    int16u caseSessionsPerFabric = 0;
    int16u subscriptionsPerFabric = 1;
  }

  struct ProductAppearanceStruct {
    ProductFinishEnum finish = 0;
    nullable ColorEnum primaryColor = 1;
  }

  critical event StartUp = 0 {
    int32u softwareVersion = 0;
  }

  critical event ShutDown = 1 {
  }

  info event Leave = 2 {
    fabric_idx fabricIndex = 0;
  }

  info event ReachableChanged = 3 {
    boolean reachableNewValue = 0;
  }

  readonly attribute int16u dataModelRevision = 0;
  readonly attribute char_string<32> vendorName = 1;
  readonly attribute vendor_id vendorID = 2;
  readonly attribute char_string<32> productName = 3;
  readonly attribute int16u productID = 4;
  attribute access(write: manage) char_string<32> nodeLabel = 5;
  attribute access(write: administer) char_string<2> location = 6;
  readonly attribute int16u hardwareVersion = 7;
  readonly attribute char_string<64> hardwareVersionString = 8;
  readonly attribute int32u softwareVersion = 9;
  readonly attribute char_string<64> softwareVersionString = 10;
  readonly attribute optional char_string<16> manufacturingDate = 11;
  readonly attribute optional char_string<32> partNumber = 12;
  readonly attribute optional long_char_string<256> productURL = 13;
  readonly attribute optional char_string<64> productLabel = 14;
  readonly attribute optional char_string<32> serialNumber = 15;
  attribute access(write: manage) optional boolean localConfigDisabled = 16;
  readonly attribute optional boolean reachable = 17;
  readonly attribute char_string<32> uniqueID = 18;
  readonly attribute CapabilityMinimaStruct capabilityMinima = 19;
  readonly attribute optional ProductAppearanceStruct productAppearance = 20;
  readonly attribute int32u specificationVersion = 21;
  readonly attribute int16u maxPathsPerInvoke = 22;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  command MfgSpecificPing(): DefaultSuccess = 0;
}

/** This cluster provides attributes and events for determining basic information about Nodes, which supports both
      Commissioning and operational determination of Node characteristics, such as Vendor ID, Product ID and serial number,
      which apply to the whole Node. Also allows setting user device information such as location. */
cluster BasicInformation = 40 {
  revision 3;

  enum ColorEnum : enum8 {
    kBlack = 0;
    kNavy = 1;
    kGreen = 2;
    kTeal = 3;
    kMaroon = 4;
    kPurple = 5;
    kOlive = 6;
    kGray = 7;
    kBlue = 8;
    kLime = 9;
    kAqua = 10;
    kRed = 11;
    kFuchsia = 12;
    kYellow = 13;
    kWhite = 14;
    kNickel = 15;
    kChrome = 16;
    kBrass = 17;
    kCopper = 18;
    kSilver = 19;
    kGold = 20;
  }

  enum ProductFinishEnum : enum8 {
    kOther = 0;
    kMatte = 1;
    kSatin = 2;
    kPolished = 3;
    kRugged = 4;
    kFabric = 5;
  }

  struct CapabilityMinimaStruct {
    int16u caseSessionsPerFabric = 0;
    int16u subscriptionsPerFabric = 1;
  }

  struct ProductAppearanceStruct {
    ProductFinishEnum finish = 0;
    nullable ColorEnum primaryColor = 1;
  }

  critical event StartUp = 0 {
    int32u softwareVersion = 0;
  }

  critical event ShutDown = 1 {
  }

  info event Leave = 2 {
    fabric_idx fabricIndex = 0;
  }

  info event ReachableChanged = 3 {
    boolean reachableNewValue = 0;
  }

  readonly attribute int16u dataModelRevision = 0;
  readonly attribute char_string<32> vendorName = 1;
  readonly attribute vendor_id vendorID = 2;
  readonly attribute char_string<32> productName = 3;
  readonly attribute int16u productID = 4;
  attribute access(write: manage) char_string<32> nodeLabel = 5;
  attribute access(write: administer) char_string<2> location = 6;
  readonly attribute int16u hardwareVersion = 7;
  readonly attribute char_string<64> hardwareVersionString = 8;
  readonly attribute int32u softwareVersion = 9;
  readonly attribute char_string<64> softwareVersionString = 10;
  readonly attribute optional char_string<16> manufacturingDate = 11;
  readonly attribute optional char_string<32> partNumber = 12;
  readonly attribute optional long_char_string<256> productURL = 13;
  readonly attribute optional char_string<64> productLabel = 14;
  readonly attribute optional char_string<32> serialNumber = 15;
  attribute access(write: manage) optional boolean localConfigDisabled = 16;
  readonly attribute optional boolean reachable = 17;
  readonly attribute char_string<32> uniqueID = 18;
  readonly attribute CapabilityMinimaStruct capabilityMinima = 19;
  readonly attribute optional ProductAppearanceStruct productAppearance = 20;
  readonly attribute int32u specificationVersion = 21;
  readonly attribute int16u maxPathsPerInvoke = 22;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  command MfgSpecificPing(): DefaultSuccess = 0;
}

/** Provides an interface for providing OTA software updates */
cluster OtaSoftwareUpdateProvider = 41 {
  revision 1; // NOTE: Default/not specifically set

  enum ApplyUpdateActionEnum : enum8 {
    kProceed = 0;
    kAwaitNextAction = 1;
    kDiscontinue = 2;
  }

  enum DownloadProtocolEnum : enum8 {
    kBDXSynchronous = 0;
    kBDXAsynchronous = 1;
    kHTTPS = 2;
    kVendorSpecific = 3;
  }

  enum StatusEnum : enum8 {
    kUpdateAvailable = 0;
    kBusy = 1;
    kNotAvailable = 2;
    kDownloadProtocolNotSupported = 3;
  }

  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct QueryImageRequest {
    vendor_id vendorID = 0;
    int16u productID = 1;
    int32u softwareVersion = 2;
    DownloadProtocolEnum protocolsSupported[] = 3;
    optional int16u hardwareVersion = 4;
    optional char_string<2> location = 5;
    optional boolean requestorCanConsent = 6;
    optional octet_string<512> metadataForProvider = 7;
  }

  response struct QueryImageResponse = 1 {
    StatusEnum status = 0;
    optional int32u delayedActionTime = 1;
    optional char_string<256> imageURI = 2;
    optional int32u softwareVersion = 3;
    optional char_string<64> softwareVersionString = 4;
    optional octet_string<32> updateToken = 5;
    optional boolean userConsentNeeded = 6;
    optional octet_string<512> metadataForRequestor = 7;
  }

  request struct ApplyUpdateRequestRequest {
    octet_string<32> updateToken = 0;
    int32u newVersion = 1;
  }

  response struct ApplyUpdateResponse = 3 {
    ApplyUpdateActionEnum action = 0;
    int32u delayedActionTime = 1;
  }

  request struct NotifyUpdateAppliedRequest {
    octet_string<32> updateToken = 0;
    int32u softwareVersion = 1;
  }

  /** Determine availability of a new Software Image */
  command QueryImage(QueryImageRequest): QueryImageResponse = 0;
  /** Determine next action to take for a downloaded Software Image */
  command ApplyUpdateRequest(ApplyUpdateRequestRequest): ApplyUpdateResponse = 2;
  /** Notify OTA Provider that an update was applied */
  command NotifyUpdateApplied(NotifyUpdateAppliedRequest): DefaultSuccess = 4;
}

/** Provides an interface for downloading and applying OTA software updates */
cluster OtaSoftwareUpdateRequestor = 42 {
  revision 1; // NOTE: Default/not specifically set

  enum AnnouncementReasonEnum : enum8 {
    kSimpleAnnouncement = 0;
    kUpdateAvailable = 1;
    kUrgentUpdateAvailable = 2;
  }

  enum ChangeReasonEnum : enum8 {
    kUnknown = 0;
    kSuccess = 1;
    kFailure = 2;
    kTimeOut = 3;
    kDelayByProvider = 4;
  }

  enum UpdateStateEnum : enum8 {
    kUnknown = 0;
    kIdle = 1;
    kQuerying = 2;
    kDelayedOnQuery = 3;
    kDownloading = 4;
    kApplying = 5;
    kDelayedOnApply = 6;
    kRollingBack = 7;
    kDelayedOnUserConsent = 8;
  }

  fabric_scoped struct ProviderLocation {
    node_id providerNodeID = 1;
    endpoint_no endpoint = 2;
    fabric_idx fabricIndex = 254;
  }

  info event StateTransition = 0 {
    UpdateStateEnum previousState = 0;
    UpdateStateEnum newState = 1;
    ChangeReasonEnum reason = 2;
    nullable int32u targetSoftwareVersion = 3;
  }

  critical event VersionApplied = 1 {
    int32u softwareVersion = 0;
    int16u productID = 1;
  }

  info event DownloadError = 2 {
    int32u softwareVersion = 0;
    int64u bytesDownloaded = 1;
    nullable int8u progressPercent = 2;
    nullable int64s platformCode = 3;
  }

  attribute access(write: administer) ProviderLocation defaultOTAProviders[] = 0;
  readonly attribute boolean updatePossible = 1;
  readonly attribute UpdateStateEnum updateState = 2;
  readonly attribute nullable int8u updateStateProgress = 3;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct AnnounceOTAProviderRequest {
    node_id providerNodeID = 0;
    vendor_id vendorID = 1;
    AnnouncementReasonEnum announcementReason = 2;
    optional octet_string<512> metadataForNode = 3;
    endpoint_no endpoint = 4;
  }

  /** Announce the presence of an OTA Provider */
  command AnnounceOTAProvider(AnnounceOTAProviderRequest): DefaultSuccess = 0;
}

/** Nodes should be expected to be deployed to any and all regions of the world. These global regions
      may have differing common languages, units of measurements, and numerical formatting
      standards. As such, Nodes that visually or audibly convey information need a mechanism by which
      they can be configured to use a user’s preferred language, units, etc */
cluster LocalizationConfiguration = 43 {
  revision 1; // NOTE: Default/not specifically set

  attribute access(write: manage) char_string<35> activeLocale = 0;
  readonly attribute char_string supportedLocales[] = 1;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Nodes should be expected to be deployed to any and all regions of the world. These global regions
      may have differing preferences for how dates and times are conveyed. As such, Nodes that visually
      or audibly convey time information need a mechanism by which they can be configured to use a
      user’s preferred format. */
cluster TimeFormatLocalization = 44 {
  revision 1; // NOTE: Default/not specifically set

  enum CalendarTypeEnum : enum8 {
    kBuddhist = 0;
    kChinese = 1;
    kCoptic = 2;
    kEthiopian = 3;
    kGregorian = 4;
    kHebrew = 5;
    kIndian = 6;
    kIslamic = 7;
    kJapanese = 8;
    kKorean = 9;
    kPersian = 10;
    kTaiwanese = 11;
    kUseActiveLocale = 255;
  }

  enum HourFormatEnum : enum8 {
    k12hr = 0;
    k24hr = 1;
    kUseActiveLocale = 255;
  }

  bitmap Feature : bitmap32 {
    kCalendarFormat = 0x1;
  }

  attribute access(write: manage) HourFormatEnum hourFormat = 0;
  attribute access(write: manage) optional CalendarTypeEnum activeCalendarType = 1;
  readonly attribute optional CalendarTypeEnum supportedCalendarTypes[] = 2;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Nodes should be expected to be deployed to any and all regions of the world. These global regions
      may have differing preferences for the units in which values are conveyed in communication to a
      user. As such, Nodes that visually or audibly convey measurable values to the user need a
      mechanism by which they can be configured to use a user’s preferred unit. */
cluster UnitLocalization = 45 {
  revision 1;

  enum TempUnitEnum : enum8 {
    kFahrenheit = 0;
    kCelsius = 1;
    kKelvin = 2;
  }

  bitmap Feature : bitmap32 {
    kTemperatureUnit = 0x1;
  }

  attribute access(write: manage) optional TempUnitEnum temperatureUnit = 0;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** This cluster is used to describe the configuration and capabilities of a Device's power system. */
cluster PowerSourceConfiguration = 46 {
  revision 1;

  readonly attribute endpoint_no sources[] = 0;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** This cluster is used to manage global aspects of the Commissioning flow. */
cluster GeneralCommissioning = 48 {
  revision 1; // NOTE: Default/not specifically set

  enum CommissioningErrorEnum : enum8 {
    kOK = 0;
    kValueOutsideRange = 1;
    kInvalidAuthentication = 2;
    kNoFailSafe = 3;
    kBusyWithOtherAdmin = 4;
    kRequiredTCNotAccepted = 5;
    kTCAcknowledgementsNotReceived = 6;
    kTCMinVersionNotMet = 7;
  }

  enum RegulatoryLocationTypeEnum : enum8 {
    kIndoor = 0;
    kOutdoor = 1;
    kIndoorOutdoor = 2;
  }

  bitmap Feature : bitmap32 {
    kTermsAndConditions = 0x1;
  }

  struct BasicCommissioningInfo {
    int16u failSafeExpiryLengthSeconds = 0;
    int16u maxCumulativeFailsafeSeconds = 1;
  }

  attribute access(write: administer) int64u breadcrumb = 0;
  readonly attribute BasicCommissioningInfo basicCommissioningInfo = 1;
  readonly attribute RegulatoryLocationTypeEnum regulatoryConfig = 2;
  readonly attribute RegulatoryLocationTypeEnum locationCapability = 3;
  readonly attribute boolean supportsConcurrentConnection = 4;
  provisional readonly attribute access(read: administer) optional int16u TCAcceptedVersion = 5;
  provisional readonly attribute access(read: administer) optional int16u TCMinRequiredVersion = 6;
  provisional readonly attribute access(read: administer) optional bitmap16 TCAcknowledgements = 7;
  provisional readonly attribute access(read: administer) optional boolean TCAcknowledgementsRequired = 8;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct ArmFailSafeRequest {
    int16u expiryLengthSeconds = 0;
    int64u breadcrumb = 1;
  }

  response struct ArmFailSafeResponse = 1 {
    CommissioningErrorEnum errorCode = 0;
    char_string<128> debugText = 1;
  }

  request struct SetRegulatoryConfigRequest {
    RegulatoryLocationTypeEnum newRegulatoryConfig = 0;
    char_string<2> countryCode = 1;
    int64u breadcrumb = 2;
  }

  response struct SetRegulatoryConfigResponse = 3 {
    CommissioningErrorEnum errorCode = 0;
    char_string debugText = 1;
  }

  response struct CommissioningCompleteResponse = 5 {
    CommissioningErrorEnum errorCode = 0;
    char_string debugText = 1;
  }

  request struct SetTCAcknowledgementsRequest {
    int16u TCVersion = 0;
    bitmap16 TCUserResponse = 1;
  }

  response struct SetTCAcknowledgementsResponse = 7 {
    CommissioningErrorEnum errorCode = 0;
  }

  /** Arm the persistent fail-safe timer with an expiry time of now + ExpiryLengthSeconds using device clock */
  command access(invoke: administer) ArmFailSafe(ArmFailSafeRequest): ArmFailSafeResponse = 0;
  /** Set the regulatory configuration to be used during commissioning */
  command access(invoke: administer) SetRegulatoryConfig(SetRegulatoryConfigRequest): SetRegulatoryConfigResponse = 2;
  /** Signals the Server that the Client has successfully completed all steps of Commissioning/Recofiguration needed during fail-safe period. */
  fabric command access(invoke: administer) CommissioningComplete(): CommissioningCompleteResponse = 4;
  /** This command sets the user acknowledgements received in the Enhanced Setup Flow Terms and Conditions into the node. */
  command access(invoke: administer) SetTCAcknowledgements(SetTCAcknowledgementsRequest): SetTCAcknowledgementsResponse = 6;
}

/** Functionality to configure, enable, disable network credentials and access on a Matter device. */
cluster NetworkCommissioning = 49 {
  revision 1; // NOTE: Default/not specifically set

  enum NetworkCommissioningStatusEnum : enum8 {
    kSuccess = 0;
    kOutOfRange = 1;
    kBoundsExceeded = 2;
    kNetworkIDNotFound = 3;
    kDuplicateNetworkID = 4;
    kNetworkNotFound = 5;
    kRegulatoryError = 6;
    kAuthFailure = 7;
    kUnsupportedSecurity = 8;
    kOtherConnectionFailure = 9;
    kIPV6Failed = 10;
    kIPBindFailed = 11;
    kUnknownError = 12;
  }

  enum WiFiBandEnum : enum8 {
    k2G4 = 0;
    k3G65 = 1;
    k5G = 2;
    k6G = 3;
    k60G = 4;
    k1G = 5;
  }

  bitmap Feature : bitmap32 {
    kWiFiNetworkInterface = 0x1;
    kThreadNetworkInterface = 0x2;
    kEthernetNetworkInterface = 0x4;
    kPerDeviceCredentials = 0x8;
  }

  bitmap ThreadCapabilitiesBitmap : bitmap16 {
    kIsBorderRouterCapable = 0x1;
    kIsRouterCapable = 0x2;
    kIsSleepyEndDeviceCapable = 0x4;
    kIsFullThreadDevice = 0x8;
    kIsSynchronizedSleepyEndDeviceCapable = 0x10;
  }

  bitmap WiFiSecurityBitmap : bitmap8 {
    kUnencrypted = 0x1;
    kWEP = 0x2;
    kWPAPersonal = 0x4;
    kWPA2Personal = 0x8;
    kWPA3Personal = 0x10;
    kWPA3MatterPDC = 0x20;
  }

  struct NetworkInfoStruct {
    octet_string<32> networkID = 0;
    boolean connected = 1;
    optional nullable octet_string<20> networkIdentifier = 2;
    optional nullable octet_string<20> clientIdentifier = 3;
  }

  struct ThreadInterfaceScanResultStruct {
    int16u panId = 0;
    int64u extendedPanId = 1;
    char_string<16> networkName = 2;
    int16u channel = 3;
    int8u version = 4;
    octet_string<8> extendedAddress = 5;
    int8s rssi = 6;
    int8u lqi = 7;
  }

  struct WiFiInterfaceScanResultStruct {
    WiFiSecurityBitmap security = 0;
    octet_string<32> ssid = 1;
    octet_string<6> bssid = 2;
    int16u channel = 3;
    WiFiBandEnum wiFiBand = 4;
    int8s rssi = 5;
  }

  readonly attribute access(read: administer) int8u maxNetworks = 0;
  readonly attribute access(read: administer) NetworkInfoStruct networks[] = 1;
  readonly attribute optional int8u scanMaxTimeSeconds = 2;
  readonly attribute optional int8u connectMaxTimeSeconds = 3;
  attribute access(write: administer) boolean interfaceEnabled = 4;
  readonly attribute access(read: administer) nullable NetworkCommissioningStatusEnum lastNetworkingStatus = 5;
  readonly attribute access(read: administer) nullable octet_string<32> lastNetworkID = 6;
  readonly attribute access(read: administer) nullable int32s lastConnectErrorValue = 7;
  provisional readonly attribute optional WiFiBandEnum supportedWiFiBands[] = 8;
  provisional readonly attribute optional ThreadCapabilitiesBitmap supportedThreadFeatures = 9;
  provisional readonly attribute optional int16u threadVersion = 10;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct ScanNetworksRequest {
    optional nullable octet_string<32> ssid = 0;
    optional int64u breadcrumb = 1;
  }

  response struct ScanNetworksResponse = 1 {
    NetworkCommissioningStatusEnum networkingStatus = 0;
    optional char_string debugText = 1;
    optional WiFiInterfaceScanResultStruct wiFiScanResults[] = 2;
    optional ThreadInterfaceScanResultStruct threadScanResults[] = 3;
  }

  request struct AddOrUpdateWiFiNetworkRequest {
    octet_string<32> ssid = 0;
    octet_string<64> credentials = 1;
    optional int64u breadcrumb = 2;
    optional octet_string<140> networkIdentity = 3;
    optional octet_string<20> clientIdentifier = 4;
    optional octet_string<32> possessionNonce = 5;
  }

  request struct AddOrUpdateThreadNetworkRequest {
    octet_string<254> operationalDataset = 0;
    optional int64u breadcrumb = 1;
  }

  request struct RemoveNetworkRequest {
    octet_string<32> networkID = 0;
    optional int64u breadcrumb = 1;
  }

  response struct NetworkConfigResponse = 5 {
    NetworkCommissioningStatusEnum networkingStatus = 0;
    optional char_string<512> debugText = 1;
    optional int8u networkIndex = 2;
    optional octet_string<140> clientIdentity = 3;
    optional octet_string<64> possessionSignature = 4;
  }

  request struct ConnectNetworkRequest {
    octet_string<32> networkID = 0;
    optional int64u breadcrumb = 1;
  }

  response struct ConnectNetworkResponse = 7 {
    NetworkCommissioningStatusEnum networkingStatus = 0;
    optional char_string debugText = 1;
    nullable int32s errorValue = 2;
  }

  request struct ReorderNetworkRequest {
    octet_string<32> networkID = 0;
    int8u networkIndex = 1;
    optional int64u breadcrumb = 2;
  }

  request struct QueryIdentityRequest {
    octet_string<20> keyIdentifier = 0;
    optional octet_string<32> possessionNonce = 1;
  }

  response struct QueryIdentityResponse = 10 {
    octet_string<140> identity = 0;
    optional octet_string<64> possessionSignature = 1;
  }

  /** Detemine the set of networks the device sees as available. */
  command access(invoke: administer) ScanNetworks(ScanNetworksRequest): ScanNetworksResponse = 0;
  /** Add or update the credentials for a given Wi-Fi network. */
  command access(invoke: administer) AddOrUpdateWiFiNetwork(AddOrUpdateWiFiNetworkRequest): NetworkConfigResponse = 2;
  /** Add or update the credentials for a given Thread network. */
  command access(invoke: administer) AddOrUpdateThreadNetwork(AddOrUpdateThreadNetworkRequest): NetworkConfigResponse = 3;
  /** Remove the definition of a given network (including its credentials). */
  command access(invoke: administer) RemoveNetwork(RemoveNetworkRequest): NetworkConfigResponse = 4;
  /** Connect to the specified network, using previously-defined credentials. */
  command access(invoke: administer) ConnectNetwork(ConnectNetworkRequest): ConnectNetworkResponse = 6;
  /** Modify the order in which networks will be presented in the Networks attribute. */
  command access(invoke: administer) ReorderNetwork(ReorderNetworkRequest): NetworkConfigResponse = 8;
  /** Retrieve details about and optionally proof of possession of a network client identity. */
  command access(invoke: administer) QueryIdentity(QueryIdentityRequest): QueryIdentityResponse = 9;
}

/** The cluster provides commands for retrieving unstructured diagnostic logs from a Node that may be used to aid in diagnostics. */
cluster DiagnosticLogs = 50 {
  revision 1; // NOTE: Default/not specifically set

  enum IntentEnum : enum8 {
    kEndUserSupport = 0;
    kNetworkDiag = 1;
    kCrashLogs = 2;
  }

  enum StatusEnum : enum8 {
    kSuccess = 0;
    kExhausted = 1;
    kNoLogs = 2;
    kBusy = 3;
    kDenied = 4;
  }

  enum TransferProtocolEnum : enum8 {
    kResponsePayload = 0;
    kBDX = 1;
  }

  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct RetrieveLogsRequestRequest {
    IntentEnum intent = 0;
    TransferProtocolEnum requestedProtocol = 1;
    optional char_string<32> transferFileDesignator = 2;
  }

  response struct RetrieveLogsResponse = 1 {
    StatusEnum status = 0;
    long_octet_string logContent = 1;
    optional epoch_us UTCTimeStamp = 2;
    optional systime_us timeSinceBoot = 3;
  }

  /** Retrieving diagnostic logs from a Node */
  command RetrieveLogsRequest(RetrieveLogsRequestRequest): RetrieveLogsResponse = 0;
}

/** The General Diagnostics Cluster, along with other diagnostics clusters, provide a means to acquire standardized diagnostics metrics that MAY be used by a Node to assist a user or Administrative Node in diagnosing potential problems. */
cluster GeneralDiagnostics = 51 {
  revision 2;

  enum BootReasonEnum : enum8 {
    kUnspecified = 0;
    kPowerOnReboot = 1;
    kBrownOutReset = 2;
    kSoftwareWatchdogReset = 3;
    kHardwareWatchdogReset = 4;
    kSoftwareUpdateCompleted = 5;
    kSoftwareReset = 6;
  }

  enum HardwareFaultEnum : enum8 {
    kUnspecified = 0;
    kRadio = 1;
    kSensor = 2;
    kResettableOverTemp = 3;
    kNonResettableOverTemp = 4;
    kPowerSource = 5;
    kVisualDisplayFault = 6;
    kAudioOutputFault = 7;
    kUserInterfaceFault = 8;
    kNonVolatileMemoryError = 9;
    kTamperDetected = 10;
  }

  enum InterfaceTypeEnum : enum8 {
    kUnspecified = 0;
    kWiFi = 1;
    kEthernet = 2;
    kCellular = 3;
    kThread = 4;
  }

  enum NetworkFaultEnum : enum8 {
    kUnspecified = 0;
    kHardwareFailure = 1;
    kNetworkJammed = 2;
    kConnectionFailed = 3;
  }

  enum RadioFaultEnum : enum8 {
    kUnspecified = 0;
    kWiFiFault = 1;
    kCellularFault = 2;
    kThreadFault = 3;
    kNFCFault = 4;
    kBLEFault = 5;
    kEthernetFault = 6;
  }

  bitmap Feature : bitmap32 {
    kDataModelTest = 0x1;
  }

  struct NetworkInterface {
    char_string<32> name = 0;
    boolean isOperational = 1;
    nullable boolean offPremiseServicesReachableIPv4 = 2;
    nullable boolean offPremiseServicesReachableIPv6 = 3;
    octet_string<8> hardwareAddress = 4;
    octet_string IPv4Addresses[] = 5;
    octet_string IPv6Addresses[] = 6;
    InterfaceTypeEnum type = 7;
  }

  critical event HardwareFaultChange = 0 {
    HardwareFaultEnum current[] = 0;
    HardwareFaultEnum previous[] = 1;
  }

  critical event RadioFaultChange = 1 {
    RadioFaultEnum current[] = 0;
    RadioFaultEnum previous[] = 1;
  }

  critical event NetworkFaultChange = 2 {
    NetworkFaultEnum current[] = 0;
    NetworkFaultEnum previous[] = 1;
  }

  critical event BootReason = 3 {
    BootReasonEnum bootReason = 0;
  }

  readonly attribute NetworkInterface networkInterfaces[] = 0;
  readonly attribute int16u rebootCount = 1;
  readonly attribute optional int64u upTime = 2;
  readonly attribute optional int32u totalOperationalHours = 3;
  readonly attribute optional BootReasonEnum bootReason = 4;
  readonly attribute optional HardwareFaultEnum activeHardwareFaults[] = 5;
  readonly attribute optional RadioFaultEnum activeRadioFaults[] = 6;
  readonly attribute optional NetworkFaultEnum activeNetworkFaults[] = 7;
  readonly attribute boolean testEventTriggersEnabled = 8;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct TestEventTriggerRequest {
    octet_string<16> enableKey = 0;
    int64u eventTrigger = 1;
  }

  response struct TimeSnapshotResponse = 2 {
    systime_ms systemTimeMs = 0;
    nullable posix_ms posixTimeMs = 1;
  }

  request struct PayloadTestRequestRequest {
    octet_string<16> enableKey = 0;
    int8u value = 1;
    int16u count = 2;
  }

  response struct PayloadTestResponse = 4 {
    octet_string payload = 0;
  }

  /** Provide a means for certification tests to trigger some test-plan-specific events */
  command access(invoke: manage) TestEventTrigger(TestEventTriggerRequest): DefaultSuccess = 0;
  /** Take a snapshot of system time and epoch time. */
  command TimeSnapshot(): TimeSnapshotResponse = 1;
  /** Request a variable length payload response. */
  command PayloadTestRequest(PayloadTestRequestRequest): PayloadTestResponse = 3;
}

/** The Software Diagnostics Cluster provides a means to acquire standardized diagnostics metrics that MAY be used by a Node to assist a user or Administrative Node in diagnosing potential problems. */
cluster SoftwareDiagnostics = 52 {
  revision 1; // NOTE: Default/not specifically set

  bitmap Feature : bitmap32 {
    kWatermarks = 0x1;
  }

  struct ThreadMetricsStruct {
    int64u id = 0;
    optional char_string<8> name = 1;
    optional int32u stackFreeCurrent = 2;
    optional int32u stackFreeMinimum = 3;
    optional int32u stackSize = 4;
  }

  info event SoftwareFault = 0 {
    int64u id = 0;
    optional char_string name = 1;
    optional octet_string faultRecording = 2;
  }

  readonly attribute optional ThreadMetricsStruct threadMetrics[] = 0;
  readonly attribute optional int64u currentHeapFree = 1;
  readonly attribute optional int64u currentHeapUsed = 2;
  readonly attribute optional int64u currentHeapHighWatermark = 3;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  /** Reception of this command SHALL reset the values: The StackFreeMinimum field of the ThreadMetrics attribute, CurrentHeapHighWaterMark attribute. */
  command access(invoke: manage) ResetWatermarks(): DefaultSuccess = 0;
}

/** The Thread Network Diagnostics Cluster provides a means to acquire standardized diagnostics metrics that MAY be used by a Node to assist a user or Administrative Node in diagnosing potential problems */
cluster ThreadNetworkDiagnostics = 53 {
  revision 2;

  enum ConnectionStatusEnum : enum8 {
    kConnected = 0;
    kNotConnected = 1;
  }

  enum NetworkFaultEnum : enum8 {
    kUnspecified = 0;
    kLinkDown = 1;
    kHardwareFailure = 2;
    kNetworkJammed = 3;
  }

  enum RoutingRoleEnum : enum8 {
    kUnspecified = 0;
    kUnassigned = 1;
    kSleepyEndDevice = 2;
    kEndDevice = 3;
    kREED = 4;
    kRouter = 5;
    kLeader = 6;
  }

  bitmap Feature : bitmap32 {
    kPacketCounts = 0x1;
    kErrorCounts = 0x2;
    kMLECounts = 0x4;
    kMACCounts = 0x8;
  }

  struct NeighborTableStruct {
    int64u extAddress = 0;
    int32u age = 1;
    int16u rloc16 = 2;
    int32u linkFrameCounter = 3;
    int32u mleFrameCounter = 4;
    int8u lqi = 5;
    nullable int8s averageRssi = 6;
    nullable int8s lastRssi = 7;
    int8u frameErrorRate = 8;
    int8u messageErrorRate = 9;
    boolean rxOnWhenIdle = 10;
    boolean fullThreadDevice = 11;
    boolean fullNetworkData = 12;
    boolean isChild = 13;
  }

  struct OperationalDatasetComponents {
    boolean activeTimestampPresent = 0;
    boolean pendingTimestampPresent = 1;
    boolean masterKeyPresent = 2;
    boolean networkNamePresent = 3;
    boolean extendedPanIdPresent = 4;
    boolean meshLocalPrefixPresent = 5;
    boolean delayPresent = 6;
    boolean panIdPresent = 7;
    boolean channelPresent = 8;
    boolean pskcPresent = 9;
    boolean securityPolicyPresent = 10;
    boolean channelMaskPresent = 11;
  }

  struct RouteTableStruct {
    int64u extAddress = 0;
    int16u rloc16 = 1;
    int8u routerId = 2;
    int8u nextHop = 3;
    int8u pathCost = 4;
    int8u LQIIn = 5;
    int8u LQIOut = 6;
    int8u age = 7;
    boolean allocated = 8;
    boolean linkEstablished = 9;
  }

  struct SecurityPolicy {
    int16u rotationTime = 0;
    int16u flags = 1;
  }

  info event ConnectionStatus = 0 {
    ConnectionStatusEnum connectionStatus = 0;
  }

  info event NetworkFaultChange = 1 {
    NetworkFaultEnum current[] = 0;
    NetworkFaultEnum previous[] = 1;
  }

  readonly attribute nullable int16u channel = 0;
  readonly attribute nullable RoutingRoleEnum routingRole = 1;
  readonly attribute nullable char_string<16> networkName = 2;
  readonly attribute nullable int16u panId = 3;
  readonly attribute nullable int64u extendedPanId = 4;
  readonly attribute nullable octet_string<17> meshLocalPrefix = 5;
  readonly attribute optional int64u overrunCount = 6;
  readonly attribute NeighborTableStruct neighborTable[] = 7;
  readonly attribute RouteTableStruct routeTable[] = 8;
  readonly attribute nullable int32u partitionId = 9;
  readonly attribute nullable int16u weighting = 10;
  readonly attribute nullable int16u dataVersion = 11;
  readonly attribute nullable int16u stableDataVersion = 12;
  readonly attribute nullable int8u leaderRouterId = 13;
  readonly attribute optional int16u detachedRoleCount = 14;
  readonly attribute optional int16u childRoleCount = 15;
  readonly attribute optional int16u routerRoleCount = 16;
  readonly attribute optional int16u leaderRoleCount = 17;
  readonly attribute optional int16u attachAttemptCount = 18;
  readonly attribute optional int16u partitionIdChangeCount = 19;
  readonly attribute optional int16u betterPartitionAttachAttemptCount = 20;
  readonly attribute optional int16u parentChangeCount = 21;
  readonly attribute optional int32u txTotalCount = 22;
  readonly attribute optional int32u txUnicastCount = 23;
  readonly attribute optional int32u txBroadcastCount = 24;
  readonly attribute optional int32u txAckRequestedCount = 25;
  readonly attribute optional int32u txAckedCount = 26;
  readonly attribute optional int32u txNoAckRequestedCount = 27;
  readonly attribute optional int32u txDataCount = 28;
  readonly attribute optional int32u txDataPollCount = 29;
  readonly attribute optional int32u txBeaconCount = 30;
  readonly attribute optional int32u txBeaconRequestCount = 31;
  readonly attribute optional int32u txOtherCount = 32;
  readonly attribute optional int32u txRetryCount = 33;
  readonly attribute optional int32u txDirectMaxRetryExpiryCount = 34;
  readonly attribute optional int32u txIndirectMaxRetryExpiryCount = 35;
  readonly attribute optional int32u txErrCcaCount = 36;
  readonly attribute optional int32u txErrAbortCount = 37;
  readonly attribute optional int32u txErrBusyChannelCount = 38;
  readonly attribute optional int32u rxTotalCount = 39;
  readonly attribute optional int32u rxUnicastCount = 40;
  readonly attribute optional int32u rxBroadcastCount = 41;
  readonly attribute optional int32u rxDataCount = 42;
  readonly attribute optional int32u rxDataPollCount = 43;
  readonly attribute optional int32u rxBeaconCount = 44;
  readonly attribute optional int32u rxBeaconRequestCount = 45;
  readonly attribute optional int32u rxOtherCount = 46;
  readonly attribute optional int32u rxAddressFilteredCount = 47;
  readonly attribute optional int32u rxDestAddrFilteredCount = 48;
  readonly attribute optional int32u rxDuplicatedCount = 49;
  readonly attribute optional int32u rxErrNoFrameCount = 50;
  readonly attribute optional int32u rxErrUnknownNeighborCount = 51;
  readonly attribute optional int32u rxErrInvalidSrcAddrCount = 52;
  readonly attribute optional int32u rxErrSecCount = 53;
  readonly attribute optional int32u rxErrFcsCount = 54;
  readonly attribute optional int32u rxErrOtherCount = 55;
  readonly attribute optional nullable int64u activeTimestamp = 56;
  readonly attribute optional nullable int64u pendingTimestamp = 57;
  readonly attribute optional nullable int32u delay = 58;
  readonly attribute nullable SecurityPolicy securityPolicy = 59;
  readonly attribute nullable octet_string<4> channelPage0Mask = 60;
  readonly attribute nullable OperationalDatasetComponents operationalDatasetComponents = 61;
  readonly attribute NetworkFaultEnum activeNetworkFaultsList[] = 62;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  /** Reception of this command SHALL reset the OverrunCount attributes to 0 */
  command access(invoke: manage) ResetCounts(): DefaultSuccess = 0;
}

/** The Wi-Fi Network Diagnostics Cluster provides a means to acquire standardized diagnostics metrics that MAY be used by a Node to assist a user or Administrative Node in diagnosing potential problems. */
cluster WiFiNetworkDiagnostics = 54 {
  revision 1; // NOTE: Default/not specifically set

  enum AssociationFailureCauseEnum : enum8 {
    kUnknown = 0;
    kAssociationFailed = 1;
    kAuthenticationFailed = 2;
    kSsidNotFound = 3;
  }

  enum ConnectionStatusEnum : enum8 {
    kConnected = 0;
    kNotConnected = 1;
  }

  enum SecurityTypeEnum : enum8 {
    kUnspecified = 0;
    kNone = 1;
    kWEP = 2;
    kWPA = 3;
    kWPA2 = 4;
    kWPA3 = 5;
  }

  enum WiFiVersionEnum : enum8 {
    kA = 0;
    kB = 1;
    kG = 2;
    kN = 3;
    kAc = 4;
    kAx = 5;
    kAh = 6;
  }

  bitmap Feature : bitmap32 {
    kPacketCounts = 0x1;
    kErrorCounts = 0x2;
  }

  info event Disconnection = 0 {
    int16u reasonCode = 0;
  }

  info event AssociationFailure = 1 {
    AssociationFailureCauseEnum associationFailureCause = 0;
    int16u status = 1;
  }

  info event ConnectionStatus = 2 {
    ConnectionStatusEnum connectionStatus = 0;
  }

  readonly attribute nullable octet_string<6> bssid = 0;
  readonly attribute nullable SecurityTypeEnum securityType = 1;
  readonly attribute nullable WiFiVersionEnum wiFiVersion = 2;
  readonly attribute nullable int16u channelNumber = 3;
  readonly attribute nullable int8s rssi = 4;
  readonly attribute optional nullable int32u beaconLostCount = 5;
  readonly attribute optional nullable int32u beaconRxCount = 6;
  readonly attribute optional nullable int32u packetMulticastRxCount = 7;
  readonly attribute optional nullable int32u packetMulticastTxCount = 8;
  readonly attribute optional nullable int32u packetUnicastRxCount = 9;
  readonly attribute optional nullable int32u packetUnicastTxCount = 10;
  readonly attribute optional nullable int64u currentMaxRate = 11;
  readonly attribute optional nullable int64u overrunCount = 12;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  /** Reception of this command SHALL reset the Breacon and Packet related count attributes to 0 */
  command ResetCounts(): DefaultSuccess = 0;
}

/** The Ethernet Network Diagnostics Cluster provides a means to acquire standardized diagnostics metrics that MAY be used by a Node to assist a user or Administrative Node in diagnosing potential problems. */
cluster EthernetNetworkDiagnostics = 55 {
  revision 1; // NOTE: Default/not specifically set

  enum PHYRateEnum : enum8 {
    kRate10M = 0;
    kRate100M = 1;
    kRate1G = 2;
    kRate25G = 3;
    kRate5G = 4;
    kRate10G = 5;
    kRate40G = 6;
    kRate100G = 7;
    kRate200G = 8;
    kRate400G = 9;
  }

  bitmap Feature : bitmap32 {
    kPacketCounts = 0x1;
    kErrorCounts = 0x2;
  }

  readonly attribute optional nullable PHYRateEnum PHYRate = 0;
  readonly attribute optional nullable boolean fullDuplex = 1;
  readonly attribute optional int64u packetRxCount = 2;
  readonly attribute optional int64u packetTxCount = 3;
  readonly attribute optional int64u txErrCount = 4;
  readonly attribute optional int64u collisionCount = 5;
  readonly attribute optional int64u overrunCount = 6;
  readonly attribute optional nullable boolean carrierDetect = 7;
  readonly attribute optional int64u timeSinceReset = 8;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  /** Reception of this command SHALL reset the attributes: PacketRxCount, PacketTxCount, TxErrCount, CollisionCount, OverrunCount to 0 */
  command access(invoke: manage) ResetCounts(): DefaultSuccess = 0;
}

/** This Cluster serves two purposes towards a Node communicating with a Bridge: indicate that the functionality on
          the Endpoint where it is placed (and its Parts) is bridged from a non-CHIP technology; and provide a centralized
          collection of attributes that the Node MAY collect to aid in conveying information regarding the Bridged Device to a user,
          such as the vendor name, the model name, or user-assigned name. */
cluster BridgedDeviceBasicInformation = 57 {
  revision 3;

  enum ColorEnum : enum8 {
    kBlack = 0;
    kNavy = 1;
    kGreen = 2;
    kTeal = 3;
    kMaroon = 4;
    kPurple = 5;
    kOlive = 6;
    kGray = 7;
    kBlue = 8;
    kLime = 9;
    kAqua = 10;
    kRed = 11;
    kFuchsia = 12;
    kYellow = 13;
    kWhite = 14;
    kNickel = 15;
    kChrome = 16;
    kBrass = 17;
    kCopper = 18;
    kSilver = 19;
    kGold = 20;
  }

  enum ProductFinishEnum : enum8 {
    kOther = 0;
    kMatte = 1;
    kSatin = 2;
    kPolished = 3;
    kRugged = 4;
    kFabric = 5;
  }

  bitmap Feature : bitmap32 {
    kBridgedICDSupport = 0x100000;
  }

  struct ProductAppearanceStruct {
    ProductFinishEnum finish = 0;
    nullable ColorEnum primaryColor = 1;
  }

  critical event StartUp = 0 {
    int32u softwareVersion = 0;
  }

  critical event ShutDown = 1 {
  }

  info event Leave = 2 {
  }

  info event ReachableChanged = 3 {
    boolean reachableNewValue = 0;
  }

  info event ActiveChanged = 128 {
    int32u promisedActiveDuration = 0;
  }

  readonly attribute optional char_string<32> vendorName = 1;
  readonly attribute optional vendor_id vendorID = 2;
  readonly attribute optional char_string<32> productName = 3;
  readonly attribute optional int16u productID = 4;
  attribute optional char_string<32> nodeLabel = 5;
  readonly attribute optional int16u hardwareVersion = 7;
  readonly attribute optional char_string<64> hardwareVersionString = 8;
  readonly attribute optional int32u softwareVersion = 9;
  readonly attribute optional char_string<64> softwareVersionString = 10;
  readonly attribute optional char_string<16> manufacturingDate = 11;
  readonly attribute optional char_string<32> partNumber = 12;
  readonly attribute optional long_char_string<256> productURL = 13;
  readonly attribute optional char_string<64> productLabel = 14;
  readonly attribute optional char_string<32> serialNumber = 15;
  readonly attribute boolean reachable = 17;
  readonly attribute char_string<32> uniqueID = 18;
  readonly attribute optional ProductAppearanceStruct productAppearance = 20;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct KeepActiveRequest {
    int32u stayActiveDuration = 0;
    int32u timeoutMs = 1;
  }

  /** The server SHALL attempt to keep the devices specified active for StayActiveDuration milliseconds when they are next active. */
  command KeepActive(KeepActiveRequest): DefaultSuccess = 128;
}

/** Commands to trigger a Node to allow a new Administrator to commission it. */
cluster AdministratorCommissioning = 60 {
  revision 1; // NOTE: Default/not specifically set

  enum CommissioningWindowStatusEnum : enum8 {
    kWindowNotOpen = 0;
    kEnhancedWindowOpen = 1;
    kBasicWindowOpen = 2;
  }

  enum StatusCode : enum8 {
    kBusy = 2;
    kPAKEParameterError = 3;
    kWindowNotOpen = 4;
  }

  bitmap Feature : bitmap32 {
    kBasic = 0x1;
  }

  readonly attribute CommissioningWindowStatusEnum windowStatus = 0;
  readonly attribute nullable fabric_idx adminFabricIndex = 1;
  readonly attribute nullable vendor_id adminVendorId = 2;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct OpenCommissioningWindowRequest {
    int16u commissioningTimeout = 0;
    octet_string PAKEPasscodeVerifier = 1;
    int16u discriminator = 2;
    int32u iterations = 3;
    octet_string<32> salt = 4;
  }

  request struct OpenBasicCommissioningWindowRequest {
    int16u commissioningTimeout = 0;
  }

  /** This command is used by a current Administrator to instruct a Node to go into commissioning mode using enhanced commissioning method. */
  timed command access(invoke: administer) OpenCommissioningWindow(OpenCommissioningWindowRequest): DefaultSuccess = 0;
  /** This command is used by a current Administrator to instruct a Node to go into commissioning mode using basic commissioning method, if the node supports it. */
  timed command access(invoke: administer) OpenBasicCommissioningWindow(OpenBasicCommissioningWindowRequest): DefaultSuccess = 1;
  /** This command is used by a current Administrator to instruct a Node to revoke any active Open Commissioning Window or Open Basic Commissioning Window command. */
  timed command access(invoke: administer) RevokeCommissioning(): DefaultSuccess = 2;
}

/** This cluster is used to add or remove Operational Credentials on a Commissionee or Node, as well as manage the associated Fabrics. */
cluster OperationalCredentials = 62 {
  revision 1; // NOTE: Default/not specifically set

  enum CertificateChainTypeEnum : enum8 {
    kDACCertificate = 1;
    kPAICertificate = 2;
  }

  enum NodeOperationalCertStatusEnum : enum8 {
    kOK = 0;
    kInvalidPublicKey = 1;
    kInvalidNodeOpId = 2;
    kInvalidNOC = 3;
    kMissingCsr = 4;
    kTableFull = 5;
    kInvalidAdminSubject = 6;
    kFabricConflict = 9;
    kLabelConflict = 10;
    kInvalidFabricIndex = 11;
  }

  fabric_scoped struct FabricDescriptorStruct {
    octet_string<65> rootPublicKey = 1;
    vendor_id vendorID = 2;
    fabric_id fabricID = 3;
    node_id nodeID = 4;
    char_string<32> label = 5;
    fabric_idx fabricIndex = 254;
  }

  fabric_scoped struct NOCStruct {
    fabric_sensitive octet_string noc = 1;
    nullable fabric_sensitive octet_string icac = 2;
    fabric_idx fabricIndex = 254;
  }

  readonly attribute access(read: administer) NOCStruct NOCs[] = 0;
  readonly attribute FabricDescriptorStruct fabrics[] = 1;
  readonly attribute int8u supportedFabrics = 2;
  readonly attribute int8u commissionedFabrics = 3;
  readonly attribute octet_string trustedRootCertificates[] = 4;
  readonly attribute int8u currentFabricIndex = 5;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct AttestationRequestRequest {
    octet_string<32> attestationNonce = 0;
  }

  response struct AttestationResponse = 1 {
    octet_string<900> attestationElements = 0;
    octet_string<64> attestationSignature = 1;
  }

  request struct CertificateChainRequestRequest {
    CertificateChainTypeEnum certificateType = 0;
  }

  response struct CertificateChainResponse = 3 {
    octet_string<600> certificate = 0;
  }

  request struct CSRRequestRequest {
    octet_string<32> CSRNonce = 0;
    optional boolean isForUpdateNOC = 1;
  }

  response struct CSRResponse = 5 {
    octet_string NOCSRElements = 0;
    octet_string attestationSignature = 1;
  }

  request struct AddNOCRequest {
    octet_string<400> NOCValue = 0;
    optional octet_string<400> ICACValue = 1;
    octet_string<16> IPKValue = 2;
    int64u caseAdminSubject = 3;
    vendor_id adminVendorId = 4;
  }

  request struct UpdateNOCRequest {
    octet_string NOCValue = 0;
    optional octet_string ICACValue = 1;
  }

  response struct NOCResponse = 8 {
    NodeOperationalCertStatusEnum statusCode = 0;
    optional fabric_idx fabricIndex = 1;
    optional char_string<128> debugText = 2;
  }

  request struct UpdateFabricLabelRequest {
    char_string<32> label = 0;
  }

  request struct RemoveFabricRequest {
    fabric_idx fabricIndex = 0;
  }

  request struct AddTrustedRootCertificateRequest {
    octet_string rootCACertificate = 0;
  }

  /** Sender is requesting attestation information from the receiver. */
  command access(invoke: administer) AttestationRequest(AttestationRequestRequest): AttestationResponse = 0;
  /** Sender is requesting a device attestation certificate from the receiver. */
  command access(invoke: administer) CertificateChainRequest(CertificateChainRequestRequest): CertificateChainResponse = 2;
  /** Sender is requesting a certificate signing request (CSR) from the receiver. */
  command access(invoke: administer) CSRRequest(CSRRequestRequest): CSRResponse = 4;
  /** Sender is requesting to add the new node operational certificates. */
  command access(invoke: administer) AddNOC(AddNOCRequest): NOCResponse = 6;
  /** Sender is requesting to update the node operational certificates. */
  fabric command access(invoke: administer) UpdateNOC(UpdateNOCRequest): NOCResponse = 7;
  /** This command SHALL be used by an Administrative Node to set the user-visible Label field for a given Fabric, as reflected by entries in the Fabrics attribute. */
  fabric command access(invoke: administer) UpdateFabricLabel(UpdateFabricLabelRequest): NOCResponse = 9;
  /** This command is used by Administrative Nodes to remove a given fabric index and delete all associated fabric-scoped data. */
  command access(invoke: administer) RemoveFabric(RemoveFabricRequest): NOCResponse = 10;
  /** This command SHALL add a Trusted Root CA Certificate, provided as its CHIP Certificate representation. */
  command access(invoke: administer) AddTrustedRootCertificate(AddTrustedRootCertificateRequest): DefaultSuccess = 11;
}

/** The Group Key Management Cluster is the mechanism by which group keys are managed. */
cluster GroupKeyManagement = 63 {
  revision 1; // NOTE: Default/not specifically set

  enum GroupKeySecurityPolicyEnum : enum8 {
    kTrustFirst = 0;
    kCacheAndSync = 1;
  }

  bitmap Feature : bitmap32 {
    kCacheAndSync = 0x1;
  }

  fabric_scoped struct GroupInfoMapStruct {
    group_id groupId = 1;
    endpoint_no endpoints[] = 2;
    optional char_string<16> groupName = 3;
    fabric_idx fabricIndex = 254;
  }

  fabric_scoped struct GroupKeyMapStruct {
    group_id groupId = 1;
    int16u groupKeySetID = 2;
    fabric_idx fabricIndex = 254;
  }

  struct GroupKeySetStruct {
    int16u groupKeySetID = 0;
    GroupKeySecurityPolicyEnum groupKeySecurityPolicy = 1;
    nullable octet_string<16> epochKey0 = 2;
    nullable epoch_us epochStartTime0 = 3;
    nullable octet_string<16> epochKey1 = 4;
    nullable epoch_us epochStartTime1 = 5;
    nullable octet_string<16> epochKey2 = 6;
    nullable epoch_us epochStartTime2 = 7;
  }

  attribute access(write: manage) GroupKeyMapStruct groupKeyMap[] = 0;
  readonly attribute GroupInfoMapStruct groupTable[] = 1;
  readonly attribute int16u maxGroupsPerFabric = 2;
  readonly attribute int16u maxGroupKeysPerFabric = 3;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct KeySetWriteRequest {
    GroupKeySetStruct groupKeySet = 0;
  }

  request struct KeySetReadRequest {
    int16u groupKeySetID = 0;
  }

  response struct KeySetReadResponse = 2 {
    GroupKeySetStruct groupKeySet = 0;
  }

  request struct KeySetRemoveRequest {
    int16u groupKeySetID = 0;
  }

  response struct KeySetReadAllIndicesResponse = 5 {
    int16u groupKeySetIDs[] = 0;
  }

  /** Write a new set of keys for the given key set id. */
  fabric command access(invoke: administer) KeySetWrite(KeySetWriteRequest): DefaultSuccess = 0;
  /** Read the keys for a given key set id. */
  fabric command access(invoke: administer) KeySetRead(KeySetReadRequest): KeySetReadResponse = 1;
  /** Revoke a Root Key from a Group */
  fabric command access(invoke: administer) KeySetRemove(KeySetRemoveRequest): DefaultSuccess = 3;
  /** Return the list of Group Key Sets associated with the accessing fabric */
  fabric command access(invoke: administer) KeySetReadAllIndices(): KeySetReadAllIndicesResponse = 4;
}

/** The User Label Cluster provides a feature to tag an endpoint with zero or more labels. */
cluster UserLabel = 65 {
  revision 1; // NOTE: Default/not specifically set

  struct LabelStruct {
    char_string<16> label = 0;
    char_string<16> value = 1;
  }

  attribute access(write: manage) LabelStruct labelList[] = 0;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Attributes and commands for selecting a mode from a list of supported options. */
cluster LaundryWasherMode = 81 {
  revision 2;

  enum ModeTag : enum16 {
    kAuto = 0;
    kQuick = 1;
    kQuiet = 2;
    kLowNoise = 3;
    kLowEnergy = 4;
    kVacation = 5;
    kMin = 6;
    kMax = 7;
    kNight = 8;
    kDay = 9;
    kNormal = 16384;
    kDelicate = 16385;
    kHeavy = 16386;
    kWhites = 16387;
  }

  bitmap Feature : bitmap32 {
    kOnOff = 0x1;
  }

  struct ModeTagStruct {
    optional vendor_id mfgCode = 0;
    enum16 value = 1;
  }

  struct ModeOptionStruct {
    char_string<64> label = 0;
    int8u mode = 1;
    ModeTagStruct modeTags[] = 2;
  }

  readonly attribute ModeOptionStruct supportedModes[] = 0;
  readonly attribute int8u currentMode = 1;
  attribute optional nullable int8u startUpMode = 2;
  attribute optional nullable int8u onMode = 3;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct ChangeToModeRequest {
    int8u newMode = 0;
  }

  response struct ChangeToModeResponse = 1 {
    enum8 status = 0;
    optional char_string statusText = 1;
  }

  /** This command is used to change device modes.
        On receipt of this command the device SHALL respond with a ChangeToModeResponse command. */
  command ChangeToMode(ChangeToModeRequest): ChangeToModeResponse = 0;
}

/** Attributes and commands for selecting a mode from a list of supported options. */
cluster RefrigeratorAndTemperatureControlledCabinetMode = 82 {
  revision 2;

  enum ModeTag : enum16 {
    kAuto = 0;
    kQuick = 1;
    kQuiet = 2;
    kLowNoise = 3;
    kLowEnergy = 4;
    kVacation = 5;
    kMin = 6;
    kMax = 7;
    kNight = 8;
    kDay = 9;
    kRapidCool = 16384;
    kRapidFreeze = 16385;
  }

  bitmap Feature : bitmap32 {
    kOnOff = 0x1;
  }

  struct ModeTagStruct {
    optional vendor_id mfgCode = 0;
    enum16 value = 1;
  }

  struct ModeOptionStruct {
    char_string<64> label = 0;
    int8u mode = 1;
    ModeTagStruct modeTags[] = 2;
  }

  readonly attribute ModeOptionStruct supportedModes[] = 0;
  readonly attribute int8u currentMode = 1;
  attribute optional nullable int8u startUpMode = 2;
  attribute optional nullable int8u onMode = 3;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct ChangeToModeRequest {
    int8u newMode = 0;
  }

  response struct ChangeToModeResponse = 1 {
    enum8 status = 0;
    optional char_string statusText = 1;
  }

  /** This command is used to change device modes.
        On receipt of this command the device SHALL respond with a ChangeToModeResponse command. */
  command ChangeToMode(ChangeToModeRequest): ChangeToModeResponse = 0;
}

/** This cluster supports remotely monitoring and controlling the different types of functionality available to a washing device, such as a washing machine. */
cluster LaundryWasherControls = 83 {
  revision 1;

  enum NumberOfRinsesEnum : enum8 {
    kNone = 0;
    kNormal = 1;
    kExtra = 2;
    kMax = 3;
  }

  bitmap Feature : bitmap32 {
    kSpin = 0x1;
    kRinse = 0x2;
  }

  readonly attribute optional char_string spinSpeeds[] = 0;
  attribute optional nullable int8u spinSpeedCurrent = 1;
  attribute optional NumberOfRinsesEnum numberOfRinses = 2;
  readonly attribute optional NumberOfRinsesEnum supportedRinses[] = 3;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Attributes and commands for configuring the temperature control, and reporting temperature. */
cluster TemperatureControl = 86 {
  revision 1; // NOTE: Default/not specifically set

  bitmap Feature : bitmap32 {
    kTemperatureNumber = 0x1;
    kTemperatureLevel = 0x2;
    kTemperatureStep = 0x4;
  }

  readonly attribute optional temperature temperatureSetpoint = 0;
  readonly attribute optional temperature minTemperature = 1;
  readonly attribute optional temperature maxTemperature = 2;
  readonly attribute optional temperature step = 3;
  readonly attribute optional int8u selectedTemperatureLevel = 4;
  readonly attribute optional char_string supportedTemperatureLevels[] = 5;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct SetTemperatureRequest {
    optional temperature targetTemperature = 0;
    optional int8u targetTemperatureLevel = 1;
  }

  /** Set Temperature */
  command SetTemperature(SetTemperatureRequest): DefaultSuccess = 0;
}

/** Attributes and commands for configuring the Refrigerator alarm. */
cluster RefrigeratorAlarm = 87 {
  revision 1; // NOTE: Default/not specifically set

  bitmap AlarmBitmap : bitmap32 {
    kDoorOpen = 0x1;
  }

  info event Notify = 0 {
    AlarmBitmap active = 0;
    AlarmBitmap inactive = 1;
    AlarmBitmap state = 2;
    AlarmBitmap mask = 3;
  }

  readonly attribute AlarmBitmap mask = 0;
  readonly attribute AlarmBitmap state = 2;
  readonly attribute AlarmBitmap supported = 3;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Attributes and commands for selecting a mode from a list of supported options. */
cluster DishwasherMode = 89 {
  revision 2;

  enum ModeTag : enum16 {
    kAuto = 0;
    kQuick = 1;
    kQuiet = 2;
    kLowNoise = 3;
    kLowEnergy = 4;
    kVacation = 5;
    kMin = 6;
    kMax = 7;
    kNight = 8;
    kDay = 9;
    kNormal = 16384;
    kHeavy = 16385;
    kLight = 16386;
  }

  bitmap Feature : bitmap32 {
    kOnOff = 0x1;
  }

  struct ModeTagStruct {
    optional vendor_id mfgCode = 0;
    enum16 value = 1;
  }

  struct ModeOptionStruct {
    char_string<64> label = 0;
    int8u mode = 1;
    ModeTagStruct modeTags[] = 2;
  }

  readonly attribute ModeOptionStruct supportedModes[] = 0;
  readonly attribute int8u currentMode = 1;
  attribute optional nullable int8u startUpMode = 2;
  attribute optional nullable int8u onMode = 3;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct ChangeToModeRequest {
    int8u newMode = 0;
  }

  response struct ChangeToModeResponse = 1 {
    enum8 status = 0;
    optional char_string statusText = 1;
  }

  /** This command is used to change device modes.
        On receipt of this command the device SHALL respond with a ChangeToModeResponse command. */
  command ChangeToMode(ChangeToModeRequest): ChangeToModeResponse = 0;
}

/** Attributes for reporting air quality classification */
cluster AirQuality = 91 {
  revision 1; // NOTE: Default/not specifically set

  enum AirQualityEnum : enum8 {
    kUnknown = 0;
    kGood = 1;
    kFair = 2;
    kModerate = 3;
    kPoor = 4;
    kVeryPoor = 5;
    kExtremelyPoor = 6;
  }

  bitmap Feature : bitmap32 {
    kFair = 0x1;
    kModerate = 0x2;
    kVeryPoor = 0x4;
    kExtremelyPoor = 0x8;
  }

  readonly attribute AirQualityEnum airQuality = 0;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** This cluster provides an interface for observing and managing the state of smoke and CO alarms. */
cluster SmokeCoAlarm = 92 {
  revision 1;

  enum AlarmStateEnum : enum8 {
    kNormal = 0;
    kWarning = 1;
    kCritical = 2;
  }

  enum ContaminationStateEnum : enum8 {
    kNormal = 0;
    kLow = 1;
    kWarning = 2;
    kCritical = 3;
  }

  enum EndOfServiceEnum : enum8 {
    kNormal = 0;
    kExpired = 1;
  }

  enum ExpressedStateEnum : enum8 {
    kNormal = 0;
    kSmokeAlarm = 1;
    kCOAlarm = 2;
    kBatteryAlert = 3;
    kTesting = 4;
    kHardwareFault = 5;
    kEndOfService = 6;
    kInterconnectSmoke = 7;
    kInterconnectCO = 8;
  }

  enum MuteStateEnum : enum8 {
    kNotMuted = 0;
    kMuted = 1;
  }

  enum SensitivityEnum : enum8 {
    kHigh = 0;
    kStandard = 1;
    kLow = 2;
  }

  bitmap Feature : bitmap32 {
    kSmokeAlarm = 0x1;
    kCOAlarm = 0x2;
  }

  critical event SmokeAlarm = 0 {
    AlarmStateEnum alarmSeverityLevel = 0;
  }

  critical event COAlarm = 1 {
    AlarmStateEnum alarmSeverityLevel = 0;
  }

  info event LowBattery = 2 {
    AlarmStateEnum alarmSeverityLevel = 0;
  }

  info event HardwareFault = 3 {
  }

  info event EndOfService = 4 {
  }

  info event SelfTestComplete = 5 {
  }

  info event AlarmMuted = 6 {
  }

  info event MuteEnded = 7 {
  }

  critical event InterconnectSmokeAlarm = 8 {
    AlarmStateEnum alarmSeverityLevel = 0;
  }

  critical event InterconnectCOAlarm = 9 {
    AlarmStateEnum alarmSeverityLevel = 0;
  }

  info event AllClear = 10 {
  }

  readonly attribute ExpressedStateEnum expressedState = 0;
  readonly attribute optional AlarmStateEnum smokeState = 1;
  readonly attribute optional AlarmStateEnum COState = 2;
  readonly attribute AlarmStateEnum batteryAlert = 3;
  readonly attribute optional MuteStateEnum deviceMuted = 4;
  readonly attribute boolean testInProgress = 5;
  readonly attribute boolean hardwareFaultAlert = 6;
  readonly attribute EndOfServiceEnum endOfServiceAlert = 7;
  readonly attribute optional AlarmStateEnum interconnectSmokeAlarm = 8;
  readonly attribute optional AlarmStateEnum interconnectCOAlarm = 9;
  readonly attribute optional ContaminationStateEnum contaminationState = 10;
  attribute access(write: manage) optional SensitivityEnum smokeSensitivityLevel = 11;
  readonly attribute optional epoch_s expiryDate = 12;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  /** This command SHALL initiate a device self-test. */
  command SelfTestRequest(): DefaultSuccess = 0;
}

/** Attributes and commands for configuring the Dishwasher alarm. */
cluster DishwasherAlarm = 93 {
  revision 1; // NOTE: Default/not specifically set

  bitmap AlarmBitmap : bitmap32 {
    kInflowError = 0x1;
    kDrainError = 0x2;
    kDoorError = 0x4;
    kTempTooLow = 0x8;
    kTempTooHigh = 0x10;
    kWaterLevelError = 0x20;
  }

  bitmap Feature : bitmap32 {
    kReset = 0x1;
  }

  info event Notify = 0 {
    AlarmBitmap active = 0;
    AlarmBitmap inactive = 1;
    AlarmBitmap state = 2;
    AlarmBitmap mask = 3;
  }

  readonly attribute AlarmBitmap mask = 0;
  readonly attribute optional AlarmBitmap latch = 1;
  readonly attribute AlarmBitmap state = 2;
  readonly attribute AlarmBitmap supported = 3;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct ResetRequest {
    AlarmBitmap alarms = 0;
  }

  request struct ModifyEnabledAlarmsRequest {
    AlarmBitmap mask = 0;
  }

  /** Reset alarm */
  command Reset(ResetRequest): DefaultSuccess = 0;
  /** Modify enabled alarms */
  command ModifyEnabledAlarms(ModifyEnabledAlarmsRequest): DefaultSuccess = 1;
}

/** Attributes and commands for scene configuration and manipulation. */
provisional cluster ScenesManagement = 98 {
  revision 1;

  bitmap CopyModeBitmap : bitmap8 {
    kCopyAllScenes = 0x1;
  }

  bitmap Feature : bitmap32 {
    kSceneNames = 0x1;
  }

  struct AttributeValuePairStruct {
    attrib_id attributeID = 0;
    optional int8u valueUnsigned8 = 1;
    optional int8s valueSigned8 = 2;
    optional int16u valueUnsigned16 = 3;
    optional int16s valueSigned16 = 4;
    optional int32u valueUnsigned32 = 5;
    optional int32s valueSigned32 = 6;
    optional int64u valueUnsigned64 = 7;
    optional int64s valueSigned64 = 8;
  }

  struct ExtensionFieldSet {
    cluster_id clusterID = 0;
    AttributeValuePairStruct attributeValueList[] = 1;
  }

  fabric_scoped struct SceneInfoStruct {
    int8u sceneCount = 0;
    fabric_sensitive int8u currentScene = 1;
    fabric_sensitive group_id currentGroup = 2;
    fabric_sensitive boolean sceneValid = 3;
    int8u remainingCapacity = 4;
    fabric_idx fabricIndex = 254;
  }

  readonly attribute optional nullable node_id lastConfiguredBy = 0;
  readonly attribute int16u sceneTableSize = 1;
  readonly attribute SceneInfoStruct fabricSceneInfo[] = 2;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct AddSceneRequest {
    group_id groupID = 0;
    int8u sceneID = 1;
    int32u transitionTime = 2;
    char_string sceneName = 3;
    ExtensionFieldSet extensionFieldSets[] = 4;
  }

  response struct AddSceneResponse = 0 {
    status status = 0;
    group_id groupID = 1;
    int8u sceneID = 2;
  }

  request struct ViewSceneRequest {
    group_id groupID = 0;
    int8u sceneID = 1;
  }

  response struct ViewSceneResponse = 1 {
    status status = 0;
    group_id groupID = 1;
    int8u sceneID = 2;
    optional int32u transitionTime = 3;
    optional char_string sceneName = 4;
    optional ExtensionFieldSet extensionFieldSets[] = 5;
  }

  request struct RemoveSceneRequest {
    group_id groupID = 0;
    int8u sceneID = 1;
  }

  response struct RemoveSceneResponse = 2 {
    status status = 0;
    group_id groupID = 1;
    int8u sceneID = 2;
  }

  request struct RemoveAllScenesRequest {
    group_id groupID = 0;
  }

  response struct RemoveAllScenesResponse = 3 {
    status status = 0;
    group_id groupID = 1;
  }

  request struct StoreSceneRequest {
    group_id groupID = 0;
    int8u sceneID = 1;
  }

  response struct StoreSceneResponse = 4 {
    status status = 0;
    group_id groupID = 1;
    int8u sceneID = 2;
  }

  request struct RecallSceneRequest {
    group_id groupID = 0;
    int8u sceneID = 1;
    optional nullable int32u transitionTime = 2;
  }

  request struct GetSceneMembershipRequest {
    group_id groupID = 0;
  }

  response struct GetSceneMembershipResponse = 6 {
    status status = 0;
    nullable int8u capacity = 1;
    group_id groupID = 2;
    optional int8u sceneList[] = 3;
  }

  request struct CopySceneRequest {
    CopyModeBitmap mode = 0;
    group_id groupIdentifierFrom = 1;
    int8u sceneIdentifierFrom = 2;
    group_id groupIdentifierTo = 3;
    int8u sceneIdentifierTo = 4;
  }

  response struct CopySceneResponse = 64 {
    status status = 0;
    group_id groupIdentifierFrom = 1;
    int8u sceneIdentifierFrom = 2;
  }

  /** Add a scene to the scene table. Extension field sets are supported, and are inputed as '{"ClusterID": VALUE, "AttributeValueList":[{"AttributeID": VALUE, "Value*": VALUE}]}' */
  fabric command access(invoke: manage) AddScene(AddSceneRequest): AddSceneResponse = 0;
  /** Retrieves the requested scene entry from its Scene table. */
  fabric command ViewScene(ViewSceneRequest): ViewSceneResponse = 1;
  /** Removes the requested scene entry, corresponding to the value of the GroupID field, from its Scene Table */
  fabric command access(invoke: manage) RemoveScene(RemoveSceneRequest): RemoveSceneResponse = 2;
  /** Remove all scenes, corresponding to the value of the GroupID field, from its Scene Table */
  fabric command access(invoke: manage) RemoveAllScenes(RemoveAllScenesRequest): RemoveAllScenesResponse = 3;
  /** Adds the scene entry into its Scene Table along with all extension field sets corresponding to the current state of other clusters on the same endpoint */
  fabric command access(invoke: manage) StoreScene(StoreSceneRequest): StoreSceneResponse = 4;
  /** Set the attributes and corresponding state for each other cluster implemented on the endpoint accordingly to the resquested scene entry in the Scene Table */
  fabric command RecallScene(RecallSceneRequest): DefaultSuccess = 5;
  /** Get an unused scene identifier when no commissioning tool is in the network, or for a commissioning tool to get the used scene identifiers within a certain group */
  fabric command GetSceneMembership(GetSceneMembershipRequest): GetSceneMembershipResponse = 6;
  /** Allows a client to efficiently copy scenes from one group/scene identifier pair to another group/scene identifier pair. */
  fabric command CopyScene(CopySceneRequest): CopySceneResponse = 64;
}

/** Attributes and commands for monitoring HEPA filters in a device */
cluster HepaFilterMonitoring = 113 {
  revision 1; // NOTE: Default/not specifically set

  enum ChangeIndicationEnum : enum8 {
    kOK = 0;
    kWarning = 1;
    kCritical = 2;
  }

  enum DegradationDirectionEnum : enum8 {
    kUp = 0;
    kDown = 1;
  }

  enum ProductIdentifierTypeEnum : enum8 {
    kUPC = 0;
    kGTIN8 = 1;
    kEAN = 2;
    kGTIN14 = 3;
    kOEM = 4;
  }

  bitmap Feature : bitmap32 {
    kCondition = 0x1;
    kWarning = 0x2;
    kReplacementProductList = 0x4;
  }

  struct ReplacementProductStruct {
    ProductIdentifierTypeEnum productIdentifierType = 0;
    char_string<20> productIdentifierValue = 1;
  }

  readonly attribute optional percent condition = 0;
  readonly attribute optional DegradationDirectionEnum degradationDirection = 1;
  readonly attribute ChangeIndicationEnum changeIndication = 2;
  readonly attribute optional boolean inPlaceIndicator = 3;
  attribute optional nullable epoch_s lastChangedTime = 4;
  readonly attribute optional ReplacementProductStruct replacementProductList[] = 5;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  /** Reset the condition of the replaceable to the non degraded state */
  command ResetCondition(): DefaultSuccess = 0;
}

/** Attributes and commands for monitoring activated carbon filters in a device */
cluster ActivatedCarbonFilterMonitoring = 114 {
  revision 1; // NOTE: Default/not specifically set

  enum ChangeIndicationEnum : enum8 {
    kOK = 0;
    kWarning = 1;
    kCritical = 2;
  }

  enum DegradationDirectionEnum : enum8 {
    kUp = 0;
    kDown = 1;
  }

  enum ProductIdentifierTypeEnum : enum8 {
    kUPC = 0;
    kGTIN8 = 1;
    kEAN = 2;
    kGTIN14 = 3;
    kOEM = 4;
  }

  bitmap Feature : bitmap32 {
    kCondition = 0x1;
    kWarning = 0x2;
    kReplacementProductList = 0x4;
  }

  struct ReplacementProductStruct {
    ProductIdentifierTypeEnum productIdentifierType = 0;
    char_string<20> productIdentifierValue = 1;
  }

  readonly attribute optional percent condition = 0;
  readonly attribute optional DegradationDirectionEnum degradationDirection = 1;
  readonly attribute ChangeIndicationEnum changeIndication = 2;
  readonly attribute optional boolean inPlaceIndicator = 3;
  attribute optional nullable epoch_s lastChangedTime = 4;
  readonly attribute optional ReplacementProductStruct replacementProductList[] = 5;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  /** Reset the condition of the replaceable to the non degraded state */
  command ResetCondition(): DefaultSuccess = 0;
}

/** An interface to a generic way to secure a door */
cluster DoorLock = 257 {
  revision 7;

  enum AlarmCodeEnum : enum8 {
    kLockJammed = 0;
    kLockFactoryReset = 1;
    kLockRadioPowerCycled = 3;
    kWrongCodeEntryLimit = 4;
    kFrontEsceutcheonRemoved = 5;
    kDoorForcedOpen = 6;
    kDoorAjar = 7;
    kForcedUser = 8;
  }

  enum CredentialRuleEnum : enum8 {
    kSingle = 0;
    kDual = 1;
    kTri = 2;
  }

  enum CredentialTypeEnum : enum8 {
    kProgrammingPIN = 0;
    kPIN = 1;
    kRFID = 2;
    kFingerprint = 3;
    kFingerVein = 4;
    kFace = 5;
    kAliroCredentialIssuerKey = 6;
    kAliroEvictableEndpointKey = 7;
    kAliroNonEvictableEndpointKey = 8;
  }

  enum DataOperationTypeEnum : enum8 {
    kAdd = 0;
    kClear = 1;
    kModify = 2;
  }

  enum DlLockState : enum8 {
    kNotFullyLocked = 0;
    kLocked = 1;
    kUnlocked = 2;
    kUnlatched = 3;
  }

  enum DlLockType : enum8 {
    kDeadBolt = 0;
    kMagnetic = 1;
    kOther = 2;
    kMortise = 3;
    kRim = 4;
    kLatchBolt = 5;
    kCylindricalLock = 6;
    kTubularLock = 7;
    kInterconnectedLock = 8;
    kDeadLatch = 9;
    kDoorFurniture = 10;
    kEurocylinder = 11;
  }

  enum DlStatus : enum8 {
    kSuccess = 0;
    kFailure = 1;
    kDuplicate = 2;
    kOccupied = 3;
    kInvalidField = 133;
    kResourceExhausted = 137;
    kNotFound = 139;
  }

  enum DoorLockOperationEventCode : enum8 {
    kUnknownOrMfgSpecific = 0;
    kLock = 1;
    kUnlock = 2;
    kLockInvalidPinOrId = 3;
    kLockInvalidSchedule = 4;
    kUnlockInvalidPinOrId = 5;
    kUnlockInvalidSchedule = 6;
    kOneTouchLock = 7;
    kKeyLock = 8;
    kKeyUnlock = 9;
    kAutoLock = 10;
    kScheduleLock = 11;
    kScheduleUnlock = 12;
    kManualLock = 13;
    kManualUnlock = 14;
  }

  enum DoorLockProgrammingEventCode : enum8 {
    kUnknownOrMfgSpecific = 0;
    kMasterCodeChanged = 1;
    kPinAdded = 2;
    kPinDeleted = 3;
    kPinChanged = 4;
    kIdAdded = 5;
    kIdDeleted = 6;
  }

  enum DoorLockSetPinOrIdStatus : enum8 {
    kSuccess = 0;
    kGeneralFailure = 1;
    kMemoryFull = 2;
    kDuplicateCodeError = 3;
  }

  enum DoorLockUserStatus : enum8 {
    kAvailable = 0;
    kOccupiedEnabled = 1;
    kOccupiedDisabled = 3;
    kNotSupported = 255;
  }

  enum DoorLockUserType : enum8 {
    kUnrestricted = 0;
    kYearDayScheduleUser = 1;
    kWeekDayScheduleUser = 2;
    kMasterUser = 3;
    kNonAccessUser = 4;
    kNotSupported = 255;
  }

  enum DoorStateEnum : enum8 {
    kDoorOpen = 0;
    kDoorClosed = 1;
    kDoorJammed = 2;
    kDoorForcedOpen = 3;
    kDoorUnspecifiedError = 4;
    kDoorAjar = 5;
  }

  enum LockDataTypeEnum : enum8 {
    kUnspecified = 0;
    kProgrammingCode = 1;
    kUserIndex = 2;
    kWeekDaySchedule = 3;
    kYearDaySchedule = 4;
    kHolidaySchedule = 5;
    kPIN = 6;
    kRFID = 7;
    kFingerprint = 8;
    kFingerVein = 9;
    kFace = 10;
    kAliroCredentialIssuerKey = 11;
    kAliroEvictableEndpointKey = 12;
    kAliroNonEvictableEndpointKey = 13;
  }

  enum LockOperationTypeEnum : enum8 {
    kLock = 0;
    kUnlock = 1;
    kNonAccessUserEvent = 2;
    kForcedUserEvent = 3;
    kUnlatch = 4;
  }

  enum OperatingModeEnum : enum8 {
    kNormal = 0;
    kVacation = 1;
    kPrivacy = 2;
    kNoRemoteLockUnlock = 3;
    kPassage = 4;
  }

  enum OperationErrorEnum : enum8 {
    kUnspecified = 0;
    kInvalidCredential = 1;
    kDisabledUserDenied = 2;
    kRestricted = 3;
    kInsufficientBattery = 4;
  }

  enum OperationSourceEnum : enum8 {
    kUnspecified = 0;
    kManual = 1;
    kProprietaryRemote = 2;
    kKeypad = 3;
    kAuto = 4;
    kButton = 5;
    kSchedule = 6;
    kRemote = 7;
    kRFID = 8;
    kBiometric = 9;
    kAliro = 10;
  }

  enum UserStatusEnum : enum8 {
    kAvailable = 0;
    kOccupiedEnabled = 1;
    kOccupiedDisabled = 3;
  }

  enum UserTypeEnum : enum8 {
    kUnrestrictedUser = 0;
    kYearDayScheduleUser = 1;
    kWeekDayScheduleUser = 2;
    kProgrammingUser = 3;
    kNonAccessUser = 4;
    kForcedUser = 5;
    kDisposableUser = 6;
    kExpiringUser = 7;
    kScheduleRestrictedUser = 8;
    kRemoteOnlyUser = 9;
  }

  bitmap DaysMaskMap : bitmap8 {
    kSunday = 0x1;
    kMonday = 0x2;
    kTuesday = 0x4;
    kWednesday = 0x8;
    kThursday = 0x10;
    kFriday = 0x20;
    kSaturday = 0x40;
  }

  bitmap DlCredentialRuleMask : bitmap8 {
    kSingle = 0x1;
    kDual = 0x2;
    kTri = 0x4;
  }

  bitmap DlCredentialRulesSupport : bitmap8 {
    kSingle = 0x1;
    kDual = 0x2;
    kTri = 0x4;
  }

  bitmap DlDefaultConfigurationRegister : bitmap16 {
    kEnableLocalProgrammingEnabled = 0x1;
    kKeypadInterfaceDefaultAccessEnabled = 0x2;
    kRemoteInterfaceDefaultAccessIsEnabled = 0x4;
    kSoundEnabled = 0x20;
    kAutoRelockTimeSet = 0x40;
    kLEDSettingsSet = 0x80;
  }

  bitmap DlKeypadOperationEventMask : bitmap16 {
    kUnknown = 0x1;
    kLock = 0x2;
    kUnlock = 0x4;
    kLockInvalidPIN = 0x8;
    kLockInvalidSchedule = 0x10;
    kUnlockInvalidCode = 0x20;
    kUnlockInvalidSchedule = 0x40;
    kNonAccessUserOpEvent = 0x80;
  }

  bitmap DlKeypadProgrammingEventMask : bitmap16 {
    kUnknown = 0x1;
    kProgrammingPINChanged = 0x2;
    kPINAdded = 0x4;
    kPINCleared = 0x8;
    kPINChanged = 0x10;
  }

  bitmap DlLocalProgrammingFeatures : bitmap8 {
    kAddUsersCredentialsSchedulesLocally = 0x1;
    kModifyUsersCredentialsSchedulesLocally = 0x2;
    kClearUsersCredentialsSchedulesLocally = 0x4;
    kAdjustLockSettingsLocally = 0x8;
  }

  bitmap DlManualOperationEventMask : bitmap16 {
    kUnknown = 0x1;
    kThumbturnLock = 0x2;
    kThumbturnUnlock = 0x4;
    kOneTouchLock = 0x8;
    kKeyLock = 0x10;
    kKeyUnlock = 0x20;
    kAutoLock = 0x40;
    kScheduleLock = 0x80;
    kScheduleUnlock = 0x100;
    kManualLock = 0x200;
    kManualUnlock = 0x400;
  }

  bitmap DlRFIDOperationEventMask : bitmap16 {
    kUnknown = 0x1;
    kLock = 0x2;
    kUnlock = 0x4;
    kLockInvalidRFID = 0x8;
    kLockInvalidSchedule = 0x10;
    kUnlockInvalidRFID = 0x20;
    kUnlockInvalidSchedule = 0x40;
  }

  bitmap DlRFIDProgrammingEventMask : bitmap16 {
    kUnknown = 0x1;
    kRFIDCodeAdded = 0x20;
    kRFIDCodeCleared = 0x40;
  }

  bitmap DlRemoteOperationEventMask : bitmap16 {
    kUnknown = 0x1;
    kLock = 0x2;
    kUnlock = 0x4;
    kLockInvalidCode = 0x8;
    kLockInvalidSchedule = 0x10;
    kUnlockInvalidCode = 0x20;
    kUnlockInvalidSchedule = 0x40;
  }

  bitmap DlRemoteProgrammingEventMask : bitmap16 {
    kUnknown = 0x1;
    kProgrammingPINChanged = 0x2;
    kPINAdded = 0x4;
    kPINCleared = 0x8;
    kPINChanged = 0x10;
    kRFIDCodeAdded = 0x20;
    kRFIDCodeCleared = 0x40;
  }

  bitmap DlSupportedOperatingModes : bitmap16 {
    kNormal = 0x1;
    kVacation = 0x2;
    kPrivacy = 0x4;
    kNoRemoteLockUnlock = 0x8;
    kPassage = 0x10;
  }

  bitmap DoorLockDayOfWeek : bitmap8 {
    kSunday = 0x1;
    kMonday = 0x2;
    kTuesday = 0x4;
    kWednesday = 0x8;
    kThursday = 0x10;
    kFriday = 0x20;
    kSaturday = 0x40;
  }

  bitmap Feature : bitmap32 {
    kPINCredential = 0x1;
    kRFIDCredential = 0x2;
    kFingerCredentials = 0x4;
    kLogging = 0x8;
    kWeekDayAccessSchedules = 0x10;
    kDoorPositionSensor = 0x20;
    kFaceCredentials = 0x40;
    kCredentialsOverTheAirAccess = 0x80;
    kUser = 0x100;
    kNotification = 0x200;
    kYearDayAccessSchedules = 0x400;
    kHolidaySchedules = 0x800;
    kUnbolt = 0x1000;
    kAliroProvisioning = 0x2000;
    kAliroBLEUWB = 0x4000;
  }

  struct CredentialStruct {
    CredentialTypeEnum credentialType = 0;
    int16u credentialIndex = 1;
  }

  critical event DoorLockAlarm = 0 {
    AlarmCodeEnum alarmCode = 0;
  }

  critical event DoorStateChange = 1 {
    DoorStateEnum doorState = 0;
  }

  critical event LockOperation = 2 {
    LockOperationTypeEnum lockOperationType = 0;
    OperationSourceEnum operationSource = 1;
    nullable int16u userIndex = 2;
    nullable fabric_idx fabricIndex = 3;
    nullable node_id sourceNode = 4;
    optional nullable CredentialStruct credentials[] = 5;
  }

  critical event LockOperationError = 3 {
    LockOperationTypeEnum lockOperationType = 0;
    OperationSourceEnum operationSource = 1;
    OperationErrorEnum operationError = 2;
    nullable int16u userIndex = 3;
    nullable fabric_idx fabricIndex = 4;
    nullable node_id sourceNode = 5;
    optional nullable CredentialStruct credentials[] = 6;
  }

  info event LockUserChange = 4 {
    LockDataTypeEnum lockDataType = 0;
    DataOperationTypeEnum dataOperationType = 1;
    OperationSourceEnum operationSource = 2;
    nullable int16u userIndex = 3;
    nullable fabric_idx fabricIndex = 4;
    nullable node_id sourceNode = 5;
    nullable int16u dataIndex = 6;
  }

  readonly attribute nullable DlLockState lockState = 0;
  readonly attribute DlLockType lockType = 1;
  readonly attribute boolean actuatorEnabled = 2;
  readonly attribute optional nullable DoorStateEnum doorState = 3;
  attribute access(write: manage) optional int32u doorOpenEvents = 4;
  attribute access(write: manage) optional int32u doorClosedEvents = 5;
  attribute access(write: manage) optional int16u openPeriod = 6;
  readonly attribute optional int16u numberOfTotalUsersSupported = 17;
  readonly attribute optional int16u numberOfPINUsersSupported = 18;
  readonly attribute optional int16u numberOfRFIDUsersSupported = 19;
  readonly attribute optional int8u numberOfWeekDaySchedulesSupportedPerUser = 20;
  readonly attribute optional int8u numberOfYearDaySchedulesSupportedPerUser = 21;
  readonly attribute optional int8u numberOfHolidaySchedulesSupported = 22;
  readonly attribute optional int8u maxPINCodeLength = 23;
  readonly attribute optional int8u minPINCodeLength = 24;
  readonly attribute optional int8u maxRFIDCodeLength = 25;
  readonly attribute optional int8u minRFIDCodeLength = 26;
  readonly attribute optional DlCredentialRuleMask credentialRulesSupport = 27;
  readonly attribute optional int8u numberOfCredentialsSupportedPerUser = 28;
  attribute access(write: manage) optional char_string<3> language = 33;
  attribute access(write: manage) optional int8u LEDSettings = 34;
  attribute access(write: manage) optional int32u autoRelockTime = 35;
  attribute access(write: manage) optional int8u soundVolume = 36;
  attribute access(write: manage) OperatingModeEnum operatingMode = 37;
  readonly attribute DlSupportedOperatingModes supportedOperatingModes = 38;
  readonly attribute optional DlDefaultConfigurationRegister defaultConfigurationRegister = 39;
  attribute access(write: administer) optional boolean enableLocalProgramming = 40;
  attribute access(write: manage) optional boolean enableOneTouchLocking = 41;
  attribute access(write: manage) optional boolean enableInsideStatusLED = 42;
  attribute access(write: manage) optional boolean enablePrivacyModeButton = 43;
  attribute access(write: administer) optional DlLocalProgrammingFeatures localProgrammingFeatures = 44;
  attribute access(write: administer) optional int8u wrongCodeEntryLimit = 48;
  attribute access(write: administer) optional int8u userCodeTemporaryDisableTime = 49;
  attribute access(write: administer) optional boolean sendPINOverTheAir = 50;
  attribute access(write: administer) optional boolean requirePINforRemoteOperation = 51;
  attribute access(write: administer) optional int16u expiringUserTimeout = 53;
  provisional readonly attribute access(read: administer) optional nullable octet_string<65> aliroReaderVerificationKey = 128;
  provisional readonly attribute access(read: administer) optional nullable octet_string<16> aliroReaderGroupIdentifier = 129;
  provisional readonly attribute access(read: administer) optional octet_string<16> aliroReaderGroupSubIdentifier = 130;
  provisional readonly attribute access(read: administer) optional octet_string aliroExpeditedTransactionSupportedProtocolVersions[] = 131;
  provisional readonly attribute access(read: administer) optional nullable octet_string<16> aliroGroupResolvingKey = 132;
  provisional readonly attribute access(read: administer) optional octet_string aliroSupportedBLEUWBProtocolVersions[] = 133;
  provisional readonly attribute access(read: administer) optional int8u aliroBLEAdvertisingVersion = 134;
  provisional readonly attribute optional int16u numberOfAliroCredentialIssuerKeysSupported = 135;
  provisional readonly attribute optional int16u numberOfAliroEndpointKeysSupported = 136;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct LockDoorRequest {
    optional octet_string PINCode = 0;
  }

  request struct UnlockDoorRequest {
    optional octet_string PINCode = 0;
  }

  request struct UnlockWithTimeoutRequest {
    int16u timeout = 0;
    optional octet_string PINCode = 1;
  }

  request struct SetWeekDayScheduleRequest {
    int8u weekDayIndex = 0;
    int16u userIndex = 1;
    DaysMaskMap daysMask = 2;
    int8u startHour = 3;
    int8u startMinute = 4;
    int8u endHour = 5;
    int8u endMinute = 6;
  }

  request struct GetWeekDayScheduleRequest {
    int8u weekDayIndex = 0;
    int16u userIndex = 1;
  }

  response struct GetWeekDayScheduleResponse = 12 {
    int8u weekDayIndex = 0;
    int16u userIndex = 1;
    DlStatus status = 2;
    optional DaysMaskMap daysMask = 3;
    optional int8u startHour = 4;
    optional int8u startMinute = 5;
    optional int8u endHour = 6;
    optional int8u endMinute = 7;
  }

  request struct ClearWeekDayScheduleRequest {
    int8u weekDayIndex = 0;
    int16u userIndex = 1;
  }

  request struct SetYearDayScheduleRequest {
    int8u yearDayIndex = 0;
    int16u userIndex = 1;
    epoch_s localStartTime = 2;
    epoch_s localEndTime = 3;
  }

  request struct GetYearDayScheduleRequest {
    int8u yearDayIndex = 0;
    int16u userIndex = 1;
  }

  response struct GetYearDayScheduleResponse = 15 {
    int8u yearDayIndex = 0;
    int16u userIndex = 1;
    DlStatus status = 2;
    optional epoch_s localStartTime = 3;
    optional epoch_s localEndTime = 4;
  }

  request struct ClearYearDayScheduleRequest {
    int8u yearDayIndex = 0;
    int16u userIndex = 1;
  }

  request struct SetHolidayScheduleRequest {
    int8u holidayIndex = 0;
    epoch_s localStartTime = 1;
    epoch_s localEndTime = 2;
    OperatingModeEnum operatingMode = 3;
  }

  request struct GetHolidayScheduleRequest {
    int8u holidayIndex = 0;
  }

  response struct GetHolidayScheduleResponse = 18 {
    int8u holidayIndex = 0;
    DlStatus status = 1;
    optional epoch_s localStartTime = 2;
    optional epoch_s localEndTime = 3;
    optional OperatingModeEnum operatingMode = 4;
  }

  request struct ClearHolidayScheduleRequest {
    int8u holidayIndex = 0;
  }

  request struct SetUserRequest {
    DataOperationTypeEnum operationType = 0;
    int16u userIndex = 1;
    nullable char_string userName = 2;
    nullable int32u userUniqueID = 3;
    nullable UserStatusEnum userStatus = 4;
    nullable UserTypeEnum userType = 5;
    nullable CredentialRuleEnum credentialRule = 6;
  }

  request struct GetUserRequest {
    int16u userIndex = 0;
  }

  response struct GetUserResponse = 28 {
    int16u userIndex = 0;
    nullable char_string userName = 1;
    nullable int32u userUniqueID = 2;
    nullable UserStatusEnum userStatus = 3;
    nullable UserTypeEnum userType = 4;
    nullable CredentialRuleEnum credentialRule = 5;
    nullable CredentialStruct credentials[] = 6;
    nullable fabric_idx creatorFabricIndex = 7;
    nullable fabric_idx lastModifiedFabricIndex = 8;
    nullable int16u nextUserIndex = 9;
  }

  request struct ClearUserRequest {
    int16u userIndex = 0;
  }

  request struct SetCredentialRequest {
    DataOperationTypeEnum operationType = 0;
    CredentialStruct credential = 1;
    long_octet_string credentialData = 2;
    nullable int16u userIndex = 3;
    nullable UserStatusEnum userStatus = 4;
    nullable UserTypeEnum userType = 5;
  }

  response struct SetCredentialResponse = 35 {
    DlStatus status = 0;
    nullable int16u userIndex = 1;
    nullable int16u nextCredentialIndex = 2;
  }

  request struct GetCredentialStatusRequest {
    CredentialStruct credential = 0;
  }

  response struct GetCredentialStatusResponse = 37 {
    boolean credentialExists = 0;
    nullable int16u userIndex = 1;
    nullable fabric_idx creatorFabricIndex = 2;
    nullable fabric_idx lastModifiedFabricIndex = 3;
    nullable int16u nextCredentialIndex = 4;
    optional nullable octet_string credentialData = 5;
  }

  request struct ClearCredentialRequest {
    nullable CredentialStruct credential = 0;
  }

  request struct UnboltDoorRequest {
    optional octet_string PINCode = 0;
  }

  request struct SetAliroReaderConfigRequest {
    octet_string<32> signingKey = 0;
    octet_string<65> verificationKey = 1;
    octet_string<16> groupIdentifier = 2;
    optional octet_string<16> groupResolvingKey = 3;
  }

  /** This command causes the lock device to lock the door. */
  timed command LockDoor(LockDoorRequest): DefaultSuccess = 0;
  /** This command causes the lock device to unlock the door. */
  timed command UnlockDoor(UnlockDoorRequest): DefaultSuccess = 1;
  /** This command causes the lock device to unlock the door with a timeout parameter. */
  timed command UnlockWithTimeout(UnlockWithTimeoutRequest): DefaultSuccess = 3;
  /** Set a weekly repeating schedule for a specified user. */
  command access(invoke: administer) SetWeekDaySchedule(SetWeekDayScheduleRequest): DefaultSuccess = 11;
  /** Retrieve the specific weekly schedule for the specific user. */
  command access(invoke: administer) GetWeekDaySchedule(GetWeekDayScheduleRequest): GetWeekDayScheduleResponse = 12;
  /** Clear the specific weekly schedule or all weekly schedules for the specific user. */
  command access(invoke: administer) ClearWeekDaySchedule(ClearWeekDayScheduleRequest): DefaultSuccess = 13;
  /** Set a time-specific schedule ID for a specified user. */
  command access(invoke: administer) SetYearDaySchedule(SetYearDayScheduleRequest): DefaultSuccess = 14;
  /** Returns the year day schedule data for the specified schedule and user indexes. */
  command access(invoke: administer) GetYearDaySchedule(GetYearDayScheduleRequest): GetYearDayScheduleResponse = 15;
  /** Clears the specific year day schedule or all year day schedules for the specific user. */
  command access(invoke: administer) ClearYearDaySchedule(ClearYearDayScheduleRequest): DefaultSuccess = 16;
  /** Set the holiday Schedule by specifying local start time and local end time with respect to any Lock Operating Mode. */
  command access(invoke: administer) SetHolidaySchedule(SetHolidayScheduleRequest): DefaultSuccess = 17;
  /** Get the holiday schedule for the specified index. */
  command access(invoke: administer) GetHolidaySchedule(GetHolidayScheduleRequest): GetHolidayScheduleResponse = 18;
  /** Clears the holiday schedule or all holiday schedules. */
  command access(invoke: administer) ClearHolidaySchedule(ClearHolidayScheduleRequest): DefaultSuccess = 19;
  /** Set User into the lock. */
  timed command access(invoke: administer) SetUser(SetUserRequest): DefaultSuccess = 26;
  /** Retrieve User. */
  command access(invoke: administer) GetUser(GetUserRequest): GetUserResponse = 27;
  /** Clears a User or all Users. */
  timed command access(invoke: administer) ClearUser(ClearUserRequest): DefaultSuccess = 29;
  /** Set a credential (e.g. PIN, RFID, Fingerprint, etc.) into the lock for a new user, existing user, or ProgrammingUser. */
  timed command access(invoke: administer) SetCredential(SetCredentialRequest): SetCredentialResponse = 34;
  /** Retrieve the status of a particular credential (e.g. PIN, RFID, Fingerprint, etc.) by index. */
  command access(invoke: administer) GetCredentialStatus(GetCredentialStatusRequest): GetCredentialStatusResponse = 36;
  /** Clear one, one type, or all credentials except ProgrammingPIN credential. */
  timed command access(invoke: administer) ClearCredential(ClearCredentialRequest): DefaultSuccess = 38;
  /** This command causes the lock device to unlock the door without pulling the latch. */
  timed command UnboltDoor(UnboltDoorRequest): DefaultSuccess = 39;
  /** This command communicates an Aliro Reader configuration to the lock. */
  timed command access(invoke: administer) SetAliroReaderConfig(SetAliroReaderConfigRequest): DefaultSuccess = 40;
  /** This command clears an existing Aliro Reader configuration for the lock. */
  timed command access(invoke: administer) ClearAliroReaderConfig(): DefaultSuccess = 41;
}

/** An interface to a generic way to secure a door */
cluster DoorLock = 257 {
  revision 7;

  enum AlarmCodeEnum : enum8 {
    kLockJammed = 0;
    kLockFactoryReset = 1;
    kLockRadioPowerCycled = 3;
    kWrongCodeEntryLimit = 4;
    kFrontEsceutcheonRemoved = 5;
    kDoorForcedOpen = 6;
    kDoorAjar = 7;
    kForcedUser = 8;
  }

  enum CredentialRuleEnum : enum8 {
    kSingle = 0;
    kDual = 1;
    kTri = 2;
  }

  enum CredentialTypeEnum : enum8 {
    kProgrammingPIN = 0;
    kPIN = 1;
    kRFID = 2;
    kFingerprint = 3;
    kFingerVein = 4;
    kFace = 5;
    kAliroCredentialIssuerKey = 6;
    kAliroEvictableEndpointKey = 7;
    kAliroNonEvictableEndpointKey = 8;
  }

  enum DataOperationTypeEnum : enum8 {
    kAdd = 0;
    kClear = 1;
    kModify = 2;
  }

  enum DlLockState : enum8 {
    kNotFullyLocked = 0;
    kLocked = 1;
    kUnlocked = 2;
    kUnlatched = 3;
  }

  enum DlLockType : enum8 {
    kDeadBolt = 0;
    kMagnetic = 1;
    kOther = 2;
    kMortise = 3;
    kRim = 4;
    kLatchBolt = 5;
    kCylindricalLock = 6;
    kTubularLock = 7;
    kInterconnectedLock = 8;
    kDeadLatch = 9;
    kDoorFurniture = 10;
    kEurocylinder = 11;
  }

  enum DlStatus : enum8 {
    kSuccess = 0;
    kFailure = 1;
    kDuplicate = 2;
    kOccupied = 3;
    kInvalidField = 133;
    kResourceExhausted = 137;
    kNotFound = 139;
  }

  enum DoorLockOperationEventCode : enum8 {
    kUnknownOrMfgSpecific = 0;
    kLock = 1;
    kUnlock = 2;
    kLockInvalidPinOrId = 3;
    kLockInvalidSchedule = 4;
    kUnlockInvalidPinOrId = 5;
    kUnlockInvalidSchedule = 6;
    kOneTouchLock = 7;
    kKeyLock = 8;
    kKeyUnlock = 9;
    kAutoLock = 10;
    kScheduleLock = 11;
    kScheduleUnlock = 12;
    kManualLock = 13;
    kManualUnlock = 14;
  }

  enum DoorLockProgrammingEventCode : enum8 {
    kUnknownOrMfgSpecific = 0;
    kMasterCodeChanged = 1;
    kPinAdded = 2;
    kPinDeleted = 3;
    kPinChanged = 4;
    kIdAdded = 5;
    kIdDeleted = 6;
  }

  enum DoorLockSetPinOrIdStatus : enum8 {
    kSuccess = 0;
    kGeneralFailure = 1;
    kMemoryFull = 2;
    kDuplicateCodeError = 3;
  }

  enum DoorLockUserStatus : enum8 {
    kAvailable = 0;
    kOccupiedEnabled = 1;
    kOccupiedDisabled = 3;
    kNotSupported = 255;
  }

  enum DoorLockUserType : enum8 {
    kUnrestricted = 0;
    kYearDayScheduleUser = 1;
    kWeekDayScheduleUser = 2;
    kMasterUser = 3;
    kNonAccessUser = 4;
    kNotSupported = 255;
  }

  enum DoorStateEnum : enum8 {
    kDoorOpen = 0;
    kDoorClosed = 1;
    kDoorJammed = 2;
    kDoorForcedOpen = 3;
    kDoorUnspecifiedError = 4;
    kDoorAjar = 5;
  }

  enum LockDataTypeEnum : enum8 {
    kUnspecified = 0;
    kProgrammingCode = 1;
    kUserIndex = 2;
    kWeekDaySchedule = 3;
    kYearDaySchedule = 4;
    kHolidaySchedule = 5;
    kPIN = 6;
    kRFID = 7;
    kFingerprint = 8;
    kFingerVein = 9;
    kFace = 10;
    kAliroCredentialIssuerKey = 11;
    kAliroEvictableEndpointKey = 12;
    kAliroNonEvictableEndpointKey = 13;
  }

  enum LockOperationTypeEnum : enum8 {
    kLock = 0;
    kUnlock = 1;
    kNonAccessUserEvent = 2;
    kForcedUserEvent = 3;
    kUnlatch = 4;
  }

  enum OperatingModeEnum : enum8 {
    kNormal = 0;
    kVacation = 1;
    kPrivacy = 2;
    kNoRemoteLockUnlock = 3;
    kPassage = 4;
  }

  enum OperationErrorEnum : enum8 {
    kUnspecified = 0;
    kInvalidCredential = 1;
    kDisabledUserDenied = 2;
    kRestricted = 3;
    kInsufficientBattery = 4;
  }

  enum OperationSourceEnum : enum8 {
    kUnspecified = 0;
    kManual = 1;
    kProprietaryRemote = 2;
    kKeypad = 3;
    kAuto = 4;
    kButton = 5;
    kSchedule = 6;
    kRemote = 7;
    kRFID = 8;
    kBiometric = 9;
    kAliro = 10;
  }

  enum UserStatusEnum : enum8 {
    kAvailable = 0;
    kOccupiedEnabled = 1;
    kOccupiedDisabled = 3;
  }

  enum UserTypeEnum : enum8 {
    kUnrestrictedUser = 0;
    kYearDayScheduleUser = 1;
    kWeekDayScheduleUser = 2;
    kProgrammingUser = 3;
    kNonAccessUser = 4;
    kForcedUser = 5;
    kDisposableUser = 6;
    kExpiringUser = 7;
    kScheduleRestrictedUser = 8;
    kRemoteOnlyUser = 9;
  }

  bitmap DaysMaskMap : bitmap8 {
    kSunday = 0x1;
    kMonday = 0x2;
    kTuesday = 0x4;
    kWednesday = 0x8;
    kThursday = 0x10;
    kFriday = 0x20;
    kSaturday = 0x40;
  }

  bitmap DlCredentialRuleMask : bitmap8 {
    kSingle = 0x1;
    kDual = 0x2;
    kTri = 0x4;
  }

  bitmap DlCredentialRulesSupport : bitmap8 {
    kSingle = 0x1;
    kDual = 0x2;
    kTri = 0x4;
  }

  bitmap DlDefaultConfigurationRegister : bitmap16 {
    kEnableLocalProgrammingEnabled = 0x1;
    kKeypadInterfaceDefaultAccessEnabled = 0x2;
    kRemoteInterfaceDefaultAccessIsEnabled = 0x4;
    kSoundEnabled = 0x20;
    kAutoRelockTimeSet = 0x40;
    kLEDSettingsSet = 0x80;
  }

  bitmap DlKeypadOperationEventMask : bitmap16 {
    kUnknown = 0x1;
    kLock = 0x2;
    kUnlock = 0x4;
    kLockInvalidPIN = 0x8;
    kLockInvalidSchedule = 0x10;
    kUnlockInvalidCode = 0x20;
    kUnlockInvalidSchedule = 0x40;
    kNonAccessUserOpEvent = 0x80;
  }

  bitmap DlKeypadProgrammingEventMask : bitmap16 {
    kUnknown = 0x1;
    kProgrammingPINChanged = 0x2;
    kPINAdded = 0x4;
    kPINCleared = 0x8;
    kPINChanged = 0x10;
  }

  bitmap DlLocalProgrammingFeatures : bitmap8 {
    kAddUsersCredentialsSchedulesLocally = 0x1;
    kModifyUsersCredentialsSchedulesLocally = 0x2;
    kClearUsersCredentialsSchedulesLocally = 0x4;
    kAdjustLockSettingsLocally = 0x8;
  }

  bitmap DlManualOperationEventMask : bitmap16 {
    kUnknown = 0x1;
    kThumbturnLock = 0x2;
    kThumbturnUnlock = 0x4;
    kOneTouchLock = 0x8;
    kKeyLock = 0x10;
    kKeyUnlock = 0x20;
    kAutoLock = 0x40;
    kScheduleLock = 0x80;
    kScheduleUnlock = 0x100;
    kManualLock = 0x200;
    kManualUnlock = 0x400;
  }

  bitmap DlRFIDOperationEventMask : bitmap16 {
    kUnknown = 0x1;
    kLock = 0x2;
    kUnlock = 0x4;
    kLockInvalidRFID = 0x8;
    kLockInvalidSchedule = 0x10;
    kUnlockInvalidRFID = 0x20;
    kUnlockInvalidSchedule = 0x40;
  }

  bitmap DlRFIDProgrammingEventMask : bitmap16 {
    kUnknown = 0x1;
    kRFIDCodeAdded = 0x20;
    kRFIDCodeCleared = 0x40;
  }

  bitmap DlRemoteOperationEventMask : bitmap16 {
    kUnknown = 0x1;
    kLock = 0x2;
    kUnlock = 0x4;
    kLockInvalidCode = 0x8;
    kLockInvalidSchedule = 0x10;
    kUnlockInvalidCode = 0x20;
    kUnlockInvalidSchedule = 0x40;
  }

  bitmap DlRemoteProgrammingEventMask : bitmap16 {
    kUnknown = 0x1;
    kProgrammingPINChanged = 0x2;
    kPINAdded = 0x4;
    kPINCleared = 0x8;
    kPINChanged = 0x10;
    kRFIDCodeAdded = 0x20;
    kRFIDCodeCleared = 0x40;
  }

  bitmap DlSupportedOperatingModes : bitmap16 {
    kNormal = 0x1;
    kVacation = 0x2;
    kPrivacy = 0x4;
    kNoRemoteLockUnlock = 0x8;
    kPassage = 0x10;
  }

  bitmap DoorLockDayOfWeek : bitmap8 {
    kSunday = 0x1;
    kMonday = 0x2;
    kTuesday = 0x4;
    kWednesday = 0x8;
    kThursday = 0x10;
    kFriday = 0x20;
    kSaturday = 0x40;
  }

  bitmap Feature : bitmap32 {
    kPINCredential = 0x1;
    kRFIDCredential = 0x2;
    kFingerCredentials = 0x4;
    kLogging = 0x8;
    kWeekDayAccessSchedules = 0x10;
    kDoorPositionSensor = 0x20;
    kFaceCredentials = 0x40;
    kCredentialsOverTheAirAccess = 0x80;
    kUser = 0x100;
    kNotification = 0x200;
    kYearDayAccessSchedules = 0x400;
    kHolidaySchedules = 0x800;
    kUnbolt = 0x1000;
    kAliroProvisioning = 0x2000;
    kAliroBLEUWB = 0x4000;
  }

  struct CredentialStruct {
    CredentialTypeEnum credentialType = 0;
    int16u credentialIndex = 1;
  }

  critical event DoorLockAlarm = 0 {
    AlarmCodeEnum alarmCode = 0;
  }

  critical event DoorStateChange = 1 {
    DoorStateEnum doorState = 0;
  }

  critical event LockOperation = 2 {
    LockOperationTypeEnum lockOperationType = 0;
    OperationSourceEnum operationSource = 1;
    nullable int16u userIndex = 2;
    nullable fabric_idx fabricIndex = 3;
    nullable node_id sourceNode = 4;
    optional nullable CredentialStruct credentials[] = 5;
  }

  critical event LockOperationError = 3 {
    LockOperationTypeEnum lockOperationType = 0;
    OperationSourceEnum operationSource = 1;
    OperationErrorEnum operationError = 2;
    nullable int16u userIndex = 3;
    nullable fabric_idx fabricIndex = 4;
    nullable node_id sourceNode = 5;
    optional nullable CredentialStruct credentials[] = 6;
  }

  info event LockUserChange = 4 {
    LockDataTypeEnum lockDataType = 0;
    DataOperationTypeEnum dataOperationType = 1;
    OperationSourceEnum operationSource = 2;
    nullable int16u userIndex = 3;
    nullable fabric_idx fabricIndex = 4;
    nullable node_id sourceNode = 5;
    nullable int16u dataIndex = 6;
  }

  readonly attribute nullable DlLockState lockState = 0;
  readonly attribute DlLockType lockType = 1;
  readonly attribute boolean actuatorEnabled = 2;
  readonly attribute optional nullable DoorStateEnum doorState = 3;
  attribute access(write: manage) optional int32u doorOpenEvents = 4;
  attribute access(write: manage) optional int32u doorClosedEvents = 5;
  attribute access(write: manage) optional int16u openPeriod = 6;
  readonly attribute optional int16u numberOfTotalUsersSupported = 17;
  readonly attribute optional int16u numberOfPINUsersSupported = 18;
  readonly attribute optional int16u numberOfRFIDUsersSupported = 19;
  readonly attribute optional int8u numberOfWeekDaySchedulesSupportedPerUser = 20;
  readonly attribute optional int8u numberOfYearDaySchedulesSupportedPerUser = 21;
  readonly attribute optional int8u numberOfHolidaySchedulesSupported = 22;
  readonly attribute optional int8u maxPINCodeLength = 23;
  readonly attribute optional int8u minPINCodeLength = 24;
  readonly attribute optional int8u maxRFIDCodeLength = 25;
  readonly attribute optional int8u minRFIDCodeLength = 26;
  readonly attribute optional DlCredentialRuleMask credentialRulesSupport = 27;
  readonly attribute optional int8u numberOfCredentialsSupportedPerUser = 28;
  attribute access(write: manage) optional char_string<3> language = 33;
  attribute access(write: manage) optional int8u LEDSettings = 34;
  attribute access(write: manage) optional int32u autoRelockTime = 35;
  attribute access(write: manage) optional int8u soundVolume = 36;
  attribute access(write: manage) OperatingModeEnum operatingMode = 37;
  readonly attribute DlSupportedOperatingModes supportedOperatingModes = 38;
  readonly attribute optional DlDefaultConfigurationRegister defaultConfigurationRegister = 39;
  attribute access(write: administer) optional boolean enableLocalProgramming = 40;
  attribute access(write: manage) optional boolean enableOneTouchLocking = 41;
  attribute access(write: manage) optional boolean enableInsideStatusLED = 42;
  attribute access(write: manage) optional boolean enablePrivacyModeButton = 43;
  attribute access(write: administer) optional DlLocalProgrammingFeatures localProgrammingFeatures = 44;
  attribute access(write: administer) optional int8u wrongCodeEntryLimit = 48;
  attribute access(write: administer) optional int8u userCodeTemporaryDisableTime = 49;
  attribute access(write: administer) optional boolean sendPINOverTheAir = 50;
  attribute access(write: administer) optional boolean requirePINforRemoteOperation = 51;
  attribute access(write: administer) optional int16u expiringUserTimeout = 53;
  provisional readonly attribute access(read: administer) optional nullable octet_string<65> aliroReaderVerificationKey = 128;
  provisional readonly attribute access(read: administer) optional nullable octet_string<16> aliroReaderGroupIdentifier = 129;
  provisional readonly attribute access(read: administer) optional octet_string<16> aliroReaderGroupSubIdentifier = 130;
  provisional readonly attribute access(read: administer) optional octet_string aliroExpeditedTransactionSupportedProtocolVersions[] = 131;
  provisional readonly attribute access(read: administer) optional nullable octet_string<16> aliroGroupResolvingKey = 132;
  provisional readonly attribute access(read: administer) optional octet_string aliroSupportedBLEUWBProtocolVersions[] = 133;
  provisional readonly attribute access(read: administer) optional int8u aliroBLEAdvertisingVersion = 134;
  provisional readonly attribute optional int16u numberOfAliroCredentialIssuerKeysSupported = 135;
  provisional readonly attribute optional int16u numberOfAliroEndpointKeysSupported = 136;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct LockDoorRequest {
    optional octet_string PINCode = 0;
  }

  request struct UnlockDoorRequest {
    optional octet_string PINCode = 0;
  }

  request struct UnlockWithTimeoutRequest {
    int16u timeout = 0;
    optional octet_string PINCode = 1;
  }

  request struct SetWeekDayScheduleRequest {
    int8u weekDayIndex = 0;
    int16u userIndex = 1;
    DaysMaskMap daysMask = 2;
    int8u startHour = 3;
    int8u startMinute = 4;
    int8u endHour = 5;
    int8u endMinute = 6;
  }

  request struct GetWeekDayScheduleRequest {
    int8u weekDayIndex = 0;
    int16u userIndex = 1;
  }

  response struct GetWeekDayScheduleResponse = 12 {
    int8u weekDayIndex = 0;
    int16u userIndex = 1;
    DlStatus status = 2;
    optional DaysMaskMap daysMask = 3;
    optional int8u startHour = 4;
    optional int8u startMinute = 5;
    optional int8u endHour = 6;
    optional int8u endMinute = 7;
  }

  request struct ClearWeekDayScheduleRequest {
    int8u weekDayIndex = 0;
    int16u userIndex = 1;
  }

  request struct SetYearDayScheduleRequest {
    int8u yearDayIndex = 0;
    int16u userIndex = 1;
    epoch_s localStartTime = 2;
    epoch_s localEndTime = 3;
  }

  request struct GetYearDayScheduleRequest {
    int8u yearDayIndex = 0;
    int16u userIndex = 1;
  }

  response struct GetYearDayScheduleResponse = 15 {
    int8u yearDayIndex = 0;
    int16u userIndex = 1;
    DlStatus status = 2;
    optional epoch_s localStartTime = 3;
    optional epoch_s localEndTime = 4;
  }

  request struct ClearYearDayScheduleRequest {
    int8u yearDayIndex = 0;
    int16u userIndex = 1;
  }

  request struct SetHolidayScheduleRequest {
    int8u holidayIndex = 0;
    epoch_s localStartTime = 1;
    epoch_s localEndTime = 2;
    OperatingModeEnum operatingMode = 3;
  }

  request struct GetHolidayScheduleRequest {
    int8u holidayIndex = 0;
  }

  response struct GetHolidayScheduleResponse = 18 {
    int8u holidayIndex = 0;
    DlStatus status = 1;
    optional epoch_s localStartTime = 2;
    optional epoch_s localEndTime = 3;
    optional OperatingModeEnum operatingMode = 4;
  }

  request struct ClearHolidayScheduleRequest {
    int8u holidayIndex = 0;
  }

  request struct SetUserRequest {
    DataOperationTypeEnum operationType = 0;
    int16u userIndex = 1;
    nullable char_string userName = 2;
    nullable int32u userUniqueID = 3;
    nullable UserStatusEnum userStatus = 4;
    nullable UserTypeEnum userType = 5;
    nullable CredentialRuleEnum credentialRule = 6;
  }

  request struct GetUserRequest {
    int16u userIndex = 0;
  }

  response struct GetUserResponse = 28 {
    int16u userIndex = 0;
    nullable char_string userName = 1;
    nullable int32u userUniqueID = 2;
    nullable UserStatusEnum userStatus = 3;
    nullable UserTypeEnum userType = 4;
    nullable CredentialRuleEnum credentialRule = 5;
    nullable CredentialStruct credentials[] = 6;
    nullable fabric_idx creatorFabricIndex = 7;
    nullable fabric_idx lastModifiedFabricIndex = 8;
    nullable int16u nextUserIndex = 9;
  }

  request struct ClearUserRequest {
    int16u userIndex = 0;
  }

  request struct SetCredentialRequest {
    DataOperationTypeEnum operationType = 0;
    CredentialStruct credential = 1;
    long_octet_string credentialData = 2;
    nullable int16u userIndex = 3;
    nullable UserStatusEnum userStatus = 4;
    nullable UserTypeEnum userType = 5;
  }

  response struct SetCredentialResponse = 35 {
    DlStatus status = 0;
    nullable int16u userIndex = 1;
    nullable int16u nextCredentialIndex = 2;
  }

  request struct GetCredentialStatusRequest {
    CredentialStruct credential = 0;
  }

  response struct GetCredentialStatusResponse = 37 {
    boolean credentialExists = 0;
    nullable int16u userIndex = 1;
    nullable fabric_idx creatorFabricIndex = 2;
    nullable fabric_idx lastModifiedFabricIndex = 3;
    nullable int16u nextCredentialIndex = 4;
    optional nullable octet_string credentialData = 5;
  }

  request struct ClearCredentialRequest {
    nullable CredentialStruct credential = 0;
  }

  request struct UnboltDoorRequest {
    optional octet_string PINCode = 0;
  }

  request struct SetAliroReaderConfigRequest {
    octet_string<32> signingKey = 0;
    octet_string<65> verificationKey = 1;
    octet_string<16> groupIdentifier = 2;
    optional octet_string<16> groupResolvingKey = 3;
  }

  /** This command causes the lock device to lock the door. */
  timed command LockDoor(LockDoorRequest): DefaultSuccess = 0;
  /** This command causes the lock device to unlock the door. */
  timed command UnlockDoor(UnlockDoorRequest): DefaultSuccess = 1;
  /** This command causes the lock device to unlock the door with a timeout parameter. */
  timed command UnlockWithTimeout(UnlockWithTimeoutRequest): DefaultSuccess = 3;
  /** Set a weekly repeating schedule for a specified user. */
  command access(invoke: administer) SetWeekDaySchedule(SetWeekDayScheduleRequest): DefaultSuccess = 11;
  /** Retrieve the specific weekly schedule for the specific user. */
  command access(invoke: administer) GetWeekDaySchedule(GetWeekDayScheduleRequest): GetWeekDayScheduleResponse = 12;
  /** Clear the specific weekly schedule or all weekly schedules for the specific user. */
  command access(invoke: administer) ClearWeekDaySchedule(ClearWeekDayScheduleRequest): DefaultSuccess = 13;
  /** Set a time-specific schedule ID for a specified user. */
  command access(invoke: administer) SetYearDaySchedule(SetYearDayScheduleRequest): DefaultSuccess = 14;
  /** Returns the year day schedule data for the specified schedule and user indexes. */
  command access(invoke: administer) GetYearDaySchedule(GetYearDayScheduleRequest): GetYearDayScheduleResponse = 15;
  /** Clears the specific year day schedule or all year day schedules for the specific user. */
  command access(invoke: administer) ClearYearDaySchedule(ClearYearDayScheduleRequest): DefaultSuccess = 16;
  /** Set the holiday Schedule by specifying local start time and local end time with respect to any Lock Operating Mode. */
  command access(invoke: administer) SetHolidaySchedule(SetHolidayScheduleRequest): DefaultSuccess = 17;
  /** Get the holiday schedule for the specified index. */
  command access(invoke: administer) GetHolidaySchedule(GetHolidayScheduleRequest): GetHolidayScheduleResponse = 18;
  /** Clears the holiday schedule or all holiday schedules. */
  command access(invoke: administer) ClearHolidaySchedule(ClearHolidayScheduleRequest): DefaultSuccess = 19;
  /** Set User into the lock. */
  timed command access(invoke: administer) SetUser(SetUserRequest): DefaultSuccess = 26;
  /** Retrieve User. */
  command access(invoke: administer) GetUser(GetUserRequest): GetUserResponse = 27;
  /** Clears a User or all Users. */
  timed command access(invoke: administer) ClearUser(ClearUserRequest): DefaultSuccess = 29;
  /** Set a credential (e.g. PIN, RFID, Fingerprint, etc.) into the lock for a new user, existing user, or ProgrammingUser. */
  timed command access(invoke: administer) SetCredential(SetCredentialRequest): SetCredentialResponse = 34;
  /** Retrieve the status of a particular credential (e.g. PIN, RFID, Fingerprint, etc.) by index. */
  command access(invoke: administer) GetCredentialStatus(GetCredentialStatusRequest): GetCredentialStatusResponse = 36;
  /** Clear one, one type, or all credentials except ProgrammingPIN credential. */
  timed command access(invoke: administer) ClearCredential(ClearCredentialRequest): DefaultSuccess = 38;
  /** This command causes the lock device to unlock the door without pulling the latch. */
  timed command UnboltDoor(UnboltDoorRequest): DefaultSuccess = 39;
  /** This command communicates an Aliro Reader configuration to the lock. */
  timed command access(invoke: administer) SetAliroReaderConfig(SetAliroReaderConfigRequest): DefaultSuccess = 40;
  /** This command clears an existing Aliro Reader configuration for the lock. */
  timed command access(invoke: administer) ClearAliroReaderConfig(): DefaultSuccess = 41;
}

/** Provides an interface for controlling and adjusting automatic window coverings. */
cluster WindowCovering = 258 {
  revision 5;

  enum EndProductType : enum8 {
    kRollerShade = 0;
    kRomanShade = 1;
    kBalloonShade = 2;
    kWovenWood = 3;
    kPleatedShade = 4;
    kCellularShade = 5;
    kLayeredShade = 6;
    kLayeredShade2D = 7;
    kSheerShade = 8;
    kTiltOnlyInteriorBlind = 9;
    kInteriorBlind = 10;
    kVerticalBlindStripCurtain = 11;
    kInteriorVenetianBlind = 12;
    kExteriorVenetianBlind = 13;
    kLateralLeftCurtain = 14;
    kLateralRightCurtain = 15;
    kCentralCurtain = 16;
    kRollerShutter = 17;
    kExteriorVerticalScreen = 18;
    kAwningTerracePatio = 19;
    kAwningVerticalScreen = 20;
    kTiltOnlyPergola = 21;
    kSwingingShutter = 22;
    kSlidingShutter = 23;
    kUnknown = 255;
  }

  enum Type : enum8 {
    kRollerShade = 0;
    kRollerShade2Motor = 1;
    kRollerShadeExterior = 2;
    kRollerShadeExterior2Motor = 3;
    kDrapery = 4;
    kAwning = 5;
    kShutter = 6;
    kTiltBlindTiltOnly = 7;
    kTiltBlindLiftAndTilt = 8;
    kProjectorScreen = 9;
    kUnknown = 255;
  }

  bitmap ConfigStatus : bitmap8 {
    kOperational = 0x1;
    kOnlineReserved = 0x2;
    kLiftMovementReversed = 0x4;
    kLiftPositionAware = 0x8;
    kTiltPositionAware = 0x10;
    kLiftEncoderControlled = 0x20;
    kTiltEncoderControlled = 0x40;
  }

  bitmap Feature : bitmap32 {
    kLift = 0x1;
    kTilt = 0x2;
    kPositionAwareLift = 0x4;
    kAbsolutePosition = 0x8;
    kPositionAwareTilt = 0x10;
  }

  bitmap Mode : bitmap8 {
    kMotorDirectionReversed = 0x1;
    kCalibrationMode = 0x2;
    kMaintenanceMode = 0x4;
    kLedFeedback = 0x8;
  }

  bitmap OperationalStatus : bitmap8 {
    kGlobal = 0x3;
    kLift = 0xC;
    kTilt = 0x30;
  }

  bitmap SafetyStatus : bitmap16 {
    kRemoteLockout = 0x1;
    kTamperDetection = 0x2;
    kFailedCommunication = 0x4;
    kPositionFailure = 0x8;
    kThermalProtection = 0x10;
    kObstacleDetected = 0x20;
    kPower = 0x40;
    kStopInput = 0x80;
    kMotorJammed = 0x100;
    kHardwareFailure = 0x200;
    kManualOperation = 0x400;
    kProtection = 0x800;
  }

  readonly attribute Type type = 0;
  readonly attribute optional int16u physicalClosedLimitLift = 1;
  readonly attribute optional int16u physicalClosedLimitTilt = 2;
  readonly attribute optional nullable int16u currentPositionLift = 3;
  readonly attribute optional nullable int16u currentPositionTilt = 4;
  readonly attribute optional int16u numberOfActuationsLift = 5;
  readonly attribute optional int16u numberOfActuationsTilt = 6;
  readonly attribute ConfigStatus configStatus = 7;
  readonly attribute optional nullable percent currentPositionLiftPercentage = 8;
  readonly attribute optional nullable percent currentPositionTiltPercentage = 9;
  readonly attribute OperationalStatus operationalStatus = 10;
  readonly attribute optional nullable percent100ths targetPositionLiftPercent100ths = 11;
  readonly attribute optional nullable percent100ths targetPositionTiltPercent100ths = 12;
  readonly attribute EndProductType endProductType = 13;
  readonly attribute optional nullable percent100ths currentPositionLiftPercent100ths = 14;
  readonly attribute optional nullable percent100ths currentPositionTiltPercent100ths = 15;
  readonly attribute optional int16u installedOpenLimitLift = 16;
  readonly attribute optional int16u installedClosedLimitLift = 17;
  readonly attribute optional int16u installedOpenLimitTilt = 18;
  readonly attribute optional int16u installedClosedLimitTilt = 19;
  attribute access(write: manage) Mode mode = 23;
  readonly attribute optional SafetyStatus safetyStatus = 26;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct GoToLiftValueRequest {
    int16u liftValue = 0;
  }

  request struct GoToLiftPercentageRequest {
    percent100ths liftPercent100thsValue = 0;
  }

  request struct GoToTiltValueRequest {
    int16u tiltValue = 0;
  }

  request struct GoToTiltPercentageRequest {
    percent100ths tiltPercent100thsValue = 0;
  }

  /** Moves window covering to InstalledOpenLimitLift and InstalledOpenLimitTilt */
  command UpOrOpen(): DefaultSuccess = 0;
  /** Moves window covering to InstalledClosedLimitLift and InstalledCloseLimitTilt */
  command DownOrClose(): DefaultSuccess = 1;
  /** Stop any adjusting of window covering */
  command StopMotion(): DefaultSuccess = 2;
  /** Go to lift value specified */
  command GoToLiftValue(GoToLiftValueRequest): DefaultSuccess = 4;
  /** Go to lift percentage specified */
  command GoToLiftPercentage(GoToLiftPercentageRequest): DefaultSuccess = 5;
  /** Go to tilt value specified */
  command GoToTiltValue(GoToTiltValueRequest): DefaultSuccess = 7;
  /** Go to tilt percentage specified */
  command GoToTiltPercentage(GoToTiltPercentageRequest): DefaultSuccess = 8;
}

/** An interface for configuring and controlling pumps. */
cluster PumpConfigurationAndControl = 512 {
  revision 3;

  enum ControlModeEnum : enum8 {
    kConstantSpeed = 0;
    kConstantPressure = 1;
    kProportionalPressure = 2;
    kConstantFlow = 3;
    kConstantTemperature = 5;
    kAutomatic = 7;
  }

  enum OperationModeEnum : enum8 {
    kNormal = 0;
    kMinimum = 1;
    kMaximum = 2;
    kLocal = 3;
  }

  bitmap Feature : bitmap32 {
    kConstantPressure = 0x1;
    kCompensatedPressure = 0x2;
    kConstantFlow = 0x4;
    kConstantSpeed = 0x8;
    kConstantTemperature = 0x10;
    kAutomatic = 0x20;
    kLocalOperation = 0x40;
  }

  bitmap PumpStatusBitmap : bitmap16 {
    kDeviceFault = 0x1;
    kSupplyFault = 0x2;
    kSpeedLow = 0x4;
    kSpeedHigh = 0x8;
    kLocalOverride = 0x10;
    kRunning = 0x20;
    kRemotePressure = 0x40;
    kRemoteFlow = 0x80;
    kRemoteTemperature = 0x100;
  }

  info event SupplyVoltageLow = 0 {
  }

  info event SupplyVoltageHigh = 1 {
  }

  info event PowerMissingPhase = 2 {
  }

  info event SystemPressureLow = 3 {
  }

  info event SystemPressureHigh = 4 {
  }

  critical event DryRunning = 5 {
  }

  info event MotorTemperatureHigh = 6 {
  }

  critical event PumpMotorFatalFailure = 7 {
  }

  info event ElectronicTemperatureHigh = 8 {
  }

  critical event PumpBlocked = 9 {
  }

  info event SensorFailure = 10 {
  }

  info event ElectronicNonFatalFailure = 11 {
  }

  critical event ElectronicFatalFailure = 12 {
  }

  info event GeneralFault = 13 {
  }

  info event Leakage = 14 {
  }

  info event AirDetection = 15 {
  }

  info event TurbineOperation = 16 {
  }

  readonly attribute nullable int16s maxPressure = 0;
  readonly attribute nullable int16u maxSpeed = 1;
  readonly attribute nullable int16u maxFlow = 2;
  readonly attribute optional nullable int16s minConstPressure = 3;
  readonly attribute optional nullable int16s maxConstPressure = 4;
  readonly attribute optional nullable int16s minCompPressure = 5;
  readonly attribute optional nullable int16s maxCompPressure = 6;
  readonly attribute optional nullable int16u minConstSpeed = 7;
  readonly attribute optional nullable int16u maxConstSpeed = 8;
  readonly attribute optional nullable int16u minConstFlow = 9;
  readonly attribute optional nullable int16u maxConstFlow = 10;
  readonly attribute optional nullable int16s minConstTemp = 11;
  readonly attribute optional nullable int16s maxConstTemp = 12;
  readonly attribute optional PumpStatusBitmap pumpStatus = 16;
  readonly attribute OperationModeEnum effectiveOperationMode = 17;
  readonly attribute ControlModeEnum effectiveControlMode = 18;
  readonly attribute nullable int16s capacity = 19;
  readonly attribute optional nullable int16u speed = 20;
  attribute access(write: manage) optional nullable int24u lifetimeRunningHours = 21;
  readonly attribute optional nullable int24u power = 22;
  attribute access(write: manage) optional nullable int32u lifetimeEnergyConsumed = 23;
  attribute access(write: manage) OperationModeEnum operationMode = 32;
  attribute access(write: manage) optional ControlModeEnum controlMode = 33;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** An interface for configuring and controlling the functionality of a thermostat. */
cluster Thermostat = 513 {
  revision 7;

  enum ACCapacityFormatEnum : enum8 {
    kBTUh = 0;
  }

  enum ACCompressorTypeEnum : enum8 {
    kUnknown = 0;
    kT1 = 1;
    kT2 = 2;
    kT3 = 3;
  }

  enum ACLouverPositionEnum : enum8 {
    kClosed = 1;
    kOpen = 2;
    kQuarter = 3;
    kHalf = 4;
    kThreeQuarters = 5;
  }

  enum ACRefrigerantTypeEnum : enum8 {
    kUnknown = 0;
    kR22 = 1;
    kR410a = 2;
    kR407c = 3;
  }

  enum ACTypeEnum : enum8 {
    kUnknown = 0;
    kCoolingFixed = 1;
    kHeatPumpFixed = 2;
    kCoolingInverter = 3;
    kHeatPumpInverter = 4;
  }

  enum ControlSequenceOfOperationEnum : enum8 {
    kCoolingOnly = 0;
    kCoolingWithReheat = 1;
    kHeatingOnly = 2;
    kHeatingWithReheat = 3;
    kCoolingAndHeating = 4;
    kCoolingAndHeatingWithReheat = 5;
  }

  enum PresetScenarioEnum : enum8 {
    kOccupied = 1;
    kUnoccupied = 2;
    kSleep = 3;
    kWake = 4;
    kVacation = 5;
    kGoingToSleep = 6;
    kUserDefined = 254;
  }

  enum SetpointChangeSourceEnum : enum8 {
    kManual = 0;
    kSchedule = 1;
    kExternal = 2;
  }

  enum SetpointRaiseLowerModeEnum : enum8 {
    kHeat = 0;
    kCool = 1;
    kBoth = 2;
  }

  enum StartOfWeekEnum : enum8 {
    kSunday = 0;
    kMonday = 1;
    kTuesday = 2;
    kWednesday = 3;
    kThursday = 4;
    kFriday = 5;
    kSaturday = 6;
  }

  enum SystemModeEnum : enum8 {
    kOff = 0;
    kAuto = 1;
    kCool = 3;
    kHeat = 4;
    kEmergencyHeat = 5;
    kPrecooling = 6;
    kFanOnly = 7;
    kDry = 8;
    kSleep = 9;
  }

  enum TemperatureSetpointHoldEnum : enum8 {
    kSetpointHoldOff = 0;
    kSetpointHoldOn = 1;
  }

  enum ThermostatRunningModeEnum : enum8 {
    kOff = 0;
    kCool = 3;
    kHeat = 4;
  }

  bitmap ACErrorCodeBitmap : bitmap32 {
    kCompressorFail = 0x1;
    kRoomSensorFail = 0x2;
    kOutdoorSensorFail = 0x4;
    kCoilSensorFail = 0x8;
    kFanFail = 0x10;
  }

  bitmap Feature : bitmap32 {
    kHeating = 0x1;
    kCooling = 0x2;
    kOccupancy = 0x4;
    kScheduleConfiguration = 0x8;
    kSetback = 0x10;
    kAutoMode = 0x20;
    kLocalTemperatureNotExposed = 0x40;
    kMatterScheduleConfiguration = 0x80;
    kPresets = 0x100;
  }

  bitmap HVACSystemTypeBitmap : bitmap8 {
    kCoolingStage = 0x3;
    kHeatingStage = 0xC;
    kHeatingIsHeatPump = 0x10;
    kHeatingUsesFuel = 0x20;
  }

  bitmap OccupancyBitmap : bitmap8 {
    kOccupied = 0x1;
  }

  bitmap PresetTypeFeaturesBitmap : bitmap16 {
    kAutomatic = 0x1;
    kSupportsNames = 0x2;
  }

  bitmap ProgrammingOperationModeBitmap : bitmap8 {
    kScheduleActive = 0x1;
    kAutoRecovery = 0x2;
    kEconomy = 0x4;
  }

  bitmap RelayStateBitmap : bitmap16 {
    kHeat = 0x1;
    kCool = 0x2;
    kFan = 0x4;
    kHeatStage2 = 0x8;
    kCoolStage2 = 0x10;
    kFanStage2 = 0x20;
    kFanStage3 = 0x40;
  }

  bitmap RemoteSensingBitmap : bitmap8 {
    kLocalTemperature = 0x1;
    kOutdoorTemperature = 0x2;
    kOccupancy = 0x4;
  }

  bitmap ScheduleDayOfWeekBitmap : bitmap8 {
    kSunday = 0x1;
    kMonday = 0x2;
    kTuesday = 0x4;
    kWednesday = 0x8;
    kThursday = 0x10;
    kFriday = 0x20;
    kSaturday = 0x40;
    kAway = 0x80;
  }

  bitmap ScheduleModeBitmap : bitmap8 {
    kHeatSetpointPresent = 0x1;
    kCoolSetpointPresent = 0x2;
  }

  bitmap ScheduleTypeFeaturesBitmap : bitmap16 {
    kSupportsPresets = 0x1;
    kSupportsSetpoints = 0x2;
    kSupportsNames = 0x4;
    kSupportsOff = 0x8;
  }

  struct ScheduleTransitionStruct {
    ScheduleDayOfWeekBitmap dayOfWeek = 0;
    int16u transitionTime = 1;
    optional octet_string<16> presetHandle = 2;
    optional SystemModeEnum systemMode = 3;
    optional temperature coolingSetpoint = 4;
    optional temperature heatingSetpoint = 5;
  }

  struct ScheduleStruct {
    nullable octet_string<16> scheduleHandle = 0;
    SystemModeEnum systemMode = 1;
    optional char_string<64> name = 2;
    optional octet_string<16> presetHandle = 3;
    ScheduleTransitionStruct transitions[] = 4;
    nullable boolean builtIn = 5;
  }

  struct PresetStruct {
    nullable octet_string<16> presetHandle = 0;
    PresetScenarioEnum presetScenario = 1;
    optional nullable char_string<64> name = 2;
    optional temperature coolingSetpoint = 3;
    optional temperature heatingSetpoint = 4;
    nullable boolean builtIn = 5;
  }

  struct PresetTypeStruct {
    PresetScenarioEnum presetScenario = 0;
    int8u numberOfPresets = 1;
    PresetTypeFeaturesBitmap presetTypeFeatures = 2;
  }

  struct ScheduleTypeStruct {
    SystemModeEnum systemMode = 0;
    int8u numberOfSchedules = 1;
    ScheduleTypeFeaturesBitmap scheduleTypeFeatures = 2;
  }

  struct WeeklyScheduleTransitionStruct {
    int16u transitionTime = 0;
    nullable temperature heatSetpoint = 1;
    nullable temperature coolSetpoint = 2;
  }

  readonly attribute nullable temperature localTemperature = 0;
  readonly attribute optional nullable temperature outdoorTemperature = 1;
  readonly attribute optional OccupancyBitmap occupancy = 2;
  readonly attribute optional temperature absMinHeatSetpointLimit = 3;
  readonly attribute optional temperature absMaxHeatSetpointLimit = 4;
  readonly attribute optional temperature absMinCoolSetpointLimit = 5;
  readonly attribute optional temperature absMaxCoolSetpointLimit = 6;
  readonly attribute optional int8u PICoolingDemand = 7;
  readonly attribute optional int8u PIHeatingDemand = 8;
  attribute access(write: manage) optional HVACSystemTypeBitmap HVACSystemTypeConfiguration = 9;
  attribute access(write: manage) optional int8s localTemperatureCalibration = 16;
  attribute optional temperature occupiedCoolingSetpoint = 17;
  attribute optional temperature occupiedHeatingSetpoint = 18;
  attribute optional temperature unoccupiedCoolingSetpoint = 19;
  attribute optional temperature unoccupiedHeatingSetpoint = 20;
  attribute access(write: manage) optional temperature minHeatSetpointLimit = 21;
  attribute access(write: manage) optional temperature maxHeatSetpointLimit = 22;
  attribute access(write: manage) optional temperature minCoolSetpointLimit = 23;
  attribute access(write: manage) optional temperature maxCoolSetpointLimit = 24;
  attribute access(write: manage) optional int8s minSetpointDeadBand = 25;
  attribute access(write: manage) optional RemoteSensingBitmap remoteSensing = 26;
  attribute access(write: manage) ControlSequenceOfOperationEnum controlSequenceOfOperation = 27;
  attribute access(write: manage) SystemModeEnum systemMode = 28;
  readonly attribute optional ThermostatRunningModeEnum thermostatRunningMode = 30;
  readonly attribute optional StartOfWeekEnum startOfWeek = 32;
  readonly attribute optional int8u numberOfWeeklyTransitions = 33;
  readonly attribute optional int8u numberOfDailyTransitions = 34;
  attribute access(write: manage) optional TemperatureSetpointHoldEnum temperatureSetpointHold = 35;
  attribute access(write: manage) optional nullable int16u temperatureSetpointHoldDuration = 36;
  attribute access(write: manage) optional ProgrammingOperationModeBitmap thermostatProgrammingOperationMode = 37;
  readonly attribute optional RelayStateBitmap thermostatRunningState = 41;
  readonly attribute optional SetpointChangeSourceEnum setpointChangeSource = 48;
  readonly attribute optional nullable int16s setpointChangeAmount = 49;
  readonly attribute optional epoch_s setpointChangeSourceTimestamp = 50;
  attribute access(write: manage) optional nullable int8u occupiedSetback = 52;
  readonly attribute optional nullable int8u occupiedSetbackMin = 53;
  readonly attribute optional nullable int8u occupiedSetbackMax = 54;
  attribute access(write: manage) optional nullable int8u unoccupiedSetback = 55;
  readonly attribute optional nullable int8u unoccupiedSetbackMin = 56;
  readonly attribute optional nullable int8u unoccupiedSetbackMax = 57;
  attribute access(write: manage) optional int8u emergencyHeatDelta = 58;
  attribute access(write: manage) optional ACTypeEnum ACType = 64;
  attribute access(write: manage) optional int16u ACCapacity = 65;
  attribute access(write: manage) optional ACRefrigerantTypeEnum ACRefrigerantType = 66;
  attribute access(write: manage) optional ACCompressorTypeEnum ACCompressorType = 67;
  attribute access(write: manage) optional ACErrorCodeBitmap ACErrorCode = 68;
  attribute access(write: manage) optional ACLouverPositionEnum ACLouverPosition = 69;
  readonly attribute optional nullable temperature ACCoilTemperature = 70;
  attribute access(write: manage) optional ACCapacityFormatEnum ACCapacityformat = 71;
  readonly attribute optional PresetTypeStruct presetTypes[] = 72;
  readonly attribute optional ScheduleTypeStruct scheduleTypes[] = 73;
  readonly attribute optional int8u numberOfPresets = 74;
  readonly attribute optional int8u numberOfSchedules = 75;
  readonly attribute optional int8u numberOfScheduleTransitions = 76;
  readonly attribute optional nullable int8u numberOfScheduleTransitionPerDay = 77;
  readonly attribute optional nullable octet_string<16> activePresetHandle = 78;
  readonly attribute optional nullable octet_string<16> activeScheduleHandle = 79;
  attribute access(write: manage) optional PresetStruct presets[] = 80;
  attribute access(write: manage) optional ScheduleStruct schedules[] = 81;
  readonly attribute optional nullable epoch_s setpointHoldExpiryTimestamp = 82;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct SetpointRaiseLowerRequest {
    SetpointRaiseLowerModeEnum mode = 0;
    int8s amount = 1;
  }

  response struct GetWeeklyScheduleResponse = 0 {
    int8u numberOfTransitionsForSequence = 0;
    ScheduleDayOfWeekBitmap dayOfWeekForSequence = 1;
    ScheduleModeBitmap modeForSequence = 2;
    WeeklyScheduleTransitionStruct transitions[] = 3;
  }

  request struct SetWeeklyScheduleRequest {
    int8u numberOfTransitionsForSequence = 0;
    ScheduleDayOfWeekBitmap dayOfWeekForSequence = 1;
    ScheduleModeBitmap modeForSequence = 2;
    WeeklyScheduleTransitionStruct transitions[] = 3;
  }

  request struct GetWeeklyScheduleRequest {
    ScheduleDayOfWeekBitmap daysToReturn = 0;
    ScheduleModeBitmap modeToReturn = 1;
  }

  request struct SetActiveScheduleRequestRequest {
    octet_string<16> scheduleHandle = 0;
  }

  request struct SetActivePresetRequestRequest {
    nullable octet_string<16> presetHandle = 0;
  }

  response struct AtomicResponse = 253 {
    status statusCode = 0;
    AtomicAttributeStatusStruct attributeStatus[] = 1;
    optional int16u timeout = 2;
  }

  request struct AtomicRequestRequest {
    AtomicRequestTypeEnum requestType = 0;
    attrib_id attributeRequests[] = 1;
    optional int16u timeout = 2;
  }

  /** Upon receipt, the attributes for the indicated setpoint(s) SHALL have the amount specified in the Amount field added to them. */
  command SetpointRaiseLower(SetpointRaiseLowerRequest): DefaultSuccess = 0;
  /** This command is used to update the thermostat weekly setpoint schedule from a management system. */
  command access(invoke: manage) SetWeeklySchedule(SetWeeklyScheduleRequest): DefaultSuccess = 1;
  /** The Current Weekly Schedule Command is sent from the server in response to the Get Weekly Schedule Command. */
  command GetWeeklySchedule(GetWeeklyScheduleRequest): GetWeeklyScheduleResponse = 2;
  /** This command is used to clear the weekly schedule. */
  command access(invoke: manage) ClearWeeklySchedule(): DefaultSuccess = 3;
  /** Upon receipt, if the Schedules attribute contains a ScheduleStruct whose ScheduleHandle field matches the value of the ScheduleHandle field, the server SHALL set the thermostat's ActiveScheduleHandle attribute to the value of the ScheduleHandle field. */
  command SetActiveScheduleRequest(SetActiveScheduleRequestRequest): DefaultSuccess = 5;
  /** ID */
  command SetActivePresetRequest(SetActivePresetRequestRequest): DefaultSuccess = 6;
  /** Begins, Commits or Cancels an atomic write */
  command access(invoke: manage) AtomicRequest(AtomicRequestRequest): AtomicResponse = 254;
}

/** An interface for controlling a fan in a heating/cooling system. */
cluster FanControl = 514 {
  revision 4;

  enum AirflowDirectionEnum : enum8 {
    kForward = 0;
    kReverse = 1;
  }

  enum FanModeEnum : enum8 {
    kOff = 0;
    kLow = 1;
    kMedium = 2;
    kHigh = 3;
    kOn = 4;
    kAuto = 5;
    kSmart = 6;
  }

  enum FanModeSequenceEnum : enum8 {
    kOffLowMedHigh = 0;
    kOffLowHigh = 1;
    kOffLowMedHighAuto = 2;
    kOffLowHighAuto = 3;
    kOffHighAuto = 4;
    kOffHigh = 5;
  }

  enum StepDirectionEnum : enum8 {
    kIncrease = 0;
    kDecrease = 1;
  }

  bitmap Feature : bitmap32 {
    kMultiSpeed = 0x1;
    kAuto = 0x2;
    kRocking = 0x4;
    kWind = 0x8;
    kStep = 0x10;
    kAirflowDirection = 0x20;
  }

  bitmap RockBitmap : bitmap8 {
    kRockLeftRight = 0x1;
    kRockUpDown = 0x2;
    kRockRound = 0x4;
  }

  bitmap WindBitmap : bitmap8 {
    kSleepWind = 0x1;
    kNaturalWind = 0x2;
  }

  attribute FanModeEnum fanMode = 0;
  readonly attribute FanModeSequenceEnum fanModeSequence = 1;
  attribute nullable percent percentSetting = 2;
  readonly attribute percent percentCurrent = 3;
  readonly attribute optional int8u speedMax = 4;
  attribute optional nullable int8u speedSetting = 5;
  readonly attribute optional int8u speedCurrent = 6;
  readonly attribute optional RockBitmap rockSupport = 7;
  attribute optional RockBitmap rockSetting = 8;
  readonly attribute optional WindBitmap windSupport = 9;
  attribute optional WindBitmap windSetting = 10;
  attribute optional AirflowDirectionEnum airflowDirection = 11;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct StepRequest {
    StepDirectionEnum direction = 0;
    optional boolean wrap = 1;
    optional boolean lowestOff = 2;
  }

  /** The Step command speeds up or slows down the fan, in steps. */
  command Step(StepRequest): DefaultSuccess = 0;
}

/** An interface for configuring the user interface of a thermostat (which may be remote from the thermostat). */
cluster ThermostatUserInterfaceConfiguration = 516 {
  revision 2;

  enum KeypadLockoutEnum : enum8 {
    kNoLockout = 0;
    kLockout1 = 1;
    kLockout2 = 2;
    kLockout3 = 3;
    kLockout4 = 4;
    kLockout5 = 5;
  }

  enum ScheduleProgrammingVisibilityEnum : enum8 {
    kScheduleProgrammingPermitted = 0;
    kScheduleProgrammingDenied = 1;
  }

  enum TemperatureDisplayModeEnum : enum8 {
    kCelsius = 0;
    kFahrenheit = 1;
  }

  attribute TemperatureDisplayModeEnum temperatureDisplayMode = 0;
  attribute access(write: manage) KeypadLockoutEnum keypadLockout = 1;
  attribute access(write: manage) optional ScheduleProgrammingVisibilityEnum scheduleProgrammingVisibility = 2;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Attributes and commands for controlling the color properties of a color-capable light. */
cluster ColorControl = 768 {
  revision 7;

  enum ColorLoopActionEnum : enum8 {
    kDeactivate = 0;
    kActivateFromColorLoopStartEnhancedHue = 1;
    kActivateFromEnhancedCurrentHue = 2;
  }

  enum ColorLoopDirectionEnum : enum8 {
    kDecrement = 0;
    kIncrement = 1;
  }

  enum ColorModeEnum : enum8 {
    kCurrentHueAndCurrentSaturation = 0;
    kCurrentXAndCurrentY = 1;
    kColorTemperatureMireds = 2;
  }

  enum DirectionEnum : enum8 {
    kShortest = 0;
    kLongest = 1;
    kUp = 2;
    kDown = 3;
  }

  enum DriftCompensationEnum : enum8 {
    kNone = 0;
    kOtherOrUnknown = 1;
    kTemperatureMonitoring = 2;
    kOpticalLuminanceMonitoringAndFeedback = 3;
    kOpticalColorMonitoringAndFeedback = 4;
  }

  enum EnhancedColorModeEnum : enum8 {
    kCurrentHueAndCurrentSaturation = 0;
    kCurrentXAndCurrentY = 1;
    kColorTemperatureMireds = 2;
    kEnhancedCurrentHueAndCurrentSaturation = 3;
  }

  enum MoveModeEnum : enum8 {
    kStop = 0;
    kUp = 1;
    kDown = 3;
  }

  enum StepModeEnum : enum8 {
    kUp = 1;
    kDown = 3;
  }

  bitmap ColorCapabilitiesBitmap : bitmap16 {
    kHueSaturation = 0x1;
    kEnhancedHue = 0x2;
    kColorLoop = 0x4;
    kXY = 0x8;
    kColorTemperature = 0x10;
  }

  bitmap Feature : bitmap32 {
    kHueAndSaturation = 0x1;
    kEnhancedHue = 0x2;
    kColorLoop = 0x4;
    kXY = 0x8;
    kColorTemperature = 0x10;
  }

  bitmap OptionsBitmap : bitmap8 {
    kExecuteIfOff = 0x1;
  }

  bitmap UpdateFlagsBitmap : bitmap8 {
    kUpdateAction = 0x1;
    kUpdateDirection = 0x2;
    kUpdateTime = 0x4;
    kUpdateStartHue = 0x8;
  }

  readonly attribute optional int8u currentHue = 0;
  readonly attribute optional int8u currentSaturation = 1;
  readonly attribute optional int16u remainingTime = 2;
  readonly attribute optional int16u currentX = 3;
  readonly attribute optional int16u currentY = 4;
  readonly attribute optional DriftCompensationEnum driftCompensation = 5;
  readonly attribute optional char_string<254> compensationText = 6;
  readonly attribute optional int16u colorTemperatureMireds = 7;
  readonly attribute ColorModeEnum colorMode = 8;
  attribute OptionsBitmap options = 15;
  readonly attribute nullable int8u numberOfPrimaries = 16;
  readonly attribute optional int16u primary1X = 17;
  readonly attribute optional int16u primary1Y = 18;
  readonly attribute optional nullable int8u primary1Intensity = 19;
  readonly attribute optional int16u primary2X = 21;
  readonly attribute optional int16u primary2Y = 22;
  readonly attribute optional nullable int8u primary2Intensity = 23;
  readonly attribute optional int16u primary3X = 25;
  readonly attribute optional int16u primary3Y = 26;
  readonly attribute optional nullable int8u primary3Intensity = 27;
  readonly attribute optional int16u primary4X = 32;
  readonly attribute optional int16u primary4Y = 33;
  readonly attribute optional nullable int8u primary4Intensity = 34;
  readonly attribute optional int16u primary5X = 36;
  readonly attribute optional int16u primary5Y = 37;
  readonly attribute optional nullable int8u primary5Intensity = 38;
  readonly attribute optional int16u primary6X = 40;
  readonly attribute optional int16u primary6Y = 41;
  readonly attribute optional nullable int8u primary6Intensity = 42;
  attribute access(write: manage) optional int16u whitePointX = 48;
  attribute access(write: manage) optional int16u whitePointY = 49;
  attribute access(write: manage) optional int16u colorPointRX = 50;
  attribute access(write: manage) optional int16u colorPointRY = 51;
  attribute access(write: manage) optional nullable int8u colorPointRIntensity = 52;
  attribute access(write: manage) optional int16u colorPointGX = 54;
  attribute access(write: manage) optional int16u colorPointGY = 55;
  attribute access(write: manage) optional nullable int8u colorPointGIntensity = 56;
  attribute access(write: manage) optional int16u colorPointBX = 58;
  attribute access(write: manage) optional int16u colorPointBY = 59;
  attribute access(write: manage) optional nullable int8u colorPointBIntensity = 60;
  readonly attribute optional int16u enhancedCurrentHue = 16384;
  readonly attribute EnhancedColorModeEnum enhancedColorMode = 16385;
  readonly attribute optional int8u colorLoopActive = 16386;
  readonly attribute optional int8u colorLoopDirection = 16387;
  readonly attribute optional int16u colorLoopTime = 16388;
  readonly attribute optional int16u colorLoopStartEnhancedHue = 16389;
  readonly attribute optional int16u colorLoopStoredEnhancedHue = 16390;
  readonly attribute ColorCapabilitiesBitmap colorCapabilities = 16394;
  readonly attribute optional int16u colorTempPhysicalMinMireds = 16395;
  readonly attribute optional int16u colorTempPhysicalMaxMireds = 16396;
  readonly attribute optional int16u coupleColorTempToLevelMinMireds = 16397;
  attribute access(write: manage) optional nullable int16u startUpColorTemperatureMireds = 16400;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct MoveToHueRequest {
    int8u hue = 0;
    DirectionEnum direction = 1;
    int16u transitionTime = 2;
    OptionsBitmap optionsMask = 3;
    OptionsBitmap optionsOverride = 4;
  }

  request struct MoveHueRequest {
    MoveModeEnum moveMode = 0;
    int8u rate = 1;
    OptionsBitmap optionsMask = 2;
    OptionsBitmap optionsOverride = 3;
  }

  request struct StepHueRequest {
    StepModeEnum stepMode = 0;
    int8u stepSize = 1;
    int8u transitionTime = 2;
    OptionsBitmap optionsMask = 3;
    OptionsBitmap optionsOverride = 4;
  }

  request struct MoveToSaturationRequest {
    int8u saturation = 0;
    int16u transitionTime = 1;
    OptionsBitmap optionsMask = 2;
    OptionsBitmap optionsOverride = 3;
  }

  request struct MoveSaturationRequest {
    MoveModeEnum moveMode = 0;
    int8u rate = 1;
    OptionsBitmap optionsMask = 2;
    OptionsBitmap optionsOverride = 3;
  }

  request struct StepSaturationRequest {
    StepModeEnum stepMode = 0;
    int8u stepSize = 1;
    int8u transitionTime = 2;
    OptionsBitmap optionsMask = 3;
    OptionsBitmap optionsOverride = 4;
  }

  request struct MoveToHueAndSaturationRequest {
    int8u hue = 0;
    int8u saturation = 1;
    int16u transitionTime = 2;
    OptionsBitmap optionsMask = 3;
    OptionsBitmap optionsOverride = 4;
  }

  request struct MoveToColorRequest {
    int16u colorX = 0;
    int16u colorY = 1;
    int16u transitionTime = 2;
    OptionsBitmap optionsMask = 3;
    OptionsBitmap optionsOverride = 4;
  }

  request struct MoveColorRequest {
    int16s rateX = 0;
    int16s rateY = 1;
    OptionsBitmap optionsMask = 2;
    OptionsBitmap optionsOverride = 3;
  }

  request struct StepColorRequest {
    int16s stepX = 0;
    int16s stepY = 1;
    int16u transitionTime = 2;
    OptionsBitmap optionsMask = 3;
    OptionsBitmap optionsOverride = 4;
  }

  request struct MoveToColorTemperatureRequest {
    int16u colorTemperatureMireds = 0;
    int16u transitionTime = 1;
    OptionsBitmap optionsMask = 2;
    OptionsBitmap optionsOverride = 3;
  }

  request struct EnhancedMoveToHueRequest {
    int16u enhancedHue = 0;
    DirectionEnum direction = 1;
    int16u transitionTime = 2;
    OptionsBitmap optionsMask = 3;
    OptionsBitmap optionsOverride = 4;
  }

  request struct EnhancedMoveHueRequest {
    MoveModeEnum moveMode = 0;
    int16u rate = 1;
    OptionsBitmap optionsMask = 2;
    OptionsBitmap optionsOverride = 3;
  }

  request struct EnhancedStepHueRequest {
    StepModeEnum stepMode = 0;
    int16u stepSize = 1;
    int16u transitionTime = 2;
    OptionsBitmap optionsMask = 3;
    OptionsBitmap optionsOverride = 4;
  }

  request struct EnhancedMoveToHueAndSaturationRequest {
    int16u enhancedHue = 0;
    int8u saturation = 1;
    int16u transitionTime = 2;
    OptionsBitmap optionsMask = 3;
    OptionsBitmap optionsOverride = 4;
  }

  request struct ColorLoopSetRequest {
    UpdateFlagsBitmap updateFlags = 0;
    ColorLoopActionEnum action = 1;
    ColorLoopDirectionEnum direction = 2;
    int16u time = 3;
    int16u startHue = 4;
    OptionsBitmap optionsMask = 5;
    OptionsBitmap optionsOverride = 6;
  }

  request struct StopMoveStepRequest {
    OptionsBitmap optionsMask = 0;
    OptionsBitmap optionsOverride = 1;
  }

  request struct MoveColorTemperatureRequest {
    MoveModeEnum moveMode = 0;
    int16u rate = 1;
    int16u colorTemperatureMinimumMireds = 2;
    int16u colorTemperatureMaximumMireds = 3;
    OptionsBitmap optionsMask = 4;
    OptionsBitmap optionsOverride = 5;
  }

  request struct StepColorTemperatureRequest {
    StepModeEnum stepMode = 0;
    int16u stepSize = 1;
    int16u transitionTime = 2;
    int16u colorTemperatureMinimumMireds = 3;
    int16u colorTemperatureMaximumMireds = 4;
    OptionsBitmap optionsMask = 5;
    OptionsBitmap optionsOverride = 6;
  }

  /** Move to specified hue. */
  command MoveToHue(MoveToHueRequest): DefaultSuccess = 0;
  /** Move hue up or down at specified rate. */
  command MoveHue(MoveHueRequest): DefaultSuccess = 1;
  /** Step hue up or down by specified size at specified rate. */
  command StepHue(StepHueRequest): DefaultSuccess = 2;
  /** Move to specified saturation. */
  command MoveToSaturation(MoveToSaturationRequest): DefaultSuccess = 3;
  /** Move saturation up or down at specified rate. */
  command MoveSaturation(MoveSaturationRequest): DefaultSuccess = 4;
  /** Step saturation up or down by specified size at specified rate. */
  command StepSaturation(StepSaturationRequest): DefaultSuccess = 5;
  /** Move to hue and saturation. */
  command MoveToHueAndSaturation(MoveToHueAndSaturationRequest): DefaultSuccess = 6;
  /** Move to specified color. */
  command MoveToColor(MoveToColorRequest): DefaultSuccess = 7;
  /** Moves the color. */
  command MoveColor(MoveColorRequest): DefaultSuccess = 8;
  /** Steps the lighting to a specific color. */
  command StepColor(StepColorRequest): DefaultSuccess = 9;
  /** Move to a specific color temperature. */
  command MoveToColorTemperature(MoveToColorTemperatureRequest): DefaultSuccess = 10;
  /** Command description for EnhancedMoveToHue */
  command EnhancedMoveToHue(EnhancedMoveToHueRequest): DefaultSuccess = 64;
  /** Command description for EnhancedMoveHue */
  command EnhancedMoveHue(EnhancedMoveHueRequest): DefaultSuccess = 65;
  /** Command description for EnhancedStepHue */
  command EnhancedStepHue(EnhancedStepHueRequest): DefaultSuccess = 66;
  /** Command description for EnhancedMoveToHueAndSaturation */
  command EnhancedMoveToHueAndSaturation(EnhancedMoveToHueAndSaturationRequest): DefaultSuccess = 67;
  /** Command description for ColorLoopSet */
  command ColorLoopSet(ColorLoopSetRequest): DefaultSuccess = 68;
  /** Command description for StopMoveStep */
  command StopMoveStep(StopMoveStepRequest): DefaultSuccess = 71;
  /** Command description for MoveColorTemperature */
  command MoveColorTemperature(MoveColorTemperatureRequest): DefaultSuccess = 75;
  /** Command description for StepColorTemperature */
  command StepColorTemperature(StepColorTemperatureRequest): DefaultSuccess = 76;
}

/** Attributes and commands for configuring a lighting ballast. */
provisional cluster BallastConfiguration = 769 {
  revision 4;

  bitmap BallastStatusBitmap : bitmap8 {
    kBallastNonOperational = 0x1;
    kLampFailure = 0x2;
  }

  bitmap LampAlarmModeBitmap : bitmap8 {
    kLampBurnHours = 0x1;
  }

  readonly attribute int8u physicalMinLevel = 0;
  readonly attribute int8u physicalMaxLevel = 1;
  readonly attribute optional BallastStatusBitmap ballastStatus = 2;
  attribute access(write: manage) int8u minLevel = 16;
  attribute access(write: manage) int8u maxLevel = 17;
  attribute access(write: manage) optional nullable int8u intrinsicBallastFactor = 20;
  attribute access(write: manage) optional nullable int8u ballastFactorAdjustment = 21;
  readonly attribute int8u lampQuantity = 32;
  attribute access(write: manage) optional char_string<16> lampType = 48;
  attribute access(write: manage) optional char_string<16> lampManufacturer = 49;
  attribute access(write: manage) optional nullable int24u lampRatedHours = 50;
  attribute access(write: manage) optional nullable int24u lampBurnHours = 51;
  attribute access(write: manage) optional LampAlarmModeBitmap lampAlarmMode = 52;
  attribute access(write: manage) optional nullable int24u lampBurnHoursTripPoint = 53;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Attributes and commands for configuring the measurement of illuminance, and reporting illuminance measurements. */
cluster IlluminanceMeasurement = 1024 {
  revision 3;

  enum LightSensorTypeEnum : enum8 {
    kPhotodiode = 0;
    kCMOS = 1;
  }

  readonly attribute nullable int16u measuredValue = 0;
  readonly attribute nullable int16u minMeasuredValue = 1;
  readonly attribute nullable int16u maxMeasuredValue = 2;
  readonly attribute optional int16u tolerance = 3;
  readonly attribute optional nullable LightSensorTypeEnum lightSensorType = 4;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Attributes and commands for configuring the measurement of temperature, and reporting temperature measurements. */
cluster TemperatureMeasurement = 1026 {
  revision 1; // NOTE: Default/not specifically set

  readonly attribute nullable temperature measuredValue = 0;
  readonly attribute nullable temperature minMeasuredValue = 1;
  readonly attribute nullable temperature maxMeasuredValue = 2;
  readonly attribute optional int16u tolerance = 3;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Attributes and commands for configuring the measurement of pressure, and reporting pressure measurements. */
cluster PressureMeasurement = 1027 {
  revision 3;

  bitmap Feature : bitmap32 {
    kExtended = 0x1;
  }

  readonly attribute nullable int16s measuredValue = 0;
  readonly attribute nullable int16s minMeasuredValue = 1;
  readonly attribute nullable int16s maxMeasuredValue = 2;
  readonly attribute optional int16u tolerance = 3;
  readonly attribute optional nullable int16s scaledValue = 16;
  readonly attribute optional nullable int16s minScaledValue = 17;
  readonly attribute optional nullable int16s maxScaledValue = 18;
  readonly attribute optional int16u scaledTolerance = 19;
  readonly attribute optional int8s scale = 20;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Attributes and commands for configuring the measurement of flow, and reporting flow measurements. */
cluster FlowMeasurement = 1028 {
  revision 1; // NOTE: Default/not specifically set

  readonly attribute nullable int16u measuredValue = 0;
  readonly attribute nullable int16u minMeasuredValue = 1;
  readonly attribute nullable int16u maxMeasuredValue = 2;
  readonly attribute optional int16u tolerance = 3;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Attributes and commands for configuring the measurement of relative humidity, and reporting relative humidity measurements. */
cluster RelativeHumidityMeasurement = 1029 {
  revision 3;

  readonly attribute nullable int16u measuredValue = 0;
  readonly attribute nullable int16u minMeasuredValue = 1;
  readonly attribute nullable int16u maxMeasuredValue = 2;
  readonly attribute optional int16u tolerance = 3;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** The server cluster provides an interface to occupancy sensing functionality based on one or more sensing modalities, including configuration and provision of notifications of occupancy status. */
cluster OccupancySensing = 1030 {
  revision 5;

  enum OccupancySensorTypeEnum : enum8 {
    kPIR = 0;
    kUltrasonic = 1;
    kPIRAndUltrasonic = 2;
    kPhysicalContact = 3;
  }

  bitmap Feature : bitmap32 {
    kOther = 0x1;
    kPassiveInfrared = 0x2;
    kUltrasonic = 0x4;
    kPhysicalContact = 0x8;
    kActiveInfrared = 0x10;
    kRadar = 0x20;
    kRFSensing = 0x40;
    kVision = 0x80;
  }

  bitmap OccupancyBitmap : bitmap8 {
    kOccupied = 0x1;
  }

  bitmap OccupancySensorTypeBitmap : bitmap8 {
    kPIR = 0x1;
    kUltrasonic = 0x2;
    kPhysicalContact = 0x4;
  }

  struct HoldTimeLimitsStruct {
    int16u holdTimeMin = 0;
    int16u holdTimeMax = 1;
    int16u holdTimeDefault = 2;
  }

  info event OccupancyChanged = 0 {
    OccupancyBitmap occupancy = 0;
  }

  readonly attribute OccupancyBitmap occupancy = 0;
  readonly attribute OccupancySensorTypeEnum occupancySensorType = 1;
  readonly attribute OccupancySensorTypeBitmap occupancySensorTypeBitmap = 2;
  attribute access(write: manage) optional int16u holdTime = 3;
  readonly attribute optional HoldTimeLimitsStruct holdTimeLimits = 4;
  attribute access(write: manage) optional int16u PIROccupiedToUnoccupiedDelay = 16;
  attribute access(write: manage) optional int16u PIRUnoccupiedToOccupiedDelay = 17;
  attribute access(write: manage) optional int8u PIRUnoccupiedToOccupiedThreshold = 18;
  attribute access(write: manage) optional int16u ultrasonicOccupiedToUnoccupiedDelay = 32;
  attribute access(write: manage) optional int16u ultrasonicUnoccupiedToOccupiedDelay = 33;
  attribute access(write: manage) optional int8u ultrasonicUnoccupiedToOccupiedThreshold = 34;
  attribute access(write: manage) optional int16u physicalContactOccupiedToUnoccupiedDelay = 48;
  attribute access(write: manage) optional int16u physicalContactUnoccupiedToOccupiedDelay = 49;
  attribute access(write: manage) optional int8u physicalContactUnoccupiedToOccupiedThreshold = 50;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Attributes for reporting carbon monoxide concentration measurements */
cluster CarbonMonoxideConcentrationMeasurement = 1036 {
  revision 3;

  enum LevelValueEnum : enum8 {
    kUnknown = 0;
    kLow = 1;
    kMedium = 2;
    kHigh = 3;
    kCritical = 4;
  }

  enum MeasurementMediumEnum : enum8 {
    kAir = 0;
    kWater = 1;
    kSoil = 2;
  }

  enum MeasurementUnitEnum : enum8 {
    kPPM = 0;
    kPPB = 1;
    kPPT = 2;
    kMGM3 = 3;
    kUGM3 = 4;
    kNGM3 = 5;
    kPM3 = 6;
    kBQM3 = 7;
  }

  bitmap Feature : bitmap32 {
    kNumericMeasurement = 0x1;
    kLevelIndication = 0x2;
    kMediumLevel = 0x4;
    kCriticalLevel = 0x8;
    kPeakMeasurement = 0x10;
    kAverageMeasurement = 0x20;
  }

  readonly attribute optional nullable single measuredValue = 0;
  readonly attribute optional nullable single minMeasuredValue = 1;
  readonly attribute optional nullable single maxMeasuredValue = 2;
  readonly attribute optional nullable single peakMeasuredValue = 3;
  readonly attribute optional elapsed_s peakMeasuredValueWindow = 4;
  readonly attribute optional nullable single averageMeasuredValue = 5;
  readonly attribute optional elapsed_s averageMeasuredValueWindow = 6;
  readonly attribute optional single uncertainty = 7;
  readonly attribute optional MeasurementUnitEnum measurementUnit = 8;
  readonly attribute optional MeasurementMediumEnum measurementMedium = 9;
  readonly attribute optional LevelValueEnum levelValue = 10;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Attributes for reporting carbon dioxide concentration measurements */
cluster CarbonDioxideConcentrationMeasurement = 1037 {
  revision 3;

  enum LevelValueEnum : enum8 {
    kUnknown = 0;
    kLow = 1;
    kMedium = 2;
    kHigh = 3;
    kCritical = 4;
  }

  enum MeasurementMediumEnum : enum8 {
    kAir = 0;
    kWater = 1;
    kSoil = 2;
  }

  enum MeasurementUnitEnum : enum8 {
    kPPM = 0;
    kPPB = 1;
    kPPT = 2;
    kMGM3 = 3;
    kUGM3 = 4;
    kNGM3 = 5;
    kPM3 = 6;
    kBQM3 = 7;
  }

  bitmap Feature : bitmap32 {
    kNumericMeasurement = 0x1;
    kLevelIndication = 0x2;
    kMediumLevel = 0x4;
    kCriticalLevel = 0x8;
    kPeakMeasurement = 0x10;
    kAverageMeasurement = 0x20;
  }

  readonly attribute optional nullable single measuredValue = 0;
  readonly attribute optional nullable single minMeasuredValue = 1;
  readonly attribute optional nullable single maxMeasuredValue = 2;
  readonly attribute optional nullable single peakMeasuredValue = 3;
  readonly attribute optional elapsed_s peakMeasuredValueWindow = 4;
  readonly attribute optional nullable single averageMeasuredValue = 5;
  readonly attribute optional elapsed_s averageMeasuredValueWindow = 6;
  readonly attribute optional single uncertainty = 7;
  readonly attribute optional MeasurementUnitEnum measurementUnit = 8;
  readonly attribute optional MeasurementMediumEnum measurementMedium = 9;
  readonly attribute optional LevelValueEnum levelValue = 10;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Attributes for reporting nitrogen dioxide concentration measurements */
cluster NitrogenDioxideConcentrationMeasurement = 1043 {
  revision 3;

  enum LevelValueEnum : enum8 {
    kUnknown = 0;
    kLow = 1;
    kMedium = 2;
    kHigh = 3;
    kCritical = 4;
  }

  enum MeasurementMediumEnum : enum8 {
    kAir = 0;
    kWater = 1;
    kSoil = 2;
  }

  enum MeasurementUnitEnum : enum8 {
    kPPM = 0;
    kPPB = 1;
    kPPT = 2;
    kMGM3 = 3;
    kUGM3 = 4;
    kNGM3 = 5;
    kPM3 = 6;
    kBQM3 = 7;
  }

  bitmap Feature : bitmap32 {
    kNumericMeasurement = 0x1;
    kLevelIndication = 0x2;
    kMediumLevel = 0x4;
    kCriticalLevel = 0x8;
    kPeakMeasurement = 0x10;
    kAverageMeasurement = 0x20;
  }

  readonly attribute optional nullable single measuredValue = 0;
  readonly attribute optional nullable single minMeasuredValue = 1;
  readonly attribute optional nullable single maxMeasuredValue = 2;
  readonly attribute optional nullable single peakMeasuredValue = 3;
  readonly attribute optional elapsed_s peakMeasuredValueWindow = 4;
  readonly attribute optional nullable single averageMeasuredValue = 5;
  readonly attribute optional elapsed_s averageMeasuredValueWindow = 6;
  readonly attribute optional single uncertainty = 7;
  readonly attribute optional MeasurementUnitEnum measurementUnit = 8;
  readonly attribute optional MeasurementMediumEnum measurementMedium = 9;
  readonly attribute optional LevelValueEnum levelValue = 10;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Attributes for reporting ozone concentration measurements */
cluster OzoneConcentrationMeasurement = 1045 {
  revision 3;

  enum LevelValueEnum : enum8 {
    kUnknown = 0;
    kLow = 1;
    kMedium = 2;
    kHigh = 3;
    kCritical = 4;
  }

  enum MeasurementMediumEnum : enum8 {
    kAir = 0;
    kWater = 1;
    kSoil = 2;
  }

  enum MeasurementUnitEnum : enum8 {
    kPPM = 0;
    kPPB = 1;
    kPPT = 2;
    kMGM3 = 3;
    kUGM3 = 4;
    kNGM3 = 5;
    kPM3 = 6;
    kBQM3 = 7;
  }

  bitmap Feature : bitmap32 {
    kNumericMeasurement = 0x1;
    kLevelIndication = 0x2;
    kMediumLevel = 0x4;
    kCriticalLevel = 0x8;
    kPeakMeasurement = 0x10;
    kAverageMeasurement = 0x20;
  }

  readonly attribute optional nullable single measuredValue = 0;
  readonly attribute optional nullable single minMeasuredValue = 1;
  readonly attribute optional nullable single maxMeasuredValue = 2;
  readonly attribute optional nullable single peakMeasuredValue = 3;
  readonly attribute optional elapsed_s peakMeasuredValueWindow = 4;
  readonly attribute optional nullable single averageMeasuredValue = 5;
  readonly attribute optional elapsed_s averageMeasuredValueWindow = 6;
  readonly attribute optional single uncertainty = 7;
  readonly attribute optional MeasurementUnitEnum measurementUnit = 8;
  readonly attribute optional MeasurementMediumEnum measurementMedium = 9;
  readonly attribute optional LevelValueEnum levelValue = 10;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Attributes for reporting PM2.5 concentration measurements */
cluster Pm25ConcentrationMeasurement = 1066 {
  revision 3;

  enum LevelValueEnum : enum8 {
    kUnknown = 0;
    kLow = 1;
    kMedium = 2;
    kHigh = 3;
    kCritical = 4;
  }

  enum MeasurementMediumEnum : enum8 {
    kAir = 0;
    kWater = 1;
    kSoil = 2;
  }

  enum MeasurementUnitEnum : enum8 {
    kPPM = 0;
    kPPB = 1;
    kPPT = 2;
    kMGM3 = 3;
    kUGM3 = 4;
    kNGM3 = 5;
    kPM3 = 6;
    kBQM3 = 7;
  }

  bitmap Feature : bitmap32 {
    kNumericMeasurement = 0x1;
    kLevelIndication = 0x2;
    kMediumLevel = 0x4;
    kCriticalLevel = 0x8;
    kPeakMeasurement = 0x10;
    kAverageMeasurement = 0x20;
  }

  readonly attribute optional nullable single measuredValue = 0;
  readonly attribute optional nullable single minMeasuredValue = 1;
  readonly attribute optional nullable single maxMeasuredValue = 2;
  readonly attribute optional nullable single peakMeasuredValue = 3;
  readonly attribute optional elapsed_s peakMeasuredValueWindow = 4;
  readonly attribute optional nullable single averageMeasuredValue = 5;
  readonly attribute optional elapsed_s averageMeasuredValueWindow = 6;
  readonly attribute optional single uncertainty = 7;
  readonly attribute optional MeasurementUnitEnum measurementUnit = 8;
  readonly attribute optional MeasurementMediumEnum measurementMedium = 9;
  readonly attribute optional LevelValueEnum levelValue = 10;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Attributes for reporting formaldehyde concentration measurements */
cluster FormaldehydeConcentrationMeasurement = 1067 {
  revision 3;

  enum LevelValueEnum : enum8 {
    kUnknown = 0;
    kLow = 1;
    kMedium = 2;
    kHigh = 3;
    kCritical = 4;
  }

  enum MeasurementMediumEnum : enum8 {
    kAir = 0;
    kWater = 1;
    kSoil = 2;
  }

  enum MeasurementUnitEnum : enum8 {
    kPPM = 0;
    kPPB = 1;
    kPPT = 2;
    kMGM3 = 3;
    kUGM3 = 4;
    kNGM3 = 5;
    kPM3 = 6;
    kBQM3 = 7;
  }

  bitmap Feature : bitmap32 {
    kNumericMeasurement = 0x1;
    kLevelIndication = 0x2;
    kMediumLevel = 0x4;
    kCriticalLevel = 0x8;
    kPeakMeasurement = 0x10;
    kAverageMeasurement = 0x20;
  }

  readonly attribute optional nullable single measuredValue = 0;
  readonly attribute optional nullable single minMeasuredValue = 1;
  readonly attribute optional nullable single maxMeasuredValue = 2;
  readonly attribute optional nullable single peakMeasuredValue = 3;
  readonly attribute optional elapsed_s peakMeasuredValueWindow = 4;
  readonly attribute optional nullable single averageMeasuredValue = 5;
  readonly attribute optional elapsed_s averageMeasuredValueWindow = 6;
  readonly attribute optional single uncertainty = 7;
  readonly attribute optional MeasurementUnitEnum measurementUnit = 8;
  readonly attribute optional MeasurementMediumEnum measurementMedium = 9;
  readonly attribute optional LevelValueEnum levelValue = 10;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Attributes for reporting PM1 concentration measurements */
cluster Pm1ConcentrationMeasurement = 1068 {
  revision 3;

  enum LevelValueEnum : enum8 {
    kUnknown = 0;
    kLow = 1;
    kMedium = 2;
    kHigh = 3;
    kCritical = 4;
  }

  enum MeasurementMediumEnum : enum8 {
    kAir = 0;
    kWater = 1;
    kSoil = 2;
  }

  enum MeasurementUnitEnum : enum8 {
    kPPM = 0;
    kPPB = 1;
    kPPT = 2;
    kMGM3 = 3;
    kUGM3 = 4;
    kNGM3 = 5;
    kPM3 = 6;
    kBQM3 = 7;
  }

  bitmap Feature : bitmap32 {
    kNumericMeasurement = 0x1;
    kLevelIndication = 0x2;
    kMediumLevel = 0x4;
    kCriticalLevel = 0x8;
    kPeakMeasurement = 0x10;
    kAverageMeasurement = 0x20;
  }

  readonly attribute optional nullable single measuredValue = 0;
  readonly attribute optional nullable single minMeasuredValue = 1;
  readonly attribute optional nullable single maxMeasuredValue = 2;
  readonly attribute optional nullable single peakMeasuredValue = 3;
  readonly attribute optional elapsed_s peakMeasuredValueWindow = 4;
  readonly attribute optional nullable single averageMeasuredValue = 5;
  readonly attribute optional elapsed_s averageMeasuredValueWindow = 6;
  readonly attribute optional single uncertainty = 7;
  readonly attribute optional MeasurementUnitEnum measurementUnit = 8;
  readonly attribute optional MeasurementMediumEnum measurementMedium = 9;
  readonly attribute optional LevelValueEnum levelValue = 10;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Attributes for reporting PM10 concentration measurements */
cluster Pm10ConcentrationMeasurement = 1069 {
  revision 3;

  enum LevelValueEnum : enum8 {
    kUnknown = 0;
    kLow = 1;
    kMedium = 2;
    kHigh = 3;
    kCritical = 4;
  }

  enum MeasurementMediumEnum : enum8 {
    kAir = 0;
    kWater = 1;
    kSoil = 2;
  }

  enum MeasurementUnitEnum : enum8 {
    kPPM = 0;
    kPPB = 1;
    kPPT = 2;
    kMGM3 = 3;
    kUGM3 = 4;
    kNGM3 = 5;
    kPM3 = 6;
    kBQM3 = 7;
  }

  bitmap Feature : bitmap32 {
    kNumericMeasurement = 0x1;
    kLevelIndication = 0x2;
    kMediumLevel = 0x4;
    kCriticalLevel = 0x8;
    kPeakMeasurement = 0x10;
    kAverageMeasurement = 0x20;
  }

  readonly attribute optional nullable single measuredValue = 0;
  readonly attribute optional nullable single minMeasuredValue = 1;
  readonly attribute optional nullable single maxMeasuredValue = 2;
  readonly attribute optional nullable single peakMeasuredValue = 3;
  readonly attribute optional elapsed_s peakMeasuredValueWindow = 4;
  readonly attribute optional nullable single averageMeasuredValue = 5;
  readonly attribute optional elapsed_s averageMeasuredValueWindow = 6;
  readonly attribute optional single uncertainty = 7;
  readonly attribute optional MeasurementUnitEnum measurementUnit = 8;
  readonly attribute optional MeasurementMediumEnum measurementMedium = 9;
  readonly attribute optional LevelValueEnum levelValue = 10;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Attributes for reporting total volatile organic compounds concentration measurements */
cluster TotalVolatileOrganicCompoundsConcentrationMeasurement = 1070 {
  revision 3;

  enum LevelValueEnum : enum8 {
    kUnknown = 0;
    kLow = 1;
    kMedium = 2;
    kHigh = 3;
    kCritical = 4;
  }

  enum MeasurementMediumEnum : enum8 {
    kAir = 0;
    kWater = 1;
    kSoil = 2;
  }

  enum MeasurementUnitEnum : enum8 {
    kPPM = 0;
    kPPB = 1;
    kPPT = 2;
    kMGM3 = 3;
    kUGM3 = 4;
    kNGM3 = 5;
    kPM3 = 6;
    kBQM3 = 7;
  }

  bitmap Feature : bitmap32 {
    kNumericMeasurement = 0x1;
    kLevelIndication = 0x2;
    kMediumLevel = 0x4;
    kCriticalLevel = 0x8;
    kPeakMeasurement = 0x10;
    kAverageMeasurement = 0x20;
  }

  readonly attribute optional nullable single measuredValue = 0;
  readonly attribute optional nullable single minMeasuredValue = 1;
  readonly attribute optional nullable single maxMeasuredValue = 2;
  readonly attribute optional nullable single peakMeasuredValue = 3;
  readonly attribute optional elapsed_s peakMeasuredValueWindow = 4;
  readonly attribute optional nullable single averageMeasuredValue = 5;
  readonly attribute optional elapsed_s averageMeasuredValueWindow = 6;
  readonly attribute optional single uncertainty = 7;
  readonly attribute optional MeasurementUnitEnum measurementUnit = 8;
  readonly attribute optional MeasurementMediumEnum measurementMedium = 9;
  readonly attribute optional LevelValueEnum levelValue = 10;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Attributes for reporting radon concentration measurements */
cluster RadonConcentrationMeasurement = 1071 {
  revision 3;

  enum LevelValueEnum : enum8 {
    kUnknown = 0;
    kLow = 1;
    kMedium = 2;
    kHigh = 3;
    kCritical = 4;
  }

  enum MeasurementMediumEnum : enum8 {
    kAir = 0;
    kWater = 1;
    kSoil = 2;
  }

  enum MeasurementUnitEnum : enum8 {
    kPPM = 0;
    kPPB = 1;
    kPPT = 2;
    kMGM3 = 3;
    kUGM3 = 4;
    kNGM3 = 5;
    kPM3 = 6;
    kBQM3 = 7;
  }

  bitmap Feature : bitmap32 {
    kNumericMeasurement = 0x1;
    kLevelIndication = 0x2;
    kMediumLevel = 0x4;
    kCriticalLevel = 0x8;
    kPeakMeasurement = 0x10;
    kAverageMeasurement = 0x20;
  }

  readonly attribute optional nullable single measuredValue = 0;
  readonly attribute optional nullable single minMeasuredValue = 1;
  readonly attribute optional nullable single maxMeasuredValue = 2;
  readonly attribute optional nullable single peakMeasuredValue = 3;
  readonly attribute optional elapsed_s peakMeasuredValueWindow = 4;
  readonly attribute optional nullable single averageMeasuredValue = 5;
  readonly attribute optional elapsed_s averageMeasuredValueWindow = 6;
  readonly attribute optional single uncertainty = 7;
  readonly attribute optional MeasurementUnitEnum measurementUnit = 8;
  readonly attribute optional MeasurementMediumEnum measurementMedium = 9;
  readonly attribute optional LevelValueEnum levelValue = 10;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

endpoint 0 {
  device type ma_rootdevice = 22, version 1;

  binding cluster AccessControl;

  server cluster Descriptor {
    callback attribute deviceTypeList;
    callback attribute serverList;
    callback attribute clientList;
    callback attribute partsList;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    callback attribute featureMap;
    callback attribute clusterRevision;
  }

  server cluster AccessControl {
    emits event AccessControlEntryChanged;
    callback attribute acl;
    callback attribute extension;
    callback attribute subjectsPerAccessControlEntry;
    callback attribute targetsPerAccessControlEntry;
    callback attribute accessControlEntriesPerFabric;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    ram      attribute featureMap default = 0;
    callback attribute clusterRevision;
  }

  server cluster BasicInformation {
    emits event StartUp;
    emits event ShutDown;
    emits event Leave;
    callback attribute dataModelRevision;
    callback attribute vendorName;
    callback attribute vendorID;
    callback attribute productName;
    callback attribute productID;
    persist  attribute nodeLabel;
    callback attribute location;
    callback attribute hardwareVersion;
    callback attribute hardwareVersionString;
    callback attribute softwareVersion;
    callback attribute softwareVersionString;
    callback attribute manufacturingDate;
    callback attribute partNumber;
    callback attribute productURL;
    callback attribute productLabel;
    callback attribute serialNumber;
    persist  attribute localConfigDisabled default = 0;
    callback attribute reachable default = 1;
    callback attribute uniqueID;
    callback attribute capabilityMinima;
    callback attribute specificationVersion;
    callback attribute maxPathsPerInvoke;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 2;
  }

  server cluster LocalizationConfiguration {
    persist  attribute activeLocale default = "en-US";
    callback attribute supportedLocales;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 1;
  }

  server cluster TimeFormatLocalization {
    persist  attribute hourFormat default = 0;
    persist  attribute activeCalendarType default = 0;
    callback attribute supportedCalendarTypes;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 1;
  }

  server cluster UnitLocalization {
    persist  attribute temperatureUnit default = 0;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    ram      attribute featureMap default = 0x1;
    ram      attribute clusterRevision default = 1;
  }

  server cluster GeneralCommissioning {
    ram      attribute breadcrumb default = 0x0000000000000000;
    callback attribute basicCommissioningInfo;
    callback attribute regulatoryConfig;
    callback attribute locationCapability;
    callback attribute supportsConcurrentConnection;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 1;

    handle command ArmFailSafe;
    handle command ArmFailSafeResponse;
    handle command SetRegulatoryConfig;
    handle command SetRegulatoryConfigResponse;
    handle command CommissioningComplete;
    handle command CommissioningCompleteResponse;
  }

  server cluster NetworkCommissioning {
    ram      attribute maxNetworks;
    callback attribute networks;
    ram      attribute scanMaxTimeSeconds;
    ram      attribute connectMaxTimeSeconds;
    ram      attribute interfaceEnabled;
    ram      attribute lastNetworkingStatus;
    ram      attribute lastNetworkID;
    ram      attribute lastConnectErrorValue;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    ram      attribute featureMap default = 2;
    ram      attribute clusterRevision default = 1;

    handle command ScanNetworks;
    handle command ScanNetworksResponse;
    handle command AddOrUpdateWiFiNetwork;
    handle command AddOrUpdateThreadNetwork;
    handle command RemoveNetwork;
    handle command NetworkConfigResponse;
    handle command ConnectNetwork;
    handle command ConnectNetworkResponse;
    handle command ReorderNetwork;
  }

  server cluster DiagnosticLogs {
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 1;

    handle command RetrieveLogsRequest;
    handle command RetrieveLogsResponse;
  }

  server cluster GeneralDiagnostics {
    emits event BootReason;
    callback attribute networkInterfaces;
    callback attribute rebootCount;
    callback attribute upTime;
    callback attribute totalOperationalHours;
    callback attribute bootReason;
    callback attribute activeHardwareFaults;
    callback attribute activeRadioFaults;
    callback attribute activeNetworkFaults;
    callback attribute testEventTriggersEnabled default = false;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    callback attribute featureMap;
    callback attribute clusterRevision;

    handle command TestEventTrigger;
    handle command TimeSnapshot;
    handle command TimeSnapshotResponse;
  }

  server cluster SoftwareDiagnostics {
    emits event SoftwareFault;
    callback attribute threadMetrics;
    callback attribute currentHeapFree;
    callback attribute currentHeapUsed;
    callback attribute currentHeapHighWatermark;
    callback attribute featureMap;
    ram      attribute clusterRevision default = 1;
  }

  server cluster ThreadNetworkDiagnostics {
    callback attribute channel;
    callback attribute routingRole;
    callback attribute networkName;
    callback attribute panId;
    callback attribute extendedPanId;
    callback attribute meshLocalPrefix;
    callback attribute overrunCount;
    callback attribute neighborTable;
    callback attribute routeTable;
    callback attribute partitionId;
    callback attribute weighting;
    callback attribute dataVersion;
    callback attribute stableDataVersion;
    callback attribute leaderRouterId;
    callback attribute detachedRoleCount;
    callback attribute childRoleCount;
    callback attribute routerRoleCount;
    callback attribute leaderRoleCount;
    callback attribute attachAttemptCount;
    callback attribute partitionIdChangeCount;
    callback attribute betterPartitionAttachAttemptCount;
    callback attribute parentChangeCount;
    callback attribute txTotalCount;
    callback attribute txUnicastCount;
    callback attribute txBroadcastCount;
    callback attribute txAckRequestedCount;
    callback attribute txAckedCount;
    callback attribute txNoAckRequestedCount;
    callback attribute txDataCount;
    callback attribute txDataPollCount;
    callback attribute txBeaconCount;
    callback attribute txBeaconRequestCount;
    callback attribute txOtherCount;
    callback attribute txRetryCount;
    callback attribute txDirectMaxRetryExpiryCount;
    callback attribute txIndirectMaxRetryExpiryCount;
    callback attribute txErrCcaCount;
    callback attribute txErrAbortCount;
    callback attribute txErrBusyChannelCount;
    callback attribute rxTotalCount;
    callback attribute rxUnicastCount;
    callback attribute rxBroadcastCount;
    callback attribute rxDataCount;
    callback attribute rxDataPollCount;
    callback attribute rxBeaconCount;
    callback attribute rxBeaconRequestCount;
    callback attribute rxOtherCount;
    callback attribute rxAddressFilteredCount;
    callback attribute rxDestAddrFilteredCount;
    callback attribute rxDuplicatedCount;
    callback attribute rxErrNoFrameCount;
    callback attribute rxErrUnknownNeighborCount;
    callback attribute rxErrInvalidSrcAddrCount;
    callback attribute rxErrSecCount;
    callback attribute rxErrFcsCount;
    callback attribute rxErrOtherCount;
    callback attribute activeTimestamp;
    callback attribute pendingTimestamp;
    callback attribute delay;
    callback attribute securityPolicy;
    callback attribute channelPage0Mask;
    callback attribute operationalDatasetComponents;
    callback attribute activeNetworkFaultsList;
    ram      attribute featureMap default = 15;
    ram      attribute clusterRevision default = 1;
  }

  server cluster WiFiNetworkDiagnostics {
    emits event Disconnection;
    emits event AssociationFailure;
    emits event ConnectionStatus;
    callback attribute bssid;
    callback attribute securityType;
    callback attribute wiFiVersion;
    callback attribute channelNumber;
    callback attribute rssi;
    callback attribute beaconLostCount;
    callback attribute beaconRxCount;
    callback attribute packetMulticastRxCount;
    callback attribute packetMulticastTxCount;
    callback attribute packetUnicastRxCount;
    callback attribute packetUnicastTxCount;
    callback attribute currentMaxRate;
    callback attribute overrunCount;
    ram      attribute featureMap default = 3;
    ram      attribute clusterRevision default = 1;
  }

  server cluster EthernetNetworkDiagnostics {
    callback attribute PHYRate;
    callback attribute fullDuplex;
    callback attribute packetRxCount;
    callback attribute packetTxCount;
    callback attribute txErrCount;
    callback attribute collisionCount;
    callback attribute overrunCount;
    callback attribute carrierDetect;
    callback attribute timeSinceReset;
    ram      attribute featureMap default = 3;
    ram      attribute clusterRevision default = 1;

    handle command ResetCounts;
  }

  server cluster AdministratorCommissioning {
    callback attribute windowStatus;
    callback attribute adminFabricIndex;
    callback attribute adminVendorId;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 1;

    handle command OpenCommissioningWindow;
    handle command OpenBasicCommissioningWindow;
    handle command RevokeCommissioning;
  }

  server cluster OperationalCredentials {
    callback attribute NOCs;
    callback attribute fabrics;
    callback attribute supportedFabrics;
    callback attribute commissionedFabrics;
    callback attribute trustedRootCertificates;
    callback attribute currentFabricIndex;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 1;

    handle command AttestationRequest;
    handle command AttestationResponse;
    handle command CertificateChainRequest;
    handle command CertificateChainResponse;
    handle command CSRRequest;
    handle command CSRResponse;
    handle command AddNOC;
    handle command UpdateNOC;
    handle command NOCResponse;
    handle command UpdateFabricLabel;
    handle command RemoveFabric;
    handle command AddTrustedRootCertificate;
  }

  server cluster GroupKeyManagement {
    callback attribute groupKeyMap;
    callback attribute groupTable;
    callback attribute maxGroupsPerFabric;
    callback attribute maxGroupKeysPerFabric;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    callback attribute featureMap;
    callback attribute clusterRevision;

    handle command KeySetWrite;
    handle command KeySetRead;
    handle command KeySetReadResponse;
    handle command KeySetRemove;
    handle command KeySetReadAllIndices;
    handle command KeySetReadAllIndicesResponse;
  }

  server cluster UserLabel {
    callback attribute labelList;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 1;
  }
}
endpoint 1 {
  device type ma_aggregator = 14, version 1;

  binding cluster Binding;

  server cluster Identify {
    ram      attribute identifyTime default = 0x0;
    ram      attribute identifyType default = 0x0;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 2;

    handle command Identify;
    handle command TriggerEffect;
  }

  server cluster Descriptor {
    callback attribute deviceTypeList;
    callback attribute serverList;
    callback attribute clientList;
    callback attribute partsList;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    callback attribute featureMap;
    callback attribute clusterRevision;
  }

  server cluster Actions {
    emits event StateChanged;
    callback attribute actionList;
    callback attribute endpointLists;
    ram      attribute setupURL default = "https://example.com";
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute attributeList;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 1;

    handle command InstantAction;
  }
}
endpoint 2 {
  device type ma_rootdevice = 22, version 1;

  binding cluster BasicInformation;
  binding cluster OtaSoftwareUpdateProvider;
  binding cluster LaundryWasherMode;
  binding cluster RefrigeratorAndTemperatureControlledCabinetMode;
  binding cluster DishwasherMode;
  binding cluster DoorLock;

  server cluster Identify {
    callback attribute identifyTime default = 0x0;
    callback attribute identifyType default = 0x00;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute eventList;
    callback attribute attributeList;
    callback attribute featureMap default = 0;
    callback attribute clusterRevision default = 4;

    handle command Identify;
    handle command TriggerEffect;
  }

  server cluster Groups {
    callback attribute nameSupport default = 0;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute eventList;
    callback attribute attributeList;
    callback attribute featureMap default = 0;
    callback attribute clusterRevision default = 4;

    handle command AddGroup;
    handle command AddGroupResponse;
    handle command ViewGroup;
    handle command ViewGroupResponse;
    handle command GetGroupMembership;
    handle command GetGroupMembershipResponse;
    handle command RemoveGroup;
    handle command RemoveGroupResponse;
    handle command RemoveAllGroups;
    handle command AddGroupIfIdentifying;
  }

  server cluster OnOff {
    callback attribute onOff default = 0;
    callback attribute globalSceneControl default = 1;
    callback attribute onTime default = 0;
    callback attribute offWaitTime default = 0;
    callback attribute startUpOnOff default = 0;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute eventList;
    callback attribute attributeList;
    callback attribute featureMap default = 0;
    callback attribute clusterRevision default = 5;

    handle command Off;
    handle command On;
    handle command Toggle;
    handle command OffWithEffect;
    handle command OnWithRecallGlobalScene;
    handle command OnWithTimedOff;
  }

  server cluster LevelControl {
    callback attribute currentLevel default = 0x00;
    callback attribute remainingTime default = 0x0000;
    callback attribute minLevel default = 0x00;
    callback attribute maxLevel default = 0xFE;
    callback attribute currentFrequency default = 0x0000;
    callback attribute minFrequency default = 0x0000;
    callback attribute maxFrequency default = 0x0000;
    callback attribute options default = 0x00;
    callback attribute onOffTransitionTime default = 0x0000;
    callback attribute onLevel default = 0;
    callback attribute onTransitionTime default = 0;
    callback attribute offTransitionTime default = 0;
    callback attribute defaultMoveRate default = 0;
    callback attribute startUpCurrentLevel default = 0;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute eventList;
    callback attribute attributeList;
    callback attribute featureMap default = 0;
    callback attribute clusterRevision default = 5;

    handle command MoveToLevel;
    handle command Move;
    handle command Step;
    handle command Stop;
    handle command MoveToLevelWithOnOff;
    handle command MoveWithOnOff;
    handle command StepWithOnOff;
    handle command StopWithOnOff;
  }

  server cluster Descriptor {
    callback attribute deviceTypeList;
    callback attribute serverList;
    callback attribute clientList;
    callback attribute partsList;
    callback attribute tagList;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute eventList;
    callback attribute attributeList;
    callback attribute featureMap;
    callback attribute clusterRevision;
  }

  server cluster Binding {
    callback attribute binding;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute eventList;
    callback attribute attributeList;
    callback attribute featureMap default = 0;
    callback attribute clusterRevision default = 1;
  }

  server cluster AccessControl {
    callback attribute acl;
    callback attribute extension;
    callback attribute subjectsPerAccessControlEntry;
    callback attribute targetsPerAccessControlEntry;
    callback attribute accessControlEntriesPerFabric;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute eventList;
    callback attribute attributeList;
    callback attribute featureMap default = 0;
    callback attribute clusterRevision;
  }

  server cluster BasicInformation {
    emits event StartUp;
    emits event ShutDown;
    emits event Leave;
    emits event ReachableChanged;
    callback attribute dataModelRevision;
    callback attribute vendorName;
    callback attribute vendorID;
    callback attribute productName;
    callback attribute productID;
    callback attribute nodeLabel;
    callback attribute location;
    callback attribute hardwareVersion;
    callback attribute hardwareVersionString;
    callback attribute softwareVersion;
    callback attribute softwareVersionString;
    callback attribute manufacturingDate;
    callback attribute partNumber;
    callback attribute productURL;
    callback attribute productLabel;
    callback attribute serialNumber;
    callback attribute localConfigDisabled default = 0;
    callback attribute reachable default = 1;
    callback attribute uniqueID;
    callback attribute capabilityMinima;
    callback attribute productAppearance;
    callback attribute specificationVersion;
    callback attribute maxPathsPerInvoke;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute eventList;
    callback attribute attributeList;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 2;
  }

  server cluster OtaSoftwareUpdateRequestor {
    emits event StateTransition;
    emits event VersionApplied;
    emits event DownloadError;
    callback attribute defaultOTAProviders;
    ram      attribute updatePossible default = true;
    ram      attribute updateState default = 0;
    ram      attribute updateStateProgress;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute eventList;
    callback attribute attributeList;
    callback attribute featureMap default = 0;
    callback attribute clusterRevision default = 1;

    handle command AnnounceOTAProvider;
  }

  server cluster LocalizationConfiguration {
    ram      attribute activeLocale;
    callback attribute supportedLocales;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute eventList;
    callback attribute attributeList;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 1;
  }

  server cluster TimeFormatLocalization {
    ram      attribute hourFormat;
    ram      attribute activeCalendarType;
    callback attribute supportedCalendarTypes;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute eventList;
    callback attribute attributeList;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 1;
  }

  server cluster UnitLocalization {
    ram      attribute temperatureUnit;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute eventList;
    callback attribute attributeList;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 1;
  }

  server cluster PowerSourceConfiguration {
    callback attribute sources;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute eventList;
    callback attribute attributeList;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 1;
  }

  server cluster GeneralCommissioning {
    ram      attribute breadcrumb default = 0x0000000000000000;
    callback attribute basicCommissioningInfo;
    callback attribute regulatoryConfig;
    callback attribute locationCapability;
    callback attribute supportsConcurrentConnection;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute eventList;
    callback attribute attributeList;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 1;

    handle command ArmFailSafe;
    handle command ArmFailSafeResponse;
    handle command SetRegulatoryConfig;
    handle command SetRegulatoryConfigResponse;
    handle command CommissioningComplete;
    handle command CommissioningCompleteResponse;
  }

  server cluster NetworkCommissioning {
    ram      attribute maxNetworks;
    callback attribute networks;
    ram      attribute scanMaxTimeSeconds;
    ram      attribute connectMaxTimeSeconds;
    ram      attribute interfaceEnabled;
    ram      attribute lastNetworkingStatus;
    ram      attribute lastNetworkID;
    ram      attribute lastConnectErrorValue;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute eventList;
    callback attribute attributeList;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 1;

    handle command ScanNetworks;
    handle command ScanNetworksResponse;
    handle command AddOrUpdateWiFiNetwork;
    handle command AddOrUpdateThreadNetwork;
    handle command RemoveNetwork;
    handle command NetworkConfigResponse;
    handle command ConnectNetwork;
    handle command ConnectNetworkResponse;
    handle command ReorderNetwork;
  }

  server cluster GeneralDiagnostics {
    emits event HardwareFaultChange;
    emits event RadioFaultChange;
    emits event NetworkFaultChange;
    emits event BootReason;
    callback attribute networkInterfaces;
    callback attribute rebootCount;
    callback attribute upTime;
    callback attribute totalOperationalHours;
    callback attribute bootReason;
    callback attribute activeHardwareFaults;
    callback attribute activeRadioFaults;
    callback attribute activeNetworkFaults;
    ram      attribute testEventTriggersEnabled;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute eventList;
    callback attribute attributeList;
    callback attribute featureMap;
    callback attribute clusterRevision;

    handle command TestEventTrigger;
    handle command TimeSnapshot;
    handle command TimeSnapshotResponse;
  }

  server cluster BridgedDeviceBasicInformation {
    emits event StartUp;
    emits event ShutDown;
    emits event Leave;
    emits event ReachableChanged;
    callback attribute vendorName;
    callback attribute vendorID default = 0;
    callback attribute productName;
    callback attribute nodeLabel;
    callback attribute hardwareVersion default = 0;
    callback attribute hardwareVersionString;
    callback attribute softwareVersion default = 0;
    callback attribute softwareVersionString;
    callback attribute manufacturingDate;
    callback attribute partNumber;
    callback attribute productURL;
    callback attribute productLabel;
    callback attribute serialNumber;
    callback attribute reachable default = 1;
    callback attribute uniqueID;
    callback attribute productAppearance;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute eventList;
    callback attribute attributeList;
    callback attribute featureMap default = 0;
    callback attribute clusterRevision default = 2;
  }

  server cluster AdministratorCommissioning {
    callback attribute windowStatus;
    callback attribute adminFabricIndex;
    callback attribute adminVendorId;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute eventList;
    callback attribute attributeList;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 1;

    handle command OpenCommissioningWindow;
    handle command OpenBasicCommissioningWindow;
    handle command RevokeCommissioning;
  }

  server cluster OperationalCredentials {
    callback attribute NOCs;
    callback attribute fabrics;
    callback attribute supportedFabrics;
    callback attribute commissionedFabrics;
    callback attribute trustedRootCertificates;
    callback attribute currentFabricIndex;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute eventList;
    callback attribute attributeList;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 1;

    handle command AttestationRequest;
    handle command AttestationResponse;
    handle command CertificateChainRequest;
    handle command CertificateChainResponse;
    handle command CSRRequest;
    handle command CSRResponse;
    handle command AddNOC;
    handle command UpdateNOC;
    handle command NOCResponse;
    handle command UpdateFabricLabel;
    handle command RemoveFabric;
    handle command AddTrustedRootCertificate;
  }

  server cluster GroupKeyManagement {
    callback attribute groupKeyMap;
    callback attribute groupTable;
    callback attribute maxGroupsPerFabric;
    callback attribute maxGroupKeysPerFabric;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute eventList;
    callback attribute attributeList;
    callback attribute featureMap;
    callback attribute clusterRevision;

    handle command KeySetWrite;
    handle command KeySetRead;
    handle command KeySetReadResponse;
    handle command KeySetRemove;
    handle command KeySetReadAllIndices;
    handle command KeySetReadAllIndicesResponse;
  }

  server cluster LaundryWasherControls {
    callback attribute spinSpeeds;
    callback attribute spinSpeedCurrent default = 0;
    callback attribute numberOfRinses default = 0;
    callback attribute supportedRinses;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute eventList;
    callback attribute attributeList;
    callback attribute featureMap default = 0;
    callback attribute clusterRevision default = 1;
  }

  server cluster TemperatureControl {
    callback attribute temperatureSetpoint default = 0;
    callback attribute minTemperature default = 0;
    callback attribute maxTemperature default = 0;
    callback attribute step default = 0;
    callback attribute selectedTemperatureLevel default = 0;
    callback attribute supportedTemperatureLevels;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute eventList;
    callback attribute attributeList;
    callback attribute featureMap default = 0;
    callback attribute clusterRevision default = 1;

    handle command SetTemperature;
  }

  server cluster RefrigeratorAlarm {
    emits event Notify;
    callback attribute mask default = 0;
    callback attribute state default = 0;
    callback attribute supported default = 0;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute eventList;
    callback attribute attributeList;
    callback attribute featureMap default = 0;
    callback attribute clusterRevision default = 1;
  }

  server cluster AirQuality {
    callback attribute airQuality;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute eventList;
    callback attribute attributeList;
    callback attribute featureMap;
    callback attribute clusterRevision default = 1;
  }

  server cluster SmokeCoAlarm {
    emits event SmokeAlarm;
    emits event COAlarm;
    emits event LowBattery;
    emits event HardwareFault;
    emits event EndOfService;
    emits event SelfTestComplete;
    emits event AlarmMuted;
    emits event MuteEnded;
    emits event InterconnectSmokeAlarm;
    emits event InterconnectCOAlarm;
    emits event AllClear;
    ram      attribute expressedState;
    ram      attribute smokeState;
    ram      attribute COState;
    ram      attribute batteryAlert;
    ram      attribute deviceMuted;
    ram      attribute testInProgress;
    ram      attribute hardwareFaultAlert;
    ram      attribute endOfServiceAlert;
    ram      attribute interconnectSmokeAlarm;
    ram      attribute interconnectCOAlarm;
    ram      attribute contaminationState;
    ram      attribute smokeSensitivityLevel;
    ram      attribute expiryDate;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute eventList;
    callback attribute attributeList;
    ram      attribute featureMap default = 1;
    ram      attribute clusterRevision default = 1;
  }

  server cluster DishwasherAlarm {
    emits event Notify;
    callback attribute mask default = 0;
    callback attribute latch default = 0;
    callback attribute state default = 0;
    callback attribute supported default = 0;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute eventList;
    callback attribute attributeList;
    callback attribute featureMap default = 0;
    callback attribute clusterRevision default = 1;

    handle command Reset;
    handle command ModifyEnabledAlarms;
  }

  server cluster ScenesManagement {
    callback attribute lastConfiguredBy;
    callback attribute sceneTableSize default = 0x10;
    callback attribute fabricSceneInfo;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute eventList;
    callback attribute attributeList;
    callback attribute featureMap default = 0;
    callback attribute clusterRevision default = 5;

    handle command AddScene;
    handle command AddSceneResponse;
    handle command ViewScene;
    handle command ViewSceneResponse;
    handle command RemoveScene;
    handle command RemoveSceneResponse;
    handle command RemoveAllScenes;
    handle command RemoveAllScenesResponse;
    handle command StoreScene;
    handle command StoreSceneResponse;
    handle command RecallScene;
    handle command GetSceneMembership;
    handle command GetSceneMembershipResponse;
  }

  server cluster HepaFilterMonitoring {
    callback attribute condition;
    callback attribute degradationDirection;
    callback attribute changeIndication;
    callback attribute inPlaceIndicator;
    callback attribute lastChangedTime;
    callback attribute replacementProductList;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute eventList;
    callback attribute attributeList;
    callback attribute featureMap;
    callback attribute clusterRevision default = 1;

    handle command ResetCondition;
  }

  server cluster ActivatedCarbonFilterMonitoring {
    callback attribute condition;
    callback attribute degradationDirection;
    callback attribute changeIndication;
    callback attribute inPlaceIndicator;
    callback attribute lastChangedTime;
    callback attribute replacementProductList;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute eventList;
    callback attribute attributeList;
    callback attribute featureMap;
    callback attribute clusterRevision default = 1;

    handle command ResetCondition;
  }

  server cluster DoorLock {
    emits event DoorLockAlarm;
    emits event LockOperation;
    emits event LockOperationError;
    emits event LockUserChange;
    callback attribute lockState default = 0;
    callback attribute lockType default = 0;
    callback attribute actuatorEnabled default = 0;
    callback attribute doorState default = 0;
    callback attribute doorOpenEvents default = 0;
    callback attribute doorClosedEvents default = 0;
    callback attribute openPeriod default = 0;
    callback attribute numberOfTotalUsersSupported default = 0;
    callback attribute numberOfPINUsersSupported default = 0;
    callback attribute numberOfRFIDUsersSupported default = 0;
    callback attribute numberOfWeekDaySchedulesSupportedPerUser default = 0;
    callback attribute numberOfYearDaySchedulesSupportedPerUser default = 0;
    callback attribute numberOfHolidaySchedulesSupported default = 0;
    callback attribute maxPINCodeLength default = 0;
    callback attribute minPINCodeLength default = 4;
    callback attribute maxRFIDCodeLength default = 4;
    callback attribute minRFIDCodeLength default = 0;
    callback attribute credentialRulesSupport default = 1;
    callback attribute numberOfCredentialsSupportedPerUser default = 0;
    callback attribute language;
    callback attribute LEDSettings default = 0;
    callback attribute autoRelockTime default = 0;
    callback attribute soundVolume default = 0;
    callback attribute operatingMode default = 0;
    callback attribute supportedOperatingModes default = 0xFFF6;
    callback attribute defaultConfigurationRegister default = 0;
    callback attribute enableLocalProgramming default = 1;
    callback attribute enableOneTouchLocking default = 0;
    callback attribute enableInsideStatusLED default = 0;
    callback attribute enablePrivacyModeButton default = 0;
    callback attribute localProgrammingFeatures default = 0;
    callback attribute wrongCodeEntryLimit default = 1;
    callback attribute userCodeTemporaryDisableTime default = 1;
    callback attribute sendPINOverTheAir default = 0;
    callback attribute requirePINforRemoteOperation default = 0;
    callback attribute expiringUserTimeout default = 1;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute eventList;
    callback attribute attributeList;
    callback attribute featureMap default = 0x0001;
    callback attribute clusterRevision default = 7;

    handle command LockDoor;
    handle command UnlockDoor;
    handle command UnlockWithTimeout;
    handle command SetWeekDaySchedule;
    handle command GetWeekDaySchedule;
    handle command GetWeekDayScheduleResponse;
    handle command ClearWeekDaySchedule;
    handle command SetYearDaySchedule;
    handle command GetYearDaySchedule;
    handle command GetYearDayScheduleResponse;
    handle command ClearYearDaySchedule;
    handle command SetHolidaySchedule;
  }

  server cluster WindowCovering {
    callback attribute type default = 0x00;
    callback attribute physicalClosedLimitLift default = 0x0000;
    callback attribute physicalClosedLimitTilt default = 0x0000;
    callback attribute currentPositionLift default = 1;
    callback attribute currentPositionTilt default = 1;
    callback attribute numberOfActuationsLift default = 0x0000;
    callback attribute numberOfActuationsTilt default = 0x0000;
    callback attribute configStatus default = 0x03;
    callback attribute currentPositionLiftPercentage default = 0;
    callback attribute currentPositionTiltPercentage default = 0;
    callback attribute operationalStatus default = 0x00;
    callback attribute targetPositionLiftPercent100ths default = 100;
    callback attribute targetPositionTiltPercent100ths default = 100;
    callback attribute endProductType default = 0x00;
    callback attribute currentPositionLiftPercent100ths default = 0;
    callback attribute currentPositionTiltPercent100ths default = 0;
    callback attribute installedOpenLimitLift default = 0x0000;
    callback attribute installedClosedLimitLift default = 0xFFFF;
    callback attribute installedOpenLimitTilt default = 0x0000;
    callback attribute installedClosedLimitTilt default = 0xFFFF;
    callback attribute mode default = 0x00;
    callback attribute safetyStatus default = 0x0000;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute eventList;
    callback attribute attributeList;
    callback attribute featureMap default = 0;
    callback attribute clusterRevision default = 5;

    handle command UpOrOpen;
    handle command DownOrClose;
    handle command StopMotion;
    handle command GoToLiftValue;
    handle command GoToLiftPercentage;
    handle command GoToTiltValue;
    handle command GoToTiltPercentage;
  }

  server cluster PumpConfigurationAndControl {
    emits event SupplyVoltageLow;
    emits event SupplyVoltageHigh;
    emits event PowerMissingPhase;
    emits event SystemPressureLow;
    emits event SystemPressureHigh;
    emits event DryRunning;
    emits event MotorTemperatureHigh;
    emits event PumpMotorFatalFailure;
    emits event ElectronicTemperatureHigh;
    emits event PumpBlocked;
    emits event SensorFailure;
    emits event ElectronicNonFatalFailure;
    callback attribute maxPressure;
    callback attribute maxSpeed default = 0;
    callback attribute maxFlow default = 0;
    callback attribute minConstPressure;
    callback attribute maxConstPressure;
    callback attribute minCompPressure;
    callback attribute maxCompPressure;
    callback attribute minConstSpeed;
    callback attribute maxConstSpeed;
    callback attribute minConstFlow;
    callback attribute maxConstFlow;
    callback attribute minConstTemp;
    callback attribute maxConstTemp;
    callback attribute pumpStatus default = 0x0000;
    callback attribute effectiveOperationMode default = 0;
    callback attribute effectiveControlMode default = 0;
    callback attribute capacity;
    callback attribute speed;
    callback attribute lifetimeRunningHours;
    callback attribute power;
    callback attribute lifetimeEnergyConsumed default = 0x00000000;
    callback attribute operationMode default = 0x00;
    callback attribute controlMode default = 0x00;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute eventList;
    callback attribute attributeList;
    callback attribute featureMap default = 0;
    callback attribute clusterRevision default = 3;
  }

  server cluster Thermostat {
    callback attribute localTemperature;
    callback attribute outdoorTemperature;
    callback attribute occupancy default = 0x01;
    callback attribute absMinHeatSetpointLimit default = 0;
    callback attribute absMaxHeatSetpointLimit default = 0;
    callback attribute absMinCoolSetpointLimit default = 0;
    callback attribute absMaxCoolSetpointLimit default = 0;
    callback attribute PICoolingDemand default = 0;
    callback attribute PIHeatingDemand default = 0;
    callback attribute HVACSystemTypeConfiguration default = 0;
    callback attribute controlSequenceOfOperation default = 0x04;
    callback attribute systemMode default = 0x01;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute eventList;
    callback attribute attributeList;
    callback attribute featureMap default = 0;
    callback attribute clusterRevision default = 6;

    handle command SetpointRaiseLower;
    handle command GetWeeklyScheduleResponse;
    handle command SetWeeklySchedule;
    handle command GetWeeklySchedule;
    handle command ClearWeeklySchedule;
  }

  server cluster FanControl {
    callback attribute fanMode default = 0;
    callback attribute fanModeSequence default = 2;
    callback attribute percentSetting default = 0;
    callback attribute percentCurrent default = 0;
    callback attribute speedMax default = 1;
    callback attribute speedSetting default = 0;
    callback attribute speedCurrent default = 0;
    callback attribute rockSupport default = 0x00;
    callback attribute rockSetting default = 0x00;
    callback attribute windSupport default = 0x00;
    callback attribute windSetting default = 0x00;
    callback attribute airflowDirection default = 0;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute eventList;
    callback attribute attributeList;
    callback attribute featureMap default = 0;
    callback attribute clusterRevision default = 4;

    handle command Step;
  }

  server cluster ThermostatUserInterfaceConfiguration {
    callback attribute temperatureDisplayMode default = 0x00;
    callback attribute keypadLockout default = 0x00;
    callback attribute scheduleProgrammingVisibility default = 0;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute eventList;
    callback attribute attributeList;
    callback attribute featureMap default = 0;
    callback attribute clusterRevision default = 2;
  }

  server cluster ColorControl {
    callback attribute currentHue default = 0x00;
    callback attribute currentSaturation default = 0x00;
    callback attribute remainingTime default = 0x0000;
    callback attribute currentX default = 0x616B;
    callback attribute currentY default = 0x607D;
    callback attribute driftCompensation default = 0;
    callback attribute compensationText;
    callback attribute colorTemperatureMireds default = 0x00FA;
    callback attribute colorMode default = 0x01;
    callback attribute options default = 0x00;
    callback attribute numberOfPrimaries;
    callback attribute primary1X default = 0;
    callback attribute primary1Y default = 0;
    callback attribute primary1Intensity;
    callback attribute primary2X default = 0;
    callback attribute primary2Y default = 0;
    callback attribute primary2Intensity;
    callback attribute primary3X default = 0;
    callback attribute primary3Y default = 0;
    callback attribute primary3Intensity;
    callback attribute primary4X default = 0;
    callback attribute primary4Y default = 0;
    callback attribute primary4Intensity;
    callback attribute primary5X default = 0;
    callback attribute primary5Y default = 0;
    callback attribute primary5Intensity;
    callback attribute primary6X default = 0;
    callback attribute primary6Y default = 0;
    callback attribute primary6Intensity default = 0;
    callback attribute whitePointX default = 0;
    callback attribute whitePointY default = 0;
    callback attribute colorPointRX default = 0;
    callback attribute colorPointRY default = 0;
    callback attribute colorPointRIntensity default = 0;
    callback attribute colorPointGX default = 0;
    callback attribute colorPointGY default = 0;
    callback attribute colorPointGIntensity default = 0;
    callback attribute colorPointBX default = 0;
    callback attribute colorPointBY default = 0;
    callback attribute colorPointBIntensity default = 0;
    callback attribute enhancedCurrentHue default = 0x0000;
    callback attribute enhancedColorMode default = 0x01;
    callback attribute colorLoopActive default = 0x00;
    callback attribute colorLoopDirection default = 0x00;
    callback attribute colorLoopTime default = 0x0019;
    callback attribute colorLoopStartEnhancedHue default = 0x2300;
    callback attribute colorLoopStoredEnhancedHue default = 0x0000;
    callback attribute colorCapabilities default = 0x0000;
    callback attribute colorTempPhysicalMinMireds default = 0x0000;
    callback attribute colorTempPhysicalMaxMireds default = 0xFEFF;
    callback attribute coupleColorTempToLevelMinMireds default = 0;
    callback attribute startUpColorTemperatureMireds default = 0;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute eventList;
    callback attribute attributeList;
    callback attribute featureMap default = 0;
    callback attribute clusterRevision default = 6;

    handle command MoveToHue;
    handle command MoveHue;
    handle command StepHue;
    handle command MoveToSaturation;
    handle command MoveSaturation;
    handle command StepSaturation;
    handle command MoveToHueAndSaturation;
    handle command MoveToColor;
    handle command MoveColor;
    handle command StepColor;
    handle command MoveToColorTemperature;
    handle command EnhancedMoveToHue;
  }

  server cluster BallastConfiguration {
    callback attribute physicalMinLevel default = 0x01;
    callback attribute physicalMaxLevel default = 0xFE;
    callback attribute ballastStatus default = 0x00;
    callback attribute minLevel default = 0x01;
    callback attribute maxLevel default = 0xFE;
    callback attribute intrinsicBallastFactor default = 0;
    callback attribute ballastFactorAdjustment default = 0xFF;
    callback attribute lampQuantity default = 0;
    callback attribute lampType;
    callback attribute lampManufacturer;
    callback attribute lampRatedHours default = 0xFFFFFF;
    callback attribute lampBurnHours default = 0x000000;
    callback attribute lampAlarmMode default = 0x00;
    callback attribute lampBurnHoursTripPoint default = 0xFFFFFF;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute eventList;
    callback attribute attributeList;
    callback attribute featureMap default = 0;
    callback attribute clusterRevision default = 4;
  }

  server cluster IlluminanceMeasurement {
    callback attribute measuredValue default = 0x0000;
    callback attribute minMeasuredValue default = 1;
    callback attribute maxMeasuredValue default = 65000;
    callback attribute tolerance default = 0;
    callback attribute lightSensorType default = 0xFF;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute eventList;
    callback attribute attributeList;
    callback attribute featureMap default = 0;
    callback attribute clusterRevision default = 3;
  }

  server cluster TemperatureMeasurement {
    callback attribute measuredValue;
    callback attribute minMeasuredValue;
    callback attribute maxMeasuredValue;
    callback attribute tolerance default = 0;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute eventList;
    callback attribute attributeList;
    callback attribute featureMap default = 0;
    callback attribute clusterRevision default = 1;
  }

  server cluster PressureMeasurement {
    callback attribute measuredValue default = 0;
    callback attribute minMeasuredValue;
    callback attribute maxMeasuredValue;
    callback attribute tolerance default = 0;
    callback attribute scaledValue default = 0;
    callback attribute minScaledValue default = 0;
    callback attribute maxScaledValue default = 0;
    callback attribute scaledTolerance default = 0;
    callback attribute scale default = 0;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute eventList;
    callback attribute attributeList;
    callback attribute featureMap default = 0;
    callback attribute clusterRevision default = 3;
  }

  server cluster FlowMeasurement {
    callback attribute measuredValue;
    callback attribute minMeasuredValue;
    callback attribute maxMeasuredValue;
    callback attribute tolerance default = 0;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute eventList;
    callback attribute attributeList;
    callback attribute featureMap default = 0;
    callback attribute clusterRevision default = 1;
  }

  server cluster RelativeHumidityMeasurement {
    callback attribute measuredValue;
    callback attribute minMeasuredValue;
    callback attribute maxMeasuredValue;
    callback attribute tolerance default = 0;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute eventList;
    callback attribute attributeList;
    callback attribute featureMap default = 0;
    callback attribute clusterRevision default = 3;
  }

  server cluster OccupancySensing {
    callback attribute occupancy default = 0;
    callback attribute occupancySensorType default = 0;
    callback attribute occupancySensorTypeBitmap default = 0;
    callback attribute PIROccupiedToUnoccupiedDelay default = 0x0000;
    callback attribute PIRUnoccupiedToOccupiedDelay default = 0x0000;
    callback attribute PIRUnoccupiedToOccupiedThreshold default = 0x01;
    callback attribute ultrasonicOccupiedToUnoccupiedDelay default = 0x0000;
    callback attribute ultrasonicUnoccupiedToOccupiedDelay default = 0x0000;
    callback attribute ultrasonicUnoccupiedToOccupiedThreshold default = 0x01;
    callback attribute physicalContactOccupiedToUnoccupiedDelay default = 0x0000;
    callback attribute physicalContactUnoccupiedToOccupiedDelay default = 0x0000;
    callback attribute physicalContactUnoccupiedToOccupiedThreshold default = 0x01;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute eventList;
    callback attribute attributeList;
    callback attribute featureMap;
    callback attribute clusterRevision default = 3;
  }

  server cluster CarbonMonoxideConcentrationMeasurement {
    callback attribute measuredValue;
    callback attribute minMeasuredValue;
    callback attribute maxMeasuredValue;
    callback attribute peakMeasuredValue;
    callback attribute peakMeasuredValueWindow;
    callback attribute averageMeasuredValue;
    callback attribute averageMeasuredValueWindow;
    callback attribute uncertainty;
    callback attribute measurementUnit;
    callback attribute measurementMedium;
    callback attribute levelValue;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute eventList;
    callback attribute attributeList;
    callback attribute featureMap;
    callback attribute clusterRevision default = 3;
  }

  server cluster CarbonDioxideConcentrationMeasurement {
    callback attribute measuredValue;
    callback attribute minMeasuredValue;
    callback attribute maxMeasuredValue;
    callback attribute peakMeasuredValue;
    callback attribute peakMeasuredValueWindow;
    callback attribute averageMeasuredValue;
    callback attribute averageMeasuredValueWindow;
    callback attribute uncertainty;
    callback attribute measurementUnit;
    callback attribute measurementMedium;
    callback attribute levelValue;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute eventList;
    callback attribute attributeList;
    callback attribute featureMap;
    callback attribute clusterRevision default = 1;
  }

  server cluster NitrogenDioxideConcentrationMeasurement {
    callback attribute measuredValue;
    callback attribute minMeasuredValue;
    callback attribute maxMeasuredValue;
    callback attribute peakMeasuredValue;
    callback attribute peakMeasuredValueWindow;
    callback attribute averageMeasuredValue;
    callback attribute averageMeasuredValueWindow;
    callback attribute uncertainty;
    callback attribute measurementUnit;
    callback attribute measurementMedium;
    callback attribute levelValue;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute eventList;
    callback attribute attributeList;
    callback attribute featureMap;
    callback attribute clusterRevision default = 3;
  }

  server cluster OzoneConcentrationMeasurement {
    callback attribute measuredValue;
    callback attribute minMeasuredValue;
    callback attribute maxMeasuredValue;
    callback attribute peakMeasuredValue;
    callback attribute peakMeasuredValueWindow;
    callback attribute averageMeasuredValue;
    callback attribute averageMeasuredValueWindow;
    callback attribute uncertainty;
    callback attribute measurementUnit;
    callback attribute measurementMedium;
    callback attribute levelValue;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute eventList;
    callback attribute attributeList;
    callback attribute featureMap;
    callback attribute clusterRevision default = 3;
  }

  server cluster Pm25ConcentrationMeasurement {
    callback attribute measuredValue;
    callback attribute minMeasuredValue;
    callback attribute maxMeasuredValue;
    callback attribute peakMeasuredValue;
    callback attribute peakMeasuredValueWindow;
    callback attribute averageMeasuredValue;
    callback attribute averageMeasuredValueWindow;
    callback attribute uncertainty;
    callback attribute measurementUnit;
    callback attribute measurementMedium;
    callback attribute levelValue;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute eventList;
    callback attribute attributeList;
    callback attribute featureMap;
    callback attribute clusterRevision default = 3;
  }

  server cluster FormaldehydeConcentrationMeasurement {
    callback attribute measuredValue;
    callback attribute minMeasuredValue;
    callback attribute maxMeasuredValue;
    callback attribute peakMeasuredValue;
    callback attribute peakMeasuredValueWindow;
    callback attribute averageMeasuredValue;
    callback attribute averageMeasuredValueWindow;
    callback attribute uncertainty;
    callback attribute measurementUnit;
    callback attribute measurementMedium;
    callback attribute levelValue;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute eventList;
    callback attribute attributeList;
    callback attribute featureMap;
    callback attribute clusterRevision default = 3;
  }

  server cluster Pm1ConcentrationMeasurement {
    callback attribute measuredValue;
    callback attribute minMeasuredValue;
    callback attribute maxMeasuredValue;
    callback attribute peakMeasuredValue;
    callback attribute peakMeasuredValueWindow;
    callback attribute averageMeasuredValue;
    callback attribute averageMeasuredValueWindow;
    callback attribute uncertainty;
    callback attribute measurementUnit;
    callback attribute measurementMedium;
    callback attribute levelValue;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute eventList;
    callback attribute attributeList;
    callback attribute featureMap;
    callback attribute clusterRevision default = 3;
  }

  server cluster Pm10ConcentrationMeasurement {
    callback attribute measuredValue;
    callback attribute minMeasuredValue;
    callback attribute maxMeasuredValue;
    callback attribute peakMeasuredValue;
    callback attribute peakMeasuredValueWindow;
    callback attribute averageMeasuredValue;
    callback attribute averageMeasuredValueWindow;
    callback attribute uncertainty;
    callback attribute measurementUnit;
    callback attribute measurementMedium;
    callback attribute levelValue;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute eventList;
    callback attribute attributeList;
    callback attribute featureMap;
    callback attribute clusterRevision default = 3;
  }

  server cluster TotalVolatileOrganicCompoundsConcentrationMeasurement {
    callback attribute measuredValue;
    callback attribute minMeasuredValue;
    callback attribute maxMeasuredValue;
    callback attribute peakMeasuredValue;
    callback attribute peakMeasuredValueWindow;
    callback attribute averageMeasuredValue;
    callback attribute averageMeasuredValueWindow;
    callback attribute uncertainty;
    callback attribute measurementUnit;
    callback attribute measurementMedium;
    callback attribute levelValue;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute eventList;
    callback attribute attributeList;
    callback attribute featureMap;
    callback attribute clusterRevision default = 3;
  }

  server cluster RadonConcentrationMeasurement {
    callback attribute measuredValue;
    callback attribute minMeasuredValue;
    callback attribute maxMeasuredValue;
    callback attribute peakMeasuredValue;
    callback attribute peakMeasuredValueWindow;
    callback attribute averageMeasuredValue;
    callback attribute averageMeasuredValueWindow;
    callback attribute uncertainty;
    callback attribute measurementUnit;
    callback attribute measurementMedium;
    callback attribute levelValue;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute eventList;
    callback attribute attributeList;
    callback attribute featureMap;
    callback attribute clusterRevision default = 3;
  }
}


