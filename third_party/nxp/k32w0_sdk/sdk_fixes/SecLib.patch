--- a/SecLib.c
+++ b/SecLib.c
@@ -114,13 +114,24 @@
 
 /* Need to lockout access to the AES HW accelerator in multitask environments */ 
 #if USE_RTOS && (LTC_HW_ACC || MMCAU_HW_ACC || JN_AES_HW_ACC || FSL_FEATURE_SOC_AES_HW) && gSecLibUseMutex_c
-    #define SECLIB_MUTEX_LOCK()   OSA_MutexLock(mSecLibMutexId, osaWaitForever_c)
-    #define SECLIB_MUTEX_UNLOCK() OSA_MutexUnlock(mSecLibMutexId)
+    #define SECLIB_AES_MUTEX_LOCK()   OSA_MutexLock(mSecLibAesMutexId, osaWaitForever_c)
+    #define SECLIB_AES_MUTEX_UNLOCK() OSA_MutexUnlock(mSecLibAesMutexId)
 #else
-    #define SECLIB_MUTEX_LOCK()
-    #define SECLIB_MUTEX_UNLOCK()
+    #define SECLIB_AES_MUTEX_LOCK()
+    #define SECLIB_AES_MUTEX_UNLOCK()
 #endif /* USE_RTOS */
 
+#if !defined(SECLIB_SHA256_ALT)
+/* Need to lockout access to the SHA HW accelerator in multitask environments */ 
+#if USE_RTOS && JN_SHA_HW_ACC && gSecLibUseMutex_c
+    #define SECLIB_SHA_MUTEX_LOCK()   OSA_MutexLock(mSecLibShaMutexId, osaWaitForever_c)
+    #define SECLIB_SHA_MUTEX_UNLOCK() OSA_MutexUnlock(mSecLibShaMutexId)
+#else
+    #define SECLIB_SHA_MUTEX_LOCK(...)
+    #define SECLIB_SHA_MUTEX_UNLOCK()
+#endif /* USE_RTOS */
+#endif
+
 #if (JN_AES_HW_ACC)
 #define Lo8(x) ((uint8_t) ((x) & 0xFF))
 
@@ -163,16 +174,18 @@ mmcauAesContext_t mmcauAesCtx;
 
 #if USE_RTOS && (JN_AES_HW_ACC || LTC_HW_ACC || MMCAU_HW_ACC || FSL_FEATURE_SOC_AES_HW)
 /*! Mutex used to protect the AES Context when an RTOS is used. */
-osaMutexId_t mSecLibMutexId = NULL;
+osaMutexId_t mSecLibAesMutexId = NULL;
+#endif /* USE_RTOS */
+
+#if USE_RTOS && (JN_SHA_HW_ACC)
+/*! Mutex used to protect the SHA Context when an RTOS is used. */
+osaMutexId_t mSecLibShaMutexId = NULL;
 #endif /* USE_RTOS */
 
 #if JN_SHA_HW_ACC
 typedef struct sha1Context_tag{
     uint32_t sha_working_area[SHA_CTX_SIZE];
 }sha1Context_t;
-typedef struct sha256Context_tag{
-    uint32_t sha_working_area[SHA_CTX_SIZE];
-}sha256Context_t;
 #else
 typedef struct sha1Context_tag{
     uint32_t hash[SHA1_HASH_SIZE/sizeof(uint32_t)];
@@ -180,6 +193,14 @@ typedef struct sha1Context_tag{
     uint32_t totalBytes;
     uint8_t  bytes;
 }sha1Context_t;
+#endif
+
+#if !defined(SECLIB_SHA256_ALT)
+#if JN_SHA_HW_ACC
+typedef struct sha256Context_tag{
+    uint32_t sha_working_area[SHA_CTX_SIZE];
+}sha256Context_t;
+#else
 typedef struct sha256Context_tag{
     uint32_t hash[SHA256_HASH_SIZE/sizeof(uint32_t)];
     uint8_t  buffer[SHA256_BLOCK_SIZE];
@@ -187,8 +208,7 @@ typedef struct sha256Context_tag{
     uint8_t  bytes;
 }sha256Context_t;
 #endif
-
-
+#endif
 
 typedef struct HMAC_SHA256_context_tag{
     sha256Context_t shaCtx;
@@ -363,10 +383,25 @@ void SecLib_Init(void)
     /*! Initialize the MMCAU AES Context Buffer Mutex here. */
     /* Do not allocate heap memory again after getting out of low power
        and reinitializing SecLib if RAM retention is on*/
-    if (mSecLibMutexId == NULL)
+    if (mSecLibAesMutexId == NULL)
+    {
+        mSecLibAesMutexId = OSA_MutexCreate();
+        if (mSecLibAesMutexId == NULL)
+        {
+            panic( ID_PANIC(0,0), (uint32_t)SecLib_Init, 0, 0 );
+            return;
+        }
+    }
+#endif
+
+#if USE_RTOS && (JN_SHA_HW_ACC)
+    /*! Initialize the MMCAU SHA Context Buffer Mutex here. */
+    /* Do not allocate heap memory again after getting out of low power
+       and reinitializing SecLib if RAM retention is on*/
+    if (mSecLibShaMutexId == NULL)
     {
-        mSecLibMutexId = OSA_MutexCreate();
-        if (mSecLibMutexId == NULL)
+        mSecLibShaMutexId = OSA_MutexCreate();
+        if (mSecLibShaMutexId == NULL)
         {
             panic( ID_PANIC(0,0), (uint32_t)SecLib_Init, 0, 0 );
             return;
@@ -399,17 +434,18 @@ bool_t  SecLib_AES_Is_HW_Accelerator_disabled(void)
 }
 #endif
 
+#if !defined(SECLIB_AES_ECB_ALT)
 static void hw_aes_encrypt(const uint8_t *pInput, const size_t inputLen, const uint8_t *pKey, uint8_t * pOutput)
 {
     SecLib_DisallowToSleep();
-    SECLIB_MUTEX_LOCK();
+    SECLIB_AES_MUTEX_LOCK();
     /* If key is already set in may be omitted and parameter is left NULL */
     if (pKey != NULL)
     {
         AES_SetKey(AES0, pKey, 128/8);
     }
     AES_EncryptEcb(AES0, pInput, pOutput, inputLen);
-    SECLIB_MUTEX_UNLOCK();
+    SECLIB_AES_MUTEX_UNLOCK();
     SecLib_AllowToSleep();
 }
 
@@ -417,14 +453,14 @@ static void hw_aes_encrypt(const uint8_t *pInput, const size_t inputLen, const u
 static void hw_aes_decrypt(const uint8_t *pInput, const size_t inputLen, const uint8_t *pKey, uint8_t * pOutput)
 {
     SecLib_DisallowToSleep();
-    SECLIB_MUTEX_LOCK();
+    SECLIB_AES_MUTEX_LOCK();
     /* If key is already set in may be omitted and parameter is left NULL */
     if (pKey != NULL)
     {
         AES_SetKey(AES0, pKey, 128/8);
     }
     AES_DecryptEcb(AES0, pInput, pOutput, inputLen);
-    SECLIB_MUTEX_UNLOCK();
+    SECLIB_AES_MUTEX_UNLOCK();
     SecLib_AllowToSleep();
 }
 
@@ -482,7 +518,7 @@ void AES_128_Encrypt(const uint8_t* pInput,
 
 #if !JN_AES_HW_ACC
     SecLib_DisallowToSleep();
-    SECLIB_MUTEX_LOCK();
+    SECLIB_AES_MUTEX_LOCK();
 #endif
 
 #if MMCAU_HW_ACC
@@ -553,7 +589,7 @@ void AES_128_Encrypt(const uint8_t* pInput,
 #endif
 
  #if !JN_AES_HW_ACC    
-    SECLIB_MUTEX_UNLOCK();
+    SECLIB_AES_MUTEX_UNLOCK();
     SecLib_AllowToSleep();
 #endif
 }
@@ -579,7 +615,7 @@ void AES_128_Decrypt(const uint8_t* pInput,
 {
 #if !JN_AES_HW_ACC
     SecLib_DisallowToSleep();
-    SECLIB_MUTEX_LOCK();
+    SECLIB_AES_MUTEX_LOCK();
 #endif
 
 #if MMCAU_HW_ACC
@@ -649,7 +685,7 @@ void AES_128_Decrypt(const uint8_t* pInput,
     sw_Aes128(pInput, pKey, 0, pOutput);
 #endif
 #if !JN_AES_HW_ACC
-    SECLIB_MUTEX_UNLOCK();
+    SECLIB_AES_MUTEX_UNLOCK();
     SecLib_AllowToSleep();
 #endif
 }
@@ -744,6 +780,8 @@ void AES_128_ECB_Encrypt(const uint8_t* pInput,
     sw_aes_encrypt(pInput, inputLen, pKey, pOutput);
 #endif
 }
+#endif /* SECLIB_AES_ECB_ALT */
+
 /*! *********************************************************************************
 * \brief  This function performs AES-128-ECB encryption on a message block.
 *
@@ -832,10 +870,10 @@ static void hw_aes_cbc_encrypt(const uint8_t* pInput,
                               uint8_t* pOutput)
 {
     SecLib_DisallowToSleep();
-    SECLIB_MUTEX_LOCK();
+    SECLIB_AES_MUTEX_LOCK();
     AES_SetKey(AES0, pKey, 128/8);
     AES_EncryptCbc(AES0, pInput, pOutput, inputLen, pInitVector);
-    SECLIB_MUTEX_UNLOCK();
+    SECLIB_AES_MUTEX_UNLOCK();
     SecLib_AllowToSleep();
 }
 
@@ -886,9 +924,9 @@ void AES_128_CBC_Encrypt(const uint8_t* pInput,
 {
 #if LTC_HW_ACC
     SecLib_DisallowToSleep();
-    SECLIB_MUTEX_LOCK();
+    SECLIB_AES_MUTEX_LOCK();
     LTC_AES_EncryptCbc(LTC0, pInput, pOutput, inputLen, pInitVector, pKey, AES_BLOCK_SIZE);
-    SECLIB_MUTEX_UNLOCK();
+    SECLIB_AES_MUTEX_UNLOCK();
     SecLib_AllowToSleep();
 
 #elif JN_AES_HW_ACC
@@ -946,9 +984,9 @@ uint32_t AES_128_CBC_Encrypt_And_Pad(uint8_t* pInput,
     /* CBC-Encrypt */
 #if LTC_HW_ACC
     SecLib_DisallowToSleep();
-    SECLIB_MUTEX_LOCK();
+    SECLIB_AES_MUTEX_LOCK();
     LTC_AES_EncryptCbc(LTC0, pInput, pOutput, newLen, pInitVector, pKey, AES_BLOCK_SIZE);
-    SECLIB_MUTEX_UNLOCK();
+    SECLIB_AES_MUTEX_UNLOCK();
     SecLib_AllowToSleep();
 #elif JN_AES_HW_ACC
     k32w0_aes_cbc_encrypt(pInput, newLen, pInitVector, pKey, pOutput);
@@ -1000,10 +1038,10 @@ static void hw_aes_cbc_decrypt(const uint8_t* pInput,
                         uint8_t* pOutput)
 {
     SecLib_DisallowToSleep();
-    SECLIB_MUTEX_LOCK();
+    SECLIB_AES_MUTEX_LOCK();
     AES_SetKey(AES0, pKey, 128/8);
     AES_DecryptCbc(AES0, pInput, pOutput, inputLen, pInitVector);
-    SECLIB_MUTEX_UNLOCK();
+    SECLIB_AES_MUTEX_UNLOCK();
     SecLib_AllowToSleep();
 }
 
@@ -1058,9 +1096,9 @@ uint32_t AES_128_CBC_Decrypt_And_Depad(const uint8_t* pInput,
     }
 #if LTC_HW_ACC
     SecLib_DisallowToSleep();
-    SECLIB_MUTEX_LOCK();
+    SECLIB_AES_MUTEX_LOCK();
     LTC_AES_DecryptCbc(LTC0, pInput, pOutput, inputLen, pInitVector, pKey, AES_BLOCK_SIZE, kLTC_DecryptKey);
-    SECLIB_MUTEX_UNLOCK();
+    SECLIB_AES_MUTEX_UNLOCK();
     SecLib_AllowToSleep();
 
 #elif JN_AES_HW_ACC
@@ -1112,10 +1150,10 @@ static void hw_aes_ctr_crypt(const uint8_t* pInput,
                      uint8_t* pOutput)
 {
     SecLib_DisallowToSleep();
-    SECLIB_MUTEX_LOCK();
+    SECLIB_AES_MUTEX_LOCK();
     AES_SetKey(AES0, pKey, 128/8);
     AES_CryptCtr(AES0, pInput, pOutput, inputLen, pCounter, NULL, NULL);
-    SECLIB_MUTEX_UNLOCK();
+    SECLIB_AES_MUTEX_UNLOCK();
     SecLib_AllowToSleep();
 }
 
@@ -1178,9 +1216,9 @@ void AES_128_CTR(const uint8_t* pInput,
 
 #elif LTC_HW_ACC
     SecLib_DisallowToSleep();
-    SECLIB_MUTEX_LOCK();
+    SECLIB_AES_MUTEX_LOCK();
     LTC_AES_EncryptCtr(LTC0, pInput, pOutput, inputLen, pCounter, pKey, AES_BLOCK_SIZE, NULL, NULL);
-    SECLIB_MUTEX_UNLOCK();
+    SECLIB_AES_MUTEX_UNLOCK();
     SecLib_AllowToSleep();
 
 #elif JN_AES_HW_ACC
@@ -1671,7 +1709,7 @@ uint8_t AES_128_CCM(uint8_t* pInput,
     uint8_t status;
 
     SecLib_DisallowToSleep();
-    SECLIB_MUTEX_LOCK();
+    SECLIB_AES_MUTEX_LOCK();
 
 #if LTC_HW_ACC
     if( flags & gSecLib_CCM_Decrypt_c )
@@ -1687,7 +1725,7 @@ uint8_t AES_128_CCM(uint8_t* pInput,
         status = sw_AES128_CCM(pInput, inputLen, pAuthData, authDataLen, pNonce, nonceSize, pKey, pOutput, pCbcMac, macSize, flags);
 #endif
 
-    SECLIB_MUTEX_UNLOCK();
+    SECLIB_AES_MUTEX_UNLOCK();
     SecLib_AllowToSleep();
 
     return status;
@@ -1949,7 +1987,7 @@ void SHA1_Init (void* pContext)
     /* lock SHA HW resource and */
     /* prevent device to go to low power until SHA processing finished */
     SecLib_DisallowToSleep();
-    SECLIB_MUTEX_LOCK();
+    SECLIB_AES_MUTEX_LOCK();
     SHA_ClkInit(SHA0);
     SHA_Init(SHA0, pContext, kSHA_Sha1);
 #else
@@ -2038,7 +2076,7 @@ void SHA1_HashFinish (void* pContext, uint8_t*  pOutput)
     SHA_ClkDeinit(SHA0);
     /* Unlock SHA HW resource and allow device to go to low power */
     SecLib_AllowToSleep();
-    SECLIB_MUTEX_UNLOCK();
+    SECLIB_AES_MUTEX_UNLOCK();
 #else
     uint32_t i;
     uint32_t temp;
@@ -2136,7 +2174,7 @@ void SHA256_CloneCtx (void* pDestCtx, void* pSourceCtx)
    FLib_MemCpy(pDestCtx, pSourceCtx, sizeof(sha256Context_t));
 }
 
-
+#if !defined(SECLIB_SHA256_ALT)
 /*! *********************************************************************************
 * \brief  This function initializes the SHA256 context data
 *
@@ -2150,7 +2188,7 @@ void SHA256_Init (void* pContext)
     /* lock SHA HW resource and */
     /* prevent device to go to low power until SHA processing finished */
     SecLib_DisallowToSleep();
-    SECLIB_MUTEX_LOCK();
+    SECLIB_SHA_MUTEX_LOCK();
     SHA_ClkInit(SHA0);
     SHA_Init(SHA0, pContext, kSHA_Sha256);
 #else  
@@ -2238,7 +2276,7 @@ void SHA256_HashFinish (void* pContext, uint8_t* pOutput)
     SHA_ClkDeinit(SHA0);
     /* Unlock SHA HW resource and allow device to go to low power */
     SecLib_AllowToSleep();
-    SECLIB_MUTEX_UNLOCK();
+    SECLIB_SHA_MUTEX_UNLOCK();
 #else
     uint32_t i;
     uint32_t temp;
@@ -2274,7 +2312,7 @@ void SHA256_HashFinish (void* pContext, uint8_t* pOutput)
     FLib_MemCpy(pOutput, (uint8_t*)(context->hash), SHA256_HASH_SIZE);
 #endif
 }
-
+#endif /* SECLIB_SHA256_ALT */
 
 /*! *********************************************************************************
 * \brief  This function performs all SHA256 steps on multiple bytes: initialize, 

--- a/SecLib.h
+++ b/SecLib.h
@@ -21,6 +21,15 @@
 ********************************************************************************** */
 #include "EmbeddedTypes.h"
 
+/* This is inspired by mbedtls ALT. The user should define
+ * its own SecLib_alt.h file where needed (e.g. in Matter 
+ * K32W0 platform code), such that it can be controllable.
+ * The implementation should be added in a separate .c file
+ * that should be included in the SDK build options. */
+#if (SECLIB_MODE_ALT)
+#include "SecLib_alt.h"
+#endif
+
 #ifndef gSecLibUseMutex_c
 #define gSecLibUseMutex_c   TRUE
 #endif

--- /dev/null
+++ b/SecLib_matter.c
@@ -0,0 +1,362 @@
+/*! *********************************************************************************
+* Copyright (c) 2015, Freescale Semiconductor, Inc.
+* Copyright 2016-2022 NXP
+* All rights reserved.
+*
+* \file
+*
+* This is the source file for some ALT functionality of the security module,
+* in Matter context.
+*
+* SPDX-License-Identifier: BSD-3-Clause
+********************************************************************************** */
+
+#include "FunctionLib.h"
+#include "SecLib.h"
+#include "fsl_os_abstraction.h"
+#include "fsl_sha.h"
+
+#if defined(SECLIB_SHA256_ALT)
+#include "fsl_sha.h"
+#endif
+
+#if defined(SECLIB_AES_ECB_ALT)
+#include "fsl_aes.h"
+#endif
+
+#if (cPWR_UsePowerDownMode)
+    #define SecLib_DisallowToSleep() PWR_DisallowDeviceToSleep()
+    #define SecLib_AllowToSleep()    PWR_AllowDeviceToSleep()
+#else
+    #define SecLib_DisallowToSleep()
+    #define SecLib_AllowToSleep()
+#endif
+
+#if defined(SECLIB_SHA256_ALT)
+
+extern osaMutexId_t mSecLibShaMutexId;
+
+/*! Pointer to the context which currently uses hardware SHA.*/
+static void* sHwShaContext = NULL;
+
+/* SHA256 functions - SW emulated*/
+void sw_sha256_initialize_output (uint32_t *sha256_state);
+void sw_sha256_hash_n (const uint8_t *msg_data, int32_t num_blks, uint32_t *sha256_state);
+void sw_sha256_hash   (const uint8_t *msg_data, uint32_t *sha256_state);
+void sw_sha256_update (const uint8_t *msg_data, int32_t num_blks, uint32_t *sha256_state);
+
+static void SHA256_hash_n(const uint8_t* pData, uint32_t nBlk, uint32_t* pHash)
+{
+    if( nBlk )
+    {
+        SecLib_DisallowToSleep();
+        sw_sha256_hash_n(pData, nBlk, pHash);
+        SecLib_AllowToSleep();
+    }
+}
+
+/*! *********************************************************************************
+* \brief  Initialize the SHA256 context data in SW.
+*         Should be declared in SecLib_alt.h
+*
+* \param [in]    pContext    Pointer to the SHA256 context data
+*
+********************************************************************************** */
+void seclib_sw_sha256_init(void* pContext)
+{
+    sha256Context_t* context = (sha256Context_t*)pContext;
+    context->bytes = 0;
+    context->totalBytes = 0;
+    sw_sha256_initialize_output(context->hash);
+}
+
+/*! *********************************************************************************
+* \brief  Perform SW SHA256 on multiple bytes and updates the context data.
+*         Should be declared in SecLib_alt.h
+*
+* \param [in]    pContext    Pointer to the SHA256 context data
+* \param [in]    pData       Pointer to the input data
+* \param [in]    numBytes    Number of bytes to hash
+*
+********************************************************************************** */
+void seclib_sw_sha256_update(void* pContext, const uint8_t* pData, uint32_t numBytes)
+{
+    uint16_t blocks;
+    sha256Context_t* context = (sha256Context_t*)pContext;
+
+    /* update total byte count */
+    context->totalBytes += numBytes;
+    /* Check if we have at least 1 SHA256 block */
+    if( context->bytes + numBytes < SHA256_BLOCK_SIZE )
+    {
+        /* store bytes for later processing */
+        FLib_MemCpy(&context->buffer[context->bytes], pData, numBytes);
+        context->bytes += numBytes;
+    }
+    else
+    {
+        /* Check for bytes leftover from previous update */
+        if( context->bytes )
+        {
+            uint8_t copyBytes = SHA256_BLOCK_SIZE - context->bytes;
+
+            FLib_MemCpy(&context->buffer[context->bytes], pData, copyBytes);
+            SHA256_hash_n(context->buffer, 1, context->hash);
+            pData += copyBytes;
+            numBytes -= copyBytes;
+            context->bytes = 0;
+        }
+        /* Hash 64 bytes blocks */
+        blocks = numBytes/SHA256_BLOCK_SIZE;
+        SHA256_hash_n(pData, blocks, context->hash);
+        numBytes -= blocks*SHA256_BLOCK_SIZE;
+        pData += blocks*SHA256_BLOCK_SIZE;
+        /* Check for remaining bytes */
+        if( numBytes )
+        {
+            context->bytes = numBytes;
+            FLib_MemCpy(context->buffer, pData, numBytes);
+        }
+    }
+}
+
+/*! *********************************************************************************
+* \brief  Finalize the SW SHA256 hash computation and clear the context data.
+*         The final hash value is stored at the provided output location.
+*         Should be declared in SecLib_alt.h
+*
+* \param [in]       pContext    Pointer to the SHA256 context data
+* \param [out]      pOutput     Pointer to the output location
+*
+********************************************************************************** */
+void seclib_sw_sha256_finish(void* pContext, uint8_t* pOutput)
+{
+    uint32_t i;
+    uint32_t temp;
+    uint32_t numBytes;
+    sha256Context_t* context = (sha256Context_t*)pContext;
+
+    /* update remaining bytes */
+    numBytes = context->bytes;
+    /* Add 1 bit (a 0x80 byte) after the message to begin padding */
+    context->buffer[numBytes++] = 0x80;
+    /* Chack for space to fit an 8 byte length field plus the 0x80 */
+    if( context->bytes >= 56 )
+    {
+        /* Fill the rest of the chunk with zeros */
+        FLib_MemSet(&context->buffer[numBytes], 0, SHA256_BLOCK_SIZE - numBytes);
+        SHA256_hash_n(context->buffer, 1, context->hash);
+        numBytes = 0;
+    }
+    /* Fill the rest of the chunk with zeros */
+    FLib_MemSet(&context->buffer[numBytes], 0, SHA256_BLOCK_SIZE - numBytes);
+    /* Append the total length of the message(Big Endian), in bits (bytes << 3) */
+    context->totalBytes <<= 3;
+    FLib_MemCpyReverseOrder(&context->buffer[60], &context->totalBytes, sizeof(uint32_t));
+    SHA256_hash_n(context->buffer, 1, context->hash);
+    /* Convert to Big Endian */
+    for(i=0; i<SHA256_HASH_SIZE/sizeof(uint32_t); i++)
+    {
+        temp = context->hash[i];
+        FLib_MemCpyReverseOrder(&context->hash[i], &temp, sizeof(uint32_t));
+    }
+
+    /* Copy the generated hash to the indicated output location */
+    FLib_MemCpy(pOutput, (uint8_t*)(context->hash), SHA256_HASH_SIZE);
+}
+
+/*! *********************************************************************************
+* \brief  This function initializes the SHA256 context data
+*
+* \param [in]    pContext    Pointer to the SHA256 context data
+*                            Allocated using SHA256_AllocCtx()
+*
+********************************************************************************** */
+void SHA256_Init (void* pContext)
+{
+    /* lock SHA HW resource and */
+    /* prevent device to go to low power until SHA processing finished */
+    SecLib_DisallowToSleep();
+    if (osaStatus_Success == OSA_MutexLock(mSecLibShaMutexId, SECLIB_SHA256_MUTEX_TIMEOUT) && sHwShaContext == NULL)
+    {
+        sHwShaContext = pContext;
+        SHA_ClkInit(SHA0);
+        SHA_Init(SHA0, pContext, kSHA_Sha256);
+    }
+    else
+    {
+        seclib_sw_sha256_init(pContext);
+    }
+}
+
+/*! *********************************************************************************
+* \brief  This function performs SHA256 on multiple bytes and updates the context data
+*
+* \param [in]    pContext    Pointer to the SHA256 context data
+*                            Allocated using SHA256_AllocCtx()
+* \param [in]    pData       Pointer to the input data
+* \param [in]    numBytes    Number of bytes to hash
+*
+********************************************************************************** */
+void SHA256_HashUpdate(void* pContext, const uint8_t* pData, uint32_t numBytes)
+{
+    if (sHwShaContext == pContext)
+    {
+        SHA_Update(SHA0, pContext, pData, numBytes);
+    }
+    else
+    {
+        seclib_sw_sha256_update(pContext, pData, numBytes);
+    }
+}
+
+/*! *********************************************************************************
+* \brief  This function finalizes the SHA256 hash computaion and clears the context data.
+*         The final hash value is stored at the provided output location.
+*
+* \param [in]       pContext    Pointer to the SHA256 context data
+*                               Allocated using SHA256_AllocCtx()
+* \param [out]      pOutput     Pointer to the output location
+*
+********************************************************************************** */
+void SHA256_HashFinish(void* pContext, uint8_t* pOutput)
+{
+    if (sHwShaContext == pContext)
+    {
+        sHwShaContext = NULL;
+        SHA_Finish(SHA0, pContext, pOutput, NULL);
+        SHA_ClkDeinit(SHA0);
+        /* Unlock SHA HW resource and allow device to go to low power */
+        SecLib_AllowToSleep();
+        OSA_MutexUnlock(mSecLibShaMutexId);
+    }
+    else
+    {
+        seclib_sw_sha256_finish(pContext, pOutput);
+    }
+}
+
+#endif /* SECLIB_SHA256_ALT */
+
+#if defined(SECLIB_AES_ECB_ALT)
+
+extern osaMutexId_t mSecLibAesMutexId;
+
+/*! *********************************************************************************
+* \brief  This function performs AES-128 encryption on a 16-byte block.
+*
+* \param[in]  pInput Pointer to the location of the 16-byte plain text block.
+*
+* \param[in]  pKey Pointer to the location of the 128-bit key.
+*             If NULL the key is already programmed.
+*
+* \param[out]  pOutput Pointer to the location to store the 16-byte ciphered output.
+*
+* \pre All Input/Output pointers must refer to a memory address aligned to 4 bytes!
+*
+********************************************************************************** */
+void AES_128_Encrypt(const uint8_t* pInput,
+                     const uint8_t* pKey,
+                     uint8_t* pOutput)
+{
+    static volatile bool_t hasIsrInterrupted = false;
+
+    if (OSA_InIsrContext())
+    {
+        AES_SetKey(AES0, pKey, 128/8);
+        AES_EncryptEcb(AES0, pInput, pOutput, AES_BLOCK_SIZE);
+        hasIsrInterrupted = true;
+    }
+    else
+    {
+        do
+        {
+            SecLib_DisallowToSleep();
+            OSA_MutexLock(mSecLibAesMutexId, osaWaitForever_c);
+            hasIsrInterrupted = false;
+            /* If key is already set in may be omitted and parameter is left NULL */
+            if (pKey != NULL)
+            {
+                AES_SetKey(AES0, pKey, 128/8);
+            }
+            AES_EncryptEcb(AES0, pInput, pOutput, AES_BLOCK_SIZE);
+            OSA_MutexUnlock(mSecLibAesMutexId);
+            SecLib_AllowToSleep();
+        } while (hasIsrInterrupted);
+    }
+}
+
+/*! *********************************************************************************
+* \brief  This function performs AES-128 decryption on a 16-byte block.
+*
+* \param[in]  pInput Pointer to the location of the 16-byte plain text block.
+*
+* \param[in]  pKey Pointer to the location of the 128-bit key.
+*
+* \param[out]  pOutput Pointer to the location to store the 16-byte ciphered output.
+*
+* \pre All Input/Output pointers must refer to a memory address alligned to 4 bytes!
+*
+********************************************************************************** */
+void AES_128_Decrypt(const uint8_t* pInput,
+                     const uint8_t* pKey,
+                     uint8_t* pOutput)
+{
+    static volatile bool_t hasIsrInterrupted = false;
+
+    if (OSA_InIsrContext())
+    {
+        AES_SetKey(AES0, pKey, 128/8);
+        AES_DecryptEcb(AES0, pInput, pOutput, AES_BLOCK_SIZE);
+        hasIsrInterrupted = true;
+    }
+    else
+    {
+        do
+        {
+            SecLib_DisallowToSleep();
+            OSA_MutexLock(mSecLibAesMutexId, osaWaitForever_c);
+            hasIsrInterrupted = false;
+            /* If key is already set in may be omitted and parameter is left NULL */
+            if (pKey != NULL)
+            {
+                AES_SetKey(AES0, pKey, 128/8);
+            }
+            AES_DecryptEcb(AES0, pInput, pOutput, AES_BLOCK_SIZE);
+            OSA_MutexUnlock(mSecLibAesMutexId);
+            SecLib_AllowToSleep();
+        } while (hasIsrInterrupted);
+    }
+}
+
+/*! *********************************************************************************
+* \brief  This function performs AES-128-ECB encryption on a message block.
+*
+* \param[in]  pInput Pointer to the location of the input message.
+*
+* \param[in]  inputLen Input message length in bytes.
+*
+* \param[in]  pKey Pointer to the location of the 128-bit key.
+*
+* \param[out]  pOutput Pointer to the location to store the ciphered output.
+*
+* \pre All Input/Output pointers must refer to a memory address alligned to 4 bytes!
+*
+********************************************************************************** */
+void AES_128_ECB_Encrypt(const uint8_t* pInput,
+                         uint32_t inputLen,
+                         const uint8_t* pKey,
+                         uint8_t* pOutput)
+{
+    SecLib_DisallowToSleep();
+    OSA_MutexLock(mSecLibAesMutexId, osaWaitForever_c);
+    /* If key is already set in may be omitted and parameter is left NULL */
+    if (pKey != NULL)
+    {
+        AES_SetKey(AES0, pKey, 128/8);
+    }
+    AES_EncryptEcb(AES0, pInput, pOutput, inputLen);
+    OSA_MutexUnlock(mSecLibAesMutexId);
+    SecLib_AllowToSleep();
+}
+#endif /* SECLIB_AES_ECB_ALT */
