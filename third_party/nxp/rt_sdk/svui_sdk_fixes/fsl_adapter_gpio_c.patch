--- a/fsl_adapter_gpio.c
+++ b/fsl_adapter_gpio.c
@@ -1,793 +1,293 @@
 /*
- * Copyright 2018 - 2019, 2023 NXP
+ * Copyright 2018-2020 NXP
  * All rights reserved.
  *
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
-#include "fsl_device_registers.h"
-#include "fsl_gpio.h"
-#if !(defined(FSL_FEATURE_PORT_HAS_NO_INTERRUPT) && FSL_FEATURE_PORT_HAS_NO_INTERRUPT) && \
-    defined(FSL_FEATURE_SOC_PORT_COUNT)
-#include "fsl_port.h"
-#endif
-#include "fsl_adapter_gpio.h"
-
-/* Component ID definition, used by tools. */
-#ifndef FSL_COMPONENT_ID
-#define FSL_COMPONENT_ID "component.gpio_adapter"
-#endif
 
-/*******************************************************************************
- * Definitions
- ******************************************************************************/
+#ifndef __HAL_GPIO_H__
+#define __HAL_GPIO_H__
 
-#if defined(__GNUC__)
-#define HAL_GPIO_CLZ(x) __builtin_clz(x)
-#elif defined(__ICCARM__)
-#define HAL_GPIO_CLZ(x) __CLZ(x)
-#elif defined(__CC_ARM) || defined(__ARMCC_VERSION)
-#define HAL_GPIO_CLZ(x) __builtin_clz(x)
-#else
-#error The tool-chain is not supported.
+#include "fsl_common.h"
+#if defined(SDK_OS_FREE_RTOS)
+#include "FreeRTOS.h"
 #endif
-#define HAL_GPIO_BSR(x) (31U - (uint8_t)HAL_GPIO_CLZ(x))
-
-/*! @brief The pin config struct of gpio adapter. */
-
-typedef struct _hal_gpio_pin
-{
-    uint16_t port : 3U;
-    uint16_t reserved : 1U;
-    uint16_t pin : 5U;
-    uint16_t direction : 1U;
-    uint16_t trigger : 3U;
-    uint16_t reserved2 : 3U;
-} hal_gpio_pin_t;
 
-typedef struct _hal_gpio_state
-{
-    struct _hal_gpio_state *next;
-    hal_gpio_callback_t callback;
-    void *callbackParam;
-    hal_gpio_direction_t direction;
-    uint8_t level;
-    uint8_t port;
-    uint8_t pin : 5U;
-    uint8_t trigger : 3U;
-} hal_gpio_state_t;
-
-/*******************************************************************************
- * Prototypes
- ******************************************************************************/
-
-/*******************************************************************************
- * Variables
- ******************************************************************************/
-
-static GPIO_Type *const s_GpioPort[] = GPIO_BASE_PTRS;
-static hal_gpio_state_t *s_GpioHead;
+/*!
+ * @addtogroup GPIO_Adapter
+ * @{
+ */
 
 /*******************************************************************************
- * Code
+ * Public macro
  ******************************************************************************/
+/*! @name Driver version */
+/*! @{ */
+#define FSL_GPIO_ADAPTER_VERSION (MAKE_VERSION(1, 0, 1)) /*!< Version 1.0.1. */
+/*! @} */
 
-static void HAL_GpioInterruptHandle(uint8_t port)
-{
-    hal_gpio_state_t *head = s_GpioHead;
-    uint32_t pinInterruptSetFlag;
-    uint8_t pin;
-
-    while (NULL != head)
-    {
-        if (head->port == port)
-        {
-            break;
-        }
-        head = head->next;
-    }
-
-    if (NULL == head)
-    {
-        return;
-    }
-
-    head = s_GpioHead;
-
-#if !(defined(FSL_FEATURE_PORT_HAS_NO_INTERRUPT) && FSL_FEATURE_PORT_HAS_NO_INTERRUPT) && \
-    defined(FSL_FEATURE_SOC_PORT_COUNT)
-    pinInterruptSetFlag = GPIO_PortGetInterruptFlags(s_GpioPort[port]);
-    /* Clear external interrupt flag. */
-    GPIO_PortClearInterruptFlags(s_GpioPort[port], pinInterruptSetFlag);
-#else
-    pinInterruptSetFlag = GPIO_GpioGetInterruptFlags(s_GpioPort[port]);
-    /* Clear external interrupt flag. */
-    GPIO_GpioClearInterruptFlags(s_GpioPort[port], pinInterruptSetFlag);
-#endif
-    if (0U != pinInterruptSetFlag)
-    {
-        pin = HAL_GPIO_BSR(pinInterruptSetFlag);
-        while (NULL != head)
-        {
-            if ((pin == head->pin) && (port == head->port))
-            {
-                if (NULL != head->callback)
-                {
-                    head->callback(head->callbackParam);
-                }
-                pinInterruptSetFlag &= ~(0x01UL << pin);
-                if (0U == pinInterruptSetFlag)
-                {
-                    break;
-                }
-                pin = HAL_GPIO_BSR(pinInterruptSetFlag);
-            }
-            head = head->next;
-        }
-    }
-}
-
-#if (defined(HAL_GPIO_CONFLICT_CHECK_ENABLE) && (HAL_GPIO_CONFLICT_CHECK_ENABLE > 0U))
-static hal_gpio_status_t HAL_GpioConflictSearch(hal_gpio_state_t *head, uint8_t port, uint8_t pin)
-{
-    while (NULL != head)
-    {
-        if ((head->port == port) && (head->pin == pin))
-        {
-            return kStatus_HAL_GpioPinConflict;
-        }
-        head = head->next;
-    }
-    return kStatus_HAL_GpioSuccess;
-}
-#endif /* HAL_GPIO_CONFLICT_CHECK_ENABLE */
-
-static hal_gpio_status_t HAL_GpioAddItem(hal_gpio_state_t **head, hal_gpio_state_t *node)
-{
-    hal_gpio_state_t *p = *head;
-    hal_gpio_state_t *q = *head;
-    uint32_t regPrimask;
-
-    regPrimask = DisableGlobalIRQ();
-
-    if (NULL == p)
-    {
-        *head = node;
-    }
-    else
-    {
-        while (NULL != p)
-        {
-            if (p == node)
-            {
-                EnableGlobalIRQ(regPrimask);
-                return kStatus_HAL_GpioPinConflict;
-            }
-            q = p;
-            p = p->next;
-        }
-
-        q->next = node;
-    }
-    node->next = NULL;
-    EnableGlobalIRQ(regPrimask);
-    return kStatus_HAL_GpioSuccess;
-}
-
-static hal_gpio_status_t HAL_GpioRemoveItem(hal_gpio_state_t **head, hal_gpio_state_t *node)
-{
-    hal_gpio_state_t *p = *head;
-    hal_gpio_state_t *q = NULL;
-    uint32_t regPrimask;
-
-    regPrimask = DisableGlobalIRQ();
-    while (p != NULL)
-    {
-        if (p == node)
-        {
-            if (NULL == q)
-            {
-                *head = p->next;
-            }
-            else
-            {
-                q->next = p->next;
-            }
-            break;
-        }
-        else
-        {
-            q = p;
-            p = p->next;
-        }
-    }
-    EnableGlobalIRQ(regPrimask);
-    return kStatus_HAL_GpioSuccess;
-}
-
-#if !(defined(FSL_FEATURE_PORT_HAS_NO_INTERRUPT) && FSL_FEATURE_PORT_HAS_NO_INTERRUPT) && \
-    (defined(FSL_FEATURE_SOC_PORT_COUNT))
-
-#if (FSL_FEATURE_SOC_GPIO_COUNT > 0U)
-void PORTA_IRQHandler(void);
-void PORTA_IRQHandler(void)
-{
-    HAL_GpioInterruptHandle(0);
-    SDK_ISR_EXIT_BARRIER;
-}
-#endif
-
-#if (FSL_FEATURE_SOC_GPIO_COUNT > 1U)
-void PORTB_IRQHandler(void);
-void PORTB_IRQHandler(void)
-{
-    HAL_GpioInterruptHandle(1);
-    SDK_ISR_EXIT_BARRIER;
-}
-#endif
-
-#if (FSL_FEATURE_SOC_GPIO_COUNT > 2U)
-void PORTC_IRQHandler(void);
-void PORTC_IRQHandler(void)
-{
-    HAL_GpioInterruptHandle(2);
-    SDK_ISR_EXIT_BARRIER;
-}
+/*! @brief Definition of GPIO conflict check Enable. */
+#ifndef HAL_GPIO_CONFLICT_CHECK_ENABLE
+#define HAL_GPIO_CONFLICT_CHECK_ENABLE (1)
 #endif
 
-#if (FSL_FEATURE_SOC_GPIO_COUNT > 2U)
-void PORTB_PORTC_IRQHandler(void);
-void PORTB_PORTC_IRQHandler(void)
-{
-    HAL_GpioInterruptHandle(1);
-    HAL_GpioInterruptHandle(2);
-    SDK_ISR_EXIT_BARRIER;
-}
-#endif
-
-#if (FSL_FEATURE_SOC_GPIO_COUNT > 4U)
-void PORTB_PORTC_PORTD_PORTE_IRQHandler(void);
-void PORTB_PORTC_PORTD_PORTE_IRQHandler(void)
-{
-    HAL_GpioInterruptHandle(1);
-    HAL_GpioInterruptHandle(2);
-    HAL_GpioInterruptHandle(3);
-    HAL_GpioInterruptHandle(4);
-    SDK_ISR_EXIT_BARRIER;
-}
-#endif
-
-#if (FSL_FEATURE_SOC_GPIO_COUNT > 3U)
-void PORTC_PORTD_IRQHandler(void);
-void PORTC_PORTD_IRQHandler(void)
-{
-    HAL_GpioInterruptHandle(2);
-    HAL_GpioInterruptHandle(3);
-    SDK_ISR_EXIT_BARRIER;
-}
-#endif
-
-#if (FSL_FEATURE_SOC_GPIO_COUNT > 3U)
-void PORTD_IRQHandler(void);
-void PORTD_IRQHandler(void)
-{
-    HAL_GpioInterruptHandle(3);
-    SDK_ISR_EXIT_BARRIER;
-}
-#endif
-
-#if (FSL_FEATURE_SOC_GPIO_COUNT > 4U)
-void PORTE_IRQHandler(void);
-void PORTE_IRQHandler(void)
-{
-    HAL_GpioInterruptHandle(4);
-    SDK_ISR_EXIT_BARRIER;
-}
-#endif
+/*! @brief Definition of GPIO adapter handle size. */
+#define HAL_GPIO_HANDLE_SIZE (16U)
 
-#if (FSL_FEATURE_SOC_GPIO_COUNT > 5U)
-void PORTF_IRQHandler(void);
-void PORTF_IRQHandler(void)
-{
-    HAL_GpioInterruptHandle(5);
-    SDK_ISR_EXIT_BARRIER;
-}
-#endif
+/*!
+ * @brief Defines the gpio handle
+ *
+ * This macro is used to define a 4 byte aligned gpio handle.
+ * Then use "(hal_gpio_handle_t)name" to get the gpio handle.
+ *
+ * The macro should be global and could be optional. You could also define gpio handle by yourself.
+ *
+ * This is an example,
+ * @code
+ * GPIO_HANDLE_DEFINE(gpioHandle);
+ * @endcode
+ *
+ * @param name The name string of the gpio handle.
+ */
+#define GPIO_HANDLE_DEFINE(name) uint32_t name[((HAL_GPIO_HANDLE_SIZE + sizeof(uint32_t) - 1U) / sizeof(uint32_t))]
 
+/*! @brief Definition of GPIO adapter isr priority. */
+#ifndef HAL_GPIO_ISR_PRIORITY
+#if defined(__GIC_PRIO_BITS)
+#define HAL_GPIO_ISR_PRIORITY (25U)
 #else
+#if defined(configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY)
+#define HAL_GPIO_ISR_PRIORITY (configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY)
+#else
+/* The default value 3 is used to support different ARM Core, such as CM0P, CM4, CM7, and CM33, etc.
+ * The minimum number of priority bits implemented in the NVIC is 2 on these SOCs. The value of mininum
+ * priority is 3 (2^2 - 1). So, the default value is 3.
+ */
+#define HAL_GPIO_ISR_PRIORITY (3U)
+#endif /* defined(configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY) */
+#endif /* defined(__GIC_PRIO_BITS) */
+#endif /* HAL_GPIO_ISR_PRIORITY */
 
-#if (FSL_FEATURE_SOC_GPIO_COUNT > 0U)
-void GPIOA_INT0_IRQHandler(void);
-void GPIOA_INT0_IRQHandler(void)
-{
-    HAL_GpioInterruptHandle(0);
-    SDK_ISR_EXIT_BARRIER;
-}
-
-void GPIOA_INT1_IRQHandler(void);
-void GPIOA_INT1_IRQHandler(void)
-{
-    GPIOA_INT0_IRQHandler();
-}
-#endif
-
-#if (FSL_FEATURE_SOC_GPIO_COUNT > 1U)
-void GPIOB_INT0_IRQHandler(void);
-void GPIOB_INT0_IRQHandler(void)
-{
-    HAL_GpioInterruptHandle(1);
-    SDK_ISR_EXIT_BARRIER;
-}
-void GPIOB_INT1_IRQHandler(void);
-void GPIOB_INT1_IRQHandler(void)
-{
-    GPIOB_INT0_IRQHandler();
-}
-#endif
-
-#if (FSL_FEATURE_SOC_GPIO_COUNT > 2U)
-void GPIOC_INT0_IRQHandler(void);
-void GPIOC_INT0_IRQHandler(void)
-{
-    HAL_GpioInterruptHandle(2);
-    SDK_ISR_EXIT_BARRIER;
-}
-void GPIOC_INT1_IRQHandler(void);
-void GPIOC_INT1_IRQHandler(void)
-{
-    GPIOC_INT0_IRQHandler();
-}
-#endif
-
-#if (FSL_FEATURE_SOC_GPIO_COUNT > 3U)
-void GPIOD_INT0_IRQHandler(void);
-void GPIOD_INT0_IRQHandler(void)
-{
-    HAL_GpioInterruptHandle(3);
-    SDK_ISR_EXIT_BARRIER;
-}
-void GPIOD_INT1_IRQHandler(void);
-void GPIOD_INT1_IRQHandler(void)
-{
-    GPIOD_INT0_IRQHandler();
-}
-#endif
-
-#if (FSL_FEATURE_SOC_GPIO_COUNT > 0U)
-void GPIO00_IRQHandler(void);
-void GPIO00_IRQHandler(void)
-{
-    HAL_GpioInterruptHandle(0);
-    SDK_ISR_EXIT_BARRIER;
-}
-
-void GPIO01_IRQHandler(void);
-void GPIO01_IRQHandler(void)
-{
-    GPIO00_IRQHandler();
-}
-#endif
-
-#if (FSL_FEATURE_SOC_GPIO_COUNT > 1U)
-void GPIO10_IRQHandler(void);
-void GPIO10_IRQHandler(void)
-{
-    HAL_GpioInterruptHandle(1);
-    SDK_ISR_EXIT_BARRIER;
-}
-void GPIO11_IRQHandler(void);
-void GPIO11_IRQHandler(void)
-{
-    GPIO10_IRQHandler();
-}
-#endif
-
-#if (FSL_FEATURE_SOC_GPIO_COUNT > 2U)
-void GPIO20_IRQHandler(void);
-void GPIO20_IRQHandler(void)
-{
-    HAL_GpioInterruptHandle(2);
-    SDK_ISR_EXIT_BARRIER;
-}
-void GPIO21_IRQHandler(void);
-void GPIO21_IRQHandler(void)
-{
-    GPIO20_IRQHandler();
-}
-#endif
-
-#if (FSL_FEATURE_SOC_GPIO_COUNT > 3U)
-void GPIO30_IRQHandler(void);
-void GPIO30_IRQHandler(void)
-{
-    HAL_GpioInterruptHandle(3);
-    SDK_ISR_EXIT_BARRIER;
-}
-void GPIO31_IRQHandler(void);
-void GPIO31_IRQHandler(void)
-{
-    GPIO30_IRQHandler();
-}
-#endif
-
-#if (FSL_FEATURE_SOC_GPIO_COUNT > 4U)
-void GPIO40_IRQHandler(void);
-void GPIO40_IRQHandler(void)
-{
-    HAL_GpioInterruptHandle(4);
-    SDK_ISR_EXIT_BARRIER;
-}
-void GPIO41_IRQHandler(void);
-void GPIO41_IRQHandler(void)
-{
-    GPIO40_IRQHandler();
-}
-#endif
-
-#if (FSL_FEATURE_SOC_GPIO_COUNT > 5U)
-void GPIO50_IRQHandler(void);
-void GPIO50_IRQHandler(void)
-{
-    HAL_GpioInterruptHandle(5);
-    SDK_ISR_EXIT_BARRIER;
-}
-void GPIO51_IRQHandler(void);
-void GPIO51_IRQHandler(void)
-{
-    GPIO50_IRQHandler();
-}
-#endif
-
-#if (FSL_FEATURE_SOC_GPIO_COUNT > 6U)
-void GPIO60_IRQHandler(void);
-void GPIO60_IRQHandler(void)
-{
-    HAL_GpioInterruptHandle(6);
-    SDK_ISR_EXIT_BARRIER;
-}
-void GPIO61_IRQHandler(void);
-void GPIO61_IRQHandler(void)
-{
-    GPIO60_IRQHandler();
-}
-#endif
-
-#if (FSL_FEATURE_SOC_GPIO_COUNT > 7U)
-void GPIO70_IRQHandler(void);
-void GPIO70_IRQHandler(void)
-{
-    HAL_GpioInterruptHandle(7);
-    SDK_ISR_EXIT_BARRIER;
-}
-void GPIO71_IRQHandler(void);
-void GPIO71_IRQHandler(void)
-{
-    GPIO70_IRQHandler();
-}
-#endif
-
-#if (FSL_FEATURE_SOC_GPIO_COUNT > 8U)
-void GPIO80_IRQHandler(void);
-void GPIO80_IRQHandler(void)
-{
-    HAL_GpioInterruptHandle(8);
-    SDK_ISR_EXIT_BARRIER;
-}
-void GPIO81_IRQHandler(void);
-void GPIO81_IRQHandler(void)
-{
-    GPIO80_IRQHandler();
-}
-#endif
-
-#if (FSL_FEATURE_SOC_GPIO_COUNT > 9U)
-void GPIO90_IRQHandler(void);
-void GPIO90_IRQHandler(void)
-{
-    HAL_GpioInterruptHandle(9);
-    SDK_ISR_EXIT_BARRIER;
-}
-void GPIO91_IRQHandler(void);
-void GPIO91_IRQHandler(void)
-{
-    GPIO90_IRQHandler();
-}
-#endif
-
-#if (FSL_FEATURE_SOC_GPIO_COUNT > 10U)
-void GPIO100_IRQHandler(void);
-void GPIO100_IRQHandler(void)
-{
-    HAL_GpioInterruptHandle(10);
-    SDK_ISR_EXIT_BARRIER;
-}
-void GPIO101_IRQHandler(void);
-void GPIO101_IRQHandler(void)
-{
-    GPIO100_IRQHandler();
-}
-#endif
-
-#if (FSL_FEATURE_SOC_GPIO_COUNT > 0U)
-void GPIO0_IRQHandler(void);
-void GPIO0_IRQHandler(void)
-{
-    HAL_GpioInterruptHandle(0);
-    SDK_ISR_EXIT_BARRIER;
-}
-#endif
-
-#if (FSL_FEATURE_SOC_GPIO_COUNT > 1U)
-void GPIO1_IRQHandler(void);
-void GPIO1_IRQHandler(void)
-{
-    HAL_GpioInterruptHandle(1);
-    SDK_ISR_EXIT_BARRIER;
-}
-#endif
+/*******************************************************************************
+ * Definitions
+ ******************************************************************************/
+/*! @brief The handle of GPIO adapter. */
+typedef void *hal_gpio_handle_t;
 
-#if (FSL_FEATURE_SOC_GPIO_COUNT > 2U)
-void GPIO2_IRQHandler(void);
-void GPIO2_IRQHandler(void)
-{
-    HAL_GpioInterruptHandle(2);
-    SDK_ISR_EXIT_BARRIER;
-}
-#endif
+/*! @brief The callback function of GPIO adapter. */
+typedef void (*hal_gpio_callback_t)(void *param);
 
-#if (FSL_FEATURE_SOC_GPIO_COUNT > 3U)
-void GPIO3_IRQHandler(void);
-void GPIO3_IRQHandler(void)
+/*! @brief The interrupt trigger of GPIO adapter. */
+typedef enum _hal_gpio_interrupt_trigger
 {
-    HAL_GpioInterruptHandle(3);
-    SDK_ISR_EXIT_BARRIER;
-}
-#endif
+    kHAL_GpioInterruptDisable     = 0x0U, /*!< Interrupt disable. */
+    kHAL_GpioInterruptLogicZero   = 0x1U, /*!< Interrupt when logic zero. */
+    kHAL_GpioInterruptRisingEdge  = 0x2U, /*!< Interrupt on rising edge. */
+    kHAL_GpioInterruptFallingEdge = 0x3U, /*!< Interrupt on falling edge. */
+    kHAL_GpioInterruptEitherEdge  = 0x4U, /*!< Interrupt on either edge. */
+    kHAL_GpioInterruptLogicOne    = 0x5U, /*!< Interrupt when logic one. */
+} hal_gpio_interrupt_trigger_t;
 
-#endif
-
-void HAL_GpioPreInit(void)
+/*! @brief The status of GPIO adapter. */
+typedef enum _hal_gpio_status
 {
-    s_GpioHead = NULL;
-}
+    kStatus_HAL_GpioSuccess     = kStatus_Success,                       /*!< Success */
+    kStatus_HAL_GpioError       = MAKE_STATUS(kStatusGroup_HAL_GPIO, 1), /*!< Failed */
+    kStatus_HAL_GpioLackSource  = MAKE_STATUS(kStatusGroup_HAL_GPIO, 2), /*!< Lack of sources */
+    kStatus_HAL_GpioPinConflict = MAKE_STATUS(kStatusGroup_HAL_GPIO, 3), /*!< PIN conflict */
+} hal_gpio_status_t;
 
-hal_gpio_status_t HAL_GpioInit(hal_gpio_handle_t gpioHandle, hal_gpio_pin_config_t *pinConfig)
+/*! @brief The direction of GPIO adapter. */
+typedef enum _hal_gpio_direction
 {
-    hal_gpio_state_t *gpioState;
-    hal_gpio_status_t status;
+    kHAL_GpioDirectionIn = 0x00U, /*!< Out */
+    kHAL_GpioDirectionOut,        /*!< In */
+} hal_gpio_direction_t;
 
-    assert(gpioHandle);
-    assert(pinConfig);
-    assert(HAL_GPIO_HANDLE_SIZE >= sizeof(hal_gpio_state_t));
-
-    gpioState = (hal_gpio_state_t *)gpioHandle;
-
-#if (defined(HAL_GPIO_CONFLICT_CHECK_ENABLE) && (HAL_GPIO_CONFLICT_CHECK_ENABLE > 0U))
-    if ((NULL != s_GpioHead) &&
-        (kStatus_HAL_GpioSuccess != HAL_GpioConflictSearch(s_GpioHead, pinConfig->port, pinConfig->pin)))
-    {
-        return kStatus_HAL_GpioPinConflict;
-    }
-#endif /* HAL_GPIO_CONFLICT_CHECK_ENABLE */
-
-    status = HAL_GpioAddItem(&s_GpioHead, gpioState);
-    if (kStatus_HAL_GpioSuccess != status)
-    {
-        return status;
-    }
-
-    (void)memcpy((void *)&gpioState->direction, (void *)pinConfig, sizeof(hal_gpio_pin_config_t));
-
-    GPIO_PinInit(s_GpioPort[pinConfig->port], pinConfig->pin, (const gpio_pin_config_t *)(void *)&pinConfig->direction);
-    return kStatus_HAL_GpioSuccess;
-}
-
-hal_gpio_status_t HAL_GpioDeinit(hal_gpio_handle_t gpioHandle)
+/*! @brief The pin config struct of GPIO adapter. */
+typedef struct _hal_gpio_pin_config
 {
-    hal_gpio_state_t *gpioState;
-
-    assert(gpioHandle);
+    hal_gpio_direction_t direction;
+    uint8_t level;
+    uint8_t port;
+    uint8_t pin;
+} hal_gpio_pin_config_t;
 
-    gpioState = (hal_gpio_state_t *)gpioHandle;
-    if (kHAL_GpioDirectionIn == gpioState->direction)
-    {
-        (void)HAL_GpioSetTriggerMode(gpioHandle, kHAL_GpioInterruptDisable);
-    }
-    (void)HAL_GpioRemoveItem(&s_GpioHead, gpioState);
-    return kStatus_HAL_GpioSuccess;
-}
+/*******************************************************************************
+ * API
+ ******************************************************************************/
 
-hal_gpio_status_t HAL_GpioGetInput(hal_gpio_handle_t gpioHandle, uint8_t *pinState)
-{
-    hal_gpio_state_t *gpioState;
+#if defined(__cplusplus)
+extern "C" {
+#endif /* __cplusplus */
 
-    assert(gpioHandle);
-    assert(pinState);
+/*!
+ * @brief Initializes static variable located in .bss section.
+ *
+ * This function is used to initialize variable located in .bss section.
+ * Usually users don't need to call this API.
+ * It's just used in the case GPIO adapter is used before .bss section is automatically cleaned up by IDE.
+ * Example below shows how to use this API.
+ *  @code
+ *   HAL_GpioPreInit();
+ *   GPIO_HANDLE_DEFINE(g_GpioHandle);
+ *   hal_gpio_pin_config_t config;
+ *   config.direction = kHAL_GpioDirectionOut;
+ *   config.port = 0;
+ *   config.pin = 0;
+ *   config.level = 0;
+ *   HAL_GpioInit((hal_gpio_handle_t)g_GpioHandle, &config);
+ *  @endcode
+ */
+void HAL_GpioPreInit(void);
 
-    gpioState = (hal_gpio_state_t *)gpioHandle;
+/*!
+ * @brief Initializes an GPIO instance with the GPIO handle and the user configuration structure.
+ *
+ * This function configures the GPIO module with user-defined settings. The user can configure the configuration
+ * structure. The parameter gpioHandle is a pointer to point to a memory space of size #HAL_GPIO_HANDLE_SIZE allocated
+ * by the caller. Example below shows how to use this API to configure the GPIO.
+ *  @code
+ *   GPIO_HANDLE_DEFINE(g_GpioHandle);
+ *   hal_gpio_pin_config_t config;
+ *   config.direction = kHAL_GpioDirectionOut;
+ *   config.port = 0;
+ *   config.pin = 0;
+ *   config.level = 0;
+ *   HAL_GpioInit((hal_gpio_handle_t)g_GpioHandle, &config);
+ *  @endcode
+ *
+ * @param gpioHandle GPIO handle pointer.
+ * The handle should be 4 byte aligned, because unaligned access doesn't be supported on some devices.
+ * You can define the handle in the following two ways:
+ * #GPIO_HANDLE_DEFINE(gpioHandle);
+ * or
+ * uint32_t gpioHandle[((HAL_GPIO_HANDLE_SIZE + sizeof(uint32_t) - 1U) / sizeof(uint32_t))];
+ * @param pinConfig Pointer to user-defined configuration structure.
+ * @retval kStatus_HAL_GpioError An error occurred while initializing the GPIO.
+ * @retval kStatus_HAL_GpioPinConflict The pair of the pin and port passed by pinConfig is initialized.
+ * @retval kStatus_HAL_GpioSuccess GPIO initialization succeed
+ */
+hal_gpio_status_t HAL_GpioInit(hal_gpio_handle_t gpioHandle, hal_gpio_pin_config_t *pinConfig);
 
-    *pinState = (GPIO_PinRead(s_GpioPort[gpioState->port], gpioState->pin) != 0U) ? 1U : 0U;
-    return kStatus_HAL_GpioSuccess;
-}
+/*!
+ * @brief Deinitializes a GPIO instance.
+ *
+ * This function disables the trigger mode.
+ *
+ * @param gpioHandle GPIO handle pointer.
+ * The handle should be 4 byte aligned, because unaligned access doesn't be supported on some devices.
+ * @retval kStatus_HAL_GpioSuccess GPIO de-initialization succeed
+ */
+hal_gpio_status_t HAL_GpioDeinit(hal_gpio_handle_t gpioHandle);
 
-hal_gpio_status_t HAL_GpioSetOutput(hal_gpio_handle_t gpioHandle, uint8_t pinState)
-{
-    hal_gpio_state_t *gpioState;
+/*!
+ * @brief Gets the pin voltage.
+ *
+ * This function gets the pin voltage. 0 - low level voltage, 1 - high level voltage.
+ *
+ * @param gpioHandle GPIO handle pointer.
+ * The handle should be 4 byte aligned, because unaligned access doesn't be supported on some devices.
+ * @param pinState A pointer to save the pin state.
+ * @retval kStatus_HAL_GpioSuccess Get successfully.
+ */
+hal_gpio_status_t HAL_GpioGetInput(hal_gpio_handle_t gpioHandle, uint8_t *pinState);
 
-    assert(gpioHandle);
+/*!
+ * @brief Sets the pin voltage.
+ *
+ * This function sets the pin voltage. 0 - low level voltage, 1 - high level voltage.
+ *
+ * @param gpioHandle GPIO handle pointer.
+ * The handle should be 4 byte aligned, because unaligned access doesn't be supported on some devices.
+ * @param pinState Pin state.
+ * @retval kStatus_HAL_GpioSuccess Set successfully.
+ */
+hal_gpio_status_t HAL_GpioSetOutput(hal_gpio_handle_t gpioHandle, uint8_t pinState);
 
-    gpioState = (hal_gpio_state_t *)gpioHandle;
+/*!
+ * @brief Gets the pin interrupt trigger mode.
+ *
+ * This function gets the pin interrupt trigger mode. The trigger mode please refer to
+ * #hal_gpio_interrupt_trigger_t.
+ *
+ * @param gpioHandle GPIO handle pointer.
+ * The handle should be 4 byte aligned, because unaligned access doesn't be supported on some devices.
+ * @param gpioTrigger A pointer to save the pin trigger mode value.
+ * @retval kStatus_HAL_GpioSuccess Get successfully.
+ * @retval kStatus_HAL_GpioError The pin is the ouput setting.
+ */
+hal_gpio_status_t HAL_GpioGetTriggerMode(hal_gpio_handle_t gpioHandle, hal_gpio_interrupt_trigger_t *gpioTrigger);
 
-    GPIO_PinWrite(s_GpioPort[gpioState->port], gpioState->pin, (pinState != 0U) ? 1U : 0U);
-    return kStatus_HAL_GpioSuccess;
-}
+/*!
+ * @brief Sets the pin interrupt trigger mode.
+ *
+ * This function sets the pin interrupt trigger mode. The trigger mode please refer to
+ * #hal_gpio_interrupt_trigger_t.
+ *
+ * @param gpioHandle GPIO handle pointer.
+ * The handle should be 4 byte aligned, because unaligned access doesn't be supported on some devices.
+ * @param gpioTrigger The pin trigger mode value.
+ * @retval kStatus_HAL_GpioSuccess Set successfully.
+ * @retval kStatus_HAL_GpioError The pin is the ouput setting.
+ */
+hal_gpio_status_t HAL_GpioSetTriggerMode(hal_gpio_handle_t gpioHandle, hal_gpio_interrupt_trigger_t gpioTrigger);
 
+/*!
+ * @brief Installs a callback and callback parameter.
+ *
+ * This function is used to install the callback and callback parameter for GPIO module.
+ * When the pin state interrupt happened, the driver will notify the upper layer by the installed callback
+ * function. After the callback called, the GPIO pin state can be got by calling function #HAL_GpioGetInput.
+ *
+ * @param gpioHandle GPIO handle pointer.
+ * The handle should be 4 byte aligned, because unaligned access doesn't be supported on some devices.
+ * @param callback The callback function.
+ * @param callbackParam The parameter of the callback function.
+ * @retval kStatus_HAL_GpioSuccess Successfully install the callback.
+ */
 hal_gpio_status_t HAL_GpioInstallCallback(hal_gpio_handle_t gpioHandle,
                                           hal_gpio_callback_t callback,
-                                          void *callbackParam)
-{
-    hal_gpio_state_t *gpioState;
-
-    assert(gpioHandle);
-
-    gpioState = (hal_gpio_state_t *)gpioHandle;
-
-    gpioState->callbackParam = callbackParam;
-    gpioState->callback      = callback;
+                                          void *callbackParam);
 
-    return kStatus_HAL_GpioSuccess;
-}
-
-hal_gpio_status_t HAL_GpioGetTriggerMode(hal_gpio_handle_t gpioHandle, hal_gpio_interrupt_trigger_t *gpioTrigger)
-{
-    hal_gpio_state_t *gpioState;
-
-    assert(gpioHandle);
-
-    gpioState = (hal_gpio_state_t *)gpioHandle;
-
-    if (kHAL_GpioDirectionOut == gpioState->direction)
-    {
-        return kStatus_HAL_GpioError;
-    }
-
-    *gpioTrigger = (hal_gpio_interrupt_trigger_t)gpioState->trigger;
-    return kStatus_HAL_GpioSuccess;
-}
-
-hal_gpio_status_t HAL_GpioSetTriggerMode(hal_gpio_handle_t gpioHandle, hal_gpio_interrupt_trigger_t gpioTrigger)
-{
-    hal_gpio_state_t *gpioState;
-#if !(defined(FSL_FEATURE_PORT_HAS_NO_INTERRUPT) && FSL_FEATURE_PORT_HAS_NO_INTERRUPT) && \
-    defined(FSL_FEATURE_SOC_PORT_COUNT)
-    PORT_Type *portList[]          = PORT_BASE_PTRS;
-    static const IRQn_Type irqNo[] = PORT_IRQS;
-    port_interrupt_t pinInt;
-#else
-    gpio_interrupt_config_t pinInt;
-    static const IRQn_Type irqNo[] = GPIO_IRQS;
-#endif
-
-    assert(gpioHandle);
-
-    gpioState = (hal_gpio_state_t *)gpioHandle;
-    assert(kHAL_GpioDirectionOut != gpioState->direction);
-
-    switch (gpioTrigger)
-    {
-        case kHAL_GpioInterruptLogicZero:
-#if !(defined(FSL_FEATURE_PORT_HAS_NO_INTERRUPT) && FSL_FEATURE_PORT_HAS_NO_INTERRUPT) && \
-    defined(FSL_FEATURE_SOC_PORT_COUNT)
-            pinInt = kPORT_InterruptLogicZero;
-#else
-            pinInt = kGPIO_InterruptLogicZero;
-#endif
-            break;
-        case kHAL_GpioInterruptLogicOne:
-#if !(defined(FSL_FEATURE_PORT_HAS_NO_INTERRUPT) && FSL_FEATURE_PORT_HAS_NO_INTERRUPT) && \
-    defined(FSL_FEATURE_SOC_PORT_COUNT)
-            pinInt = kPORT_InterruptLogicOne;
-#else
-            pinInt = kGPIO_InterruptLogicOne;
-#endif
-            break;
-        case kHAL_GpioInterruptRisingEdge:
-#if !(defined(FSL_FEATURE_PORT_HAS_NO_INTERRUPT) && FSL_FEATURE_PORT_HAS_NO_INTERRUPT) && \
-    defined(FSL_FEATURE_SOC_PORT_COUNT)
-            pinInt = kPORT_InterruptRisingEdge;
-#else
-            pinInt = kGPIO_InterruptRisingEdge;
-#endif
-            break;
-        case kHAL_GpioInterruptFallingEdge:
-#if !(defined(FSL_FEATURE_PORT_HAS_NO_INTERRUPT) && FSL_FEATURE_PORT_HAS_NO_INTERRUPT) && \
-    defined(FSL_FEATURE_SOC_PORT_COUNT)
-            pinInt = kPORT_InterruptFallingEdge;
-#else
-            pinInt = kGPIO_InterruptFallingEdge;
-#endif
-            break;
-        case kHAL_GpioInterruptEitherEdge:
-#if !(defined(FSL_FEATURE_PORT_HAS_NO_INTERRUPT) && FSL_FEATURE_PORT_HAS_NO_INTERRUPT) && \
-    defined(FSL_FEATURE_SOC_PORT_COUNT)
-            pinInt = kPORT_InterruptEitherEdge;
-#else
-            pinInt = kGPIO_InterruptEitherEdge;
-#endif
-            break;
-        default:
-#if !(defined(FSL_FEATURE_PORT_HAS_NO_INTERRUPT) && FSL_FEATURE_PORT_HAS_NO_INTERRUPT) && \
-    defined(FSL_FEATURE_SOC_PORT_COUNT)
-            pinInt = kPORT_InterruptOrDMADisabled;
-#else
-            pinInt = kGPIO_InterruptStatusFlagDisabled;
-#endif
-            break;
-    }
-
-    gpioState->trigger = (uint8_t)gpioTrigger;
-
-    /* initialize port interrupt */
-#if !(defined(FSL_FEATURE_PORT_HAS_NO_INTERRUPT) && FSL_FEATURE_PORT_HAS_NO_INTERRUPT) && \
-    defined(FSL_FEATURE_SOC_PORT_COUNT)
-    PORT_SetPinInterruptConfig(portList[gpioState->port], gpioState->pin, pinInt);
-#else
-    GPIO_SetPinInterruptConfig(s_GpioPort[gpioState->port], gpioState->pin, pinInt);
-#endif
-    NVIC_SetPriority(irqNo[gpioState->port], HAL_GPIO_ISR_PRIORITY);
-    NVIC_EnableIRQ(irqNo[gpioState->port]);
-
-    return kStatus_HAL_GpioSuccess;
-}
-
-hal_gpio_status_t HAL_GpioWakeUpSetting(hal_gpio_handle_t gpioHandle, uint8_t enable)
-{
-    hal_gpio_state_t *gpioState;
-
-    assert(gpioHandle);
-
-    gpioState = (hal_gpio_state_t *)gpioHandle;
-
-    if (kHAL_GpioDirectionOut == gpioState->direction)
-    {
-        return kStatus_HAL_GpioError;
-    }
-    /* The wakeup feature of GPIO cannot be disabled. */
-    if (0U == enable)
-    {
-        return kStatus_HAL_GpioError;
-    }
-    return kStatus_HAL_GpioSuccess;
-}
-
-hal_gpio_status_t HAL_GpioEnterLowpower(hal_gpio_handle_t gpioHandle)
-{
-    assert(gpioHandle);
-
-    return kStatus_HAL_GpioSuccess;
-}
-
-hal_gpio_status_t HAL_GpioExitLowpower(hal_gpio_handle_t gpioHandle)
-{
-    hal_gpio_state_t *gpioState;
-    gpio_pin_config_t gpioPinconfig = {
-        kGPIO_DigitalInput,
-        0,
-    };
+/*!
+ * @brief Enables or disables the GPIO wake-up feature.
+ *
+ * This function enables or disables the GPIO wake-up feature.
+ *
+ * @param gpioHandle GPIO handle pointer.
+ * The handle should be 4 byte aligned, because unaligned access doesn't be supported on some devices.
+ * @param enable enable or disable (0 - disable, 1 - enable).
+ * @retval kStatus_HAL_GpioError An error occurred.
+ * @retval kStatus_HAL_GpioSuccess Set successfully.
+ */
+hal_gpio_status_t HAL_GpioWakeUpSetting(hal_gpio_handle_t gpioHandle, uint8_t enable);
 
-    assert(gpioHandle);
+/*!
+ * @brief Prepares to enter low power consumption.
+ *
+ * This function is used to prepare to enter low power consumption.
+ *
+ * @param gpioHandle GPIO handle pointer.
+ * The handle should be 4 byte aligned, because unaligned access doesn't be supported on some devices.
+ * @retval kStatus_HAL_GpioSuccess Successful operation.
+ */
+hal_gpio_status_t HAL_GpioEnterLowpower(hal_gpio_handle_t gpioHandle);
 
-    gpioState                  = (hal_gpio_state_t *)gpioHandle;
-    gpioPinconfig.pinDirection = kGPIO_DigitalInput;
-    if (kHAL_GpioDirectionOut == gpioState->direction)
-    {
-        gpioPinconfig.pinDirection = kGPIO_DigitalOutput;
-    }
+/*!
+ * @brief Restores from low power consumption.
+ *
+ * This function is used to restore from low power consumption.
+ *
+ * @param gpioHandle GPIO handle pointer.
+ * The handle should be 4 byte aligned, because unaligned access doesn't be supported on some devices.
+ * @retval kStatus_HAL_GpioSuccess Successful operation.
+ */
+hal_gpio_status_t HAL_GpioExitLowpower(hal_gpio_handle_t gpioHandle);
 
-    GPIO_PinInit(s_GpioPort[gpioState->port], gpioState->pin, &gpioPinconfig);
-    if (kHAL_GpioDirectionIn == gpioState->direction)
-    {
-        (void)HAL_GpioSetTriggerMode(gpioHandle, (hal_gpio_interrupt_trigger_t)gpioState->trigger);
-    }
-    return kStatus_HAL_GpioSuccess;
+#if defined(__cplusplus)
 }
+#endif /* __cplusplus */
+/*! @}*/
+#endif /* __HAL_GPIO_H__ */
