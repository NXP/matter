--- a/fsl_gpio.c
+++ b/fsl_gpio.c
@@ -1,6 +1,6 @@
 /*
- * Copyright (c) 2015, Freescale Semiconductor, Inc.
- * Copyright 2016-2019, 2023 NXP
+ * Copyright (c) 2016, Freescale Semiconductor, Inc.
+ * Copyright 2016-2017, 2020-2021 NXP
  * All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
@@ -8,51 +8,30 @@
 
 #include "fsl_gpio.h"
 
-/*******************************************************************************
- * Definitions
- ******************************************************************************/
 /* Component ID definition, used by tools. */
 #ifndef FSL_COMPONENT_ID
-#define FSL_COMPONENT_ID "platform.drivers.gpio"
-#endif
-
-#if defined(GPIO_RSTS)
-#define GPIO_RESETS_ARRAY GPIO_RSTS
+#define FSL_COMPONENT_ID "platform.drivers.igpio"
 #endif
 
 /*******************************************************************************
  * Variables
  ******************************************************************************/
 
-#if !(defined(FSL_FEATURE_PORT_HAS_NO_INTERRUPT) && FSL_FEATURE_PORT_HAS_NO_INTERRUPT) && \
-    defined(FSL_FEATURE_SOC_PORT_COUNT)
-static PORT_Type *const s_portBases[] = PORT_BASE_PTRS;
+#if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)
+/* Array of GPIO peripheral base address. */
 static GPIO_Type *const s_gpioBases[] = GPIO_BASE_PTRS;
 #endif
 
-#if defined(FSL_FEATURE_SOC_FGPIO_COUNT) && FSL_FEATURE_SOC_FGPIO_COUNT
-
-#if defined(FSL_FEATURE_PCC_HAS_FGPIO_CLOCK_GATE_CONTROL) && FSL_FEATURE_PCC_HAS_FGPIO_CLOCK_GATE_CONTROL
-
 #if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)
-/*! @brief Array to map FGPIO instance number to clock name. */
-static const clock_ip_name_t s_fgpioClockName[] = FGPIO_CLOCKS;
+/* Array of GPIO clock name. */
+static const clock_ip_name_t s_gpioClock[] = GPIO_CLOCKS;
 #endif /* FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL */
 
-#endif /* FSL_FEATURE_PCC_HAS_FGPIO_CLOCK_GATE_CONTROL */
-
-#endif /* FSL_FEATURE_SOC_FGPIO_COUNT */
-
-#if defined(GPIO_RESETS_ARRAY)
-/* Reset array */
-static const reset_ip_name_t s_gpioResets[] = GPIO_RESETS_ARRAY;
-#endif
-
 /*******************************************************************************
  * Prototypes
  ******************************************************************************/
-#if !(defined(FSL_FEATURE_PORT_HAS_NO_INTERRUPT) && FSL_FEATURE_PORT_HAS_NO_INTERRUPT) && \
-    defined(FSL_FEATURE_SOC_PORT_COUNT)
+
+#if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)
 /*!
  * @brief Gets the GPIO instance according to the GPIO base
  *
@@ -60,18 +39,17 @@ static const reset_ip_name_t s_gpioResets[] = GPIO_RESETS_ARRAY;
  * @retval GPIO instance
  */
 static uint32_t GPIO_GetInstance(GPIO_Type *base);
-#endif
+
 /*******************************************************************************
  * Code
  ******************************************************************************/
-#if !(defined(FSL_FEATURE_PORT_HAS_NO_INTERRUPT) && FSL_FEATURE_PORT_HAS_NO_INTERRUPT) && \
-    defined(FSL_FEATURE_SOC_PORT_COUNT) || defined(GPIO_RESETS_ARRAY)
+
 static uint32_t GPIO_GetInstance(GPIO_Type *base)
 {
     uint32_t instance;
 
     /* Find the instance index from base address mappings. */
-    for (instance = 0; instance < ARRAY_SIZE(s_gpioBases); instance++)
+    for (instance = 0U; instance < ARRAY_SIZE(s_gpioBases); instance++)
     {
         if (s_gpioBases[instance] == base)
         {
@@ -84,357 +62,122 @@ static uint32_t GPIO_GetInstance(GPIO_Type *base)
     return instance;
 }
 #endif
+
 /*!
- * brief Initializes a GPIO pin used by the board.
- *
- * To initialize the GPIO, define a pin configuration, as either input or output, in the user file.
- * Then, call the GPIO_PinInit() function.
+ * brief Initializes the GPIO peripheral according to the specified
+ *        parameters in the initConfig.
  *
- * This is an example to define an input pin or an output pin configuration.
- * code
- * Define a digital input pin configuration,
- * gpio_pin_config_t config =
- * {
- *   kGPIO_DigitalInput,
- *   0,
- * }
- * Define a digital output pin configuration,
- * gpio_pin_config_t config =
- * {
- *   kGPIO_DigitalOutput,
- *   0,
- * }
- * endcode
- *
- * param base   GPIO peripheral base pointer (GPIOA, GPIOB, GPIOC, and so on.)
- * param pin    GPIO port pin number
- * param config GPIO pin configuration pointer
+ * param base GPIO base pointer.
+ * param pin Specifies the pin number
+ * param initConfig pointer to a ref gpio_pin_config_t structure that
+ *        contains the configuration information.
  */
-void GPIO_PinInit(GPIO_Type *base, uint32_t pin, const gpio_pin_config_t *config)
+void GPIO_PinInit(GPIO_Type *base, uint32_t pin, const gpio_pin_config_t *Config)
 {
-    assert(NULL != config);
+#if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)
+    /* Enable GPIO clock. */
+    uint32_t instance = GPIO_GetInstance(base);
 
-#if defined(GPIO_RESETS_ARRAY)
-    RESET_ReleasePeripheralReset(s_gpioResets[GPIO_GetInstance(base)]);
-#endif
+    /* If The clock IP is valid, enable the clock gate. */
+    if ((instance < ARRAY_SIZE(s_gpioClock)) && (kCLOCK_IpInvalid != s_gpioClock[instance]))
+    {
+        (void)CLOCK_EnableClock(s_gpioClock[instance]);
+    }
+#endif /* FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL */
+
+    /* Register reset to default value */
+    base->IMR &= ~(1UL << pin);
 
-    if (config->pinDirection == kGPIO_DigitalInput)
+    /* Configure GPIO pin direction */
+    if (Config->direction == kGPIO_DigitalInput)
     {
-        base->PDDR &= GPIO_FIT_REG(~(1UL << pin));
+        base->GDIR &= ~(1UL << pin);
     }
     else
     {
-        GPIO_PinWrite(base, pin, config->outputLogic);
-        base->PDDR |= GPIO_FIT_REG((1UL << pin));
+        GPIO_PinWrite(base, pin, Config->outputLogic);
+        base->GDIR |= (1UL << pin);
     }
-}
 
-#if defined(FSL_FEATURE_GPIO_HAS_VERSION_INFO_REGISTER) && FSL_FEATURE_GPIO_HAS_VERSION_INFO_REGISTER
-void GPIO_GetVersionInfo(GPIO_Type *base, gpio_version_info_t *info)
-{
-    info->feature = (uint16_t)base->VERID;
-    info->minor   = (uint8_t)(base->VERID >> GPIO_VERID_MINOR_SHIFT);
-    info->major   = (uint8_t)(base->VERID >> GPIO_VERID_MAJOR_SHIFT);
+    /* Configure GPIO pin interrupt mode */
+    GPIO_SetPinInterruptConfig(base, pin, Config->interruptMode);
 }
-#endif /* FSL_FEATURE_GPIO_HAS_VERSION_INFO_REGISTER */
 
-#if !(defined(FSL_FEATURE_PORT_HAS_NO_INTERRUPT) && FSL_FEATURE_PORT_HAS_NO_INTERRUPT) && \
-    defined(FSL_FEATURE_SOC_PORT_COUNT)
 /*!
- * brief Reads the GPIO port interrupt status flag.
+ * brief Sets the output level of the individual GPIO pin to logic 1 or 0.
  *
- * If a pin is configured to generate the DMA request, the corresponding flag
- * is cleared automatically at the completion of the requested DMA transfer.
- * Otherwise, the flag remains set until a logic one is written to that flag.
- * If configured for a level sensitive interrupt that remains asserted, the flag
- * is set again immediately.
- *
- * param base GPIO peripheral base pointer (GPIOA, GPIOB, GPIOC, and so on.)
- * retval The current GPIO port interrupt status flag, for example, 0x00010001 means the
- *         pin 0 and 17 have the interrupt.
+ * param base GPIO base pointer.
+ * param pin GPIO port pin number.
+ * param output GPIOpin output logic level.
+ *        - 0: corresponding pin output low-logic level.
+ *        - 1: corresponding pin output high-logic level.
  */
-uint32_t GPIO_PortGetInterruptFlags(GPIO_Type *base)
+void GPIO_PinWrite(GPIO_Type *base, uint32_t pin, uint8_t output)
 {
-    uint8_t instance;
-    PORT_Type *portBase;
-    instance = (uint8_t)GPIO_GetInstance(base);
-    portBase = s_portBases[instance];
-    return portBase->ISFR;
-}
+    assert(pin < 32U);
+    if (output == 0U)
+    {
+#if (defined(FSL_FEATURE_IGPIO_HAS_DR_CLEAR) && FSL_FEATURE_IGPIO_HAS_DR_CLEAR)
+        base->DR_CLEAR = (1UL << pin);
 #else
-/*!
- * brief Read the GPIO interrupt status flags.
- *
- * param base GPIO peripheral base pointer. (GPIOA, GPIOB, GPIOC, and so on.)
- * return The current GPIO's interrupt status flag.
- *         '1' means the related pin's flag is set, '0' means the related pin's flag not set.
- *          For example, the return value 0x00010001 means the pin 0 and 17 have the interrupt pending.
- */
-uint32_t GPIO_GpioGetInterruptFlags(GPIO_Type *base)
-{
-    return base->ISFR[0];
-}
-#if (defined(FSL_FEATURE_GPIO_HAS_INTERRUPT_CHANNEL_SELECT) && FSL_FEATURE_GPIO_HAS_INTERRUPT_CHANNEL_SELECT)
-/*!
- * brief Read the GPIO interrupt status flags based on selected interrupt channel(IRQS).
- * param base GPIO peripheral base pointer. (GPIOA, GPIOB, GPIOC, and so on.)
- * param channel '0' means selete interrupt channel 0, '1' means selete interrupt channel 1.
- *
- * return The current GPIO's interrupt status flag based on the selected interrupt channel.
- *         '1' means the related pin's flag is set, '0' means the related pin's flag not set.
- *          For example, the return value 0x00010001 means the pin 0 and 17 have the interrupt pending.
- */
-uint32_t GPIO_GpioGetInterruptChannelFlags(GPIO_Type *base, uint32_t channel)
-{
-    assert(channel < 2U);
-    return base->ISFR[channel];
-}
-#endif /* FSL_FEATURE_GPIO_HAS_INTERRUPT_CHANNEL_SELECT */
-/*!
- * brief Read individual pin's interrupt status flag.
- *
- * param base GPIO peripheral base pointer. (GPIOA, GPIOB, GPIOC, and so on)
- * param pin GPIO specific pin number.
- * return The current selected pin's interrupt status flag.
- */
-uint8_t GPIO_PinGetInterruptFlag(GPIO_Type *base, uint32_t pin)
-{
-    return (uint8_t)((base->ICR[pin] & GPIO_ICR_ISF_MASK) >> GPIO_ICR_ISF_SHIFT);
-}
-#endif /* FSL_FEATURE_PORT_HAS_NO_INTERRUPT */
-
-#if !(defined(FSL_FEATURE_PORT_HAS_NO_INTERRUPT) && FSL_FEATURE_PORT_HAS_NO_INTERRUPT) && \
-    defined(FSL_FEATURE_SOC_PORT_COUNT)
-/*!
- * brief Clears multiple GPIO pin interrupt status flags.
- *
- * param base GPIO peripheral base pointer (GPIOA, GPIOB, GPIOC, and so on.)
- * param mask GPIO pin number macro
- */
-void GPIO_PortClearInterruptFlags(GPIO_Type *base, uint32_t mask)
-{
-    uint8_t instance;
-    PORT_Type *portBase;
-    instance       = (uint8_t)GPIO_GetInstance(base);
-    portBase       = s_portBases[instance];
-    portBase->ISFR = mask;
-}
+        base->DR &= ~(1UL << pin); /* Set pin output to low level.*/
+#endif
+    }
+    else
+    {
+#if (defined(FSL_FEATURE_IGPIO_HAS_DR_SET) && FSL_FEATURE_IGPIO_HAS_DR_SET)
+        base->DR_SET = (1UL << pin);
 #else
-/*!
- * brief Clears GPIO pin interrupt status flags.
- *
- * param base GPIO peripheral base pointer (GPIOA, GPIOB, GPIOC, and so on.)
- * param mask GPIO pin number macro
- */
-void GPIO_GpioClearInterruptFlags(GPIO_Type *base, uint32_t mask)
-{
-    base->ISFR[0] = GPIO_FIT_REG(mask);
-}
-#if (defined(FSL_FEATURE_GPIO_HAS_INTERRUPT_CHANNEL_SELECT) && FSL_FEATURE_GPIO_HAS_INTERRUPT_CHANNEL_SELECT)
-/*!
- * brief Clears GPIO pin interrupt status flags based on selected interrupt channel(IRQS).
- *
- * param base GPIO peripheral base pointer (GPIOA, GPIOB, GPIOC, and so on.)
- * param mask GPIO pin number macro
- * param channel '0' means selete interrupt channel 0, '1' means selete interrupt channel 1.
- */
-void GPIO_GpioClearInterruptChannelFlags(GPIO_Type *base, uint32_t mask, uint32_t channel)
-{
-    assert(channel < 2U);
-    base->ISFR[channel] = GPIO_FIT_REG(mask);
-}
-#endif /* FSL_FEATURE_GPIO_HAS_INTERRUPT_CHANNEL_SELECT */
-/*!
- * brief Clear GPIO individual pin's interrupt status flag.
- *
- * param base GPIO peripheral base pointer (GPIOA, GPIOB, GPIOC, and so on).
- * param pin GPIO specific pin number.
- */
-void GPIO_PinClearInterruptFlag(GPIO_Type *base, uint32_t pin)
-{
-    base->ICR[pin] |= GPIO_FIT_REG(GPIO_ICR_ISF(1U));
+        base->DR |= (1UL << pin);  /* Set pin output to high level.*/
+#endif
+    }
 }
-#endif /* FSL_FEATURE_PORT_HAS_NO_INTERRUPT */
 
-#if defined(FSL_FEATURE_GPIO_HAS_ATTRIBUTE_CHECKER) && FSL_FEATURE_GPIO_HAS_ATTRIBUTE_CHECKER
 /*!
- * brief The GPIO module supports a device-specific number of data ports, organized as 32-bit
- * words/8-bit Bytes. Each 32-bit/8-bit data port includes a GACR register, which defines the byte-level
- * attributes required for a successful access to the GPIO programming model. If the GPIO module's GACR register
- * organized as 32-bit words, the attribute controls for the 4 data bytes in the GACR follow a standard little
- * endian data convention.
+ * brief Sets the current pin interrupt mode.
  *
- * param base      GPIO peripheral base pointer (GPIOA, GPIOB, GPIOC, and so on.)
- * param attribute GPIO checker attribute
+ * param base GPIO base pointer.
+ * param pin GPIO port pin number.
+ * param pininterruptMode pointer to a ref gpio_interrupt_mode_t structure
+ *        that contains the interrupt mode information.
  */
-void GPIO_CheckAttributeBytes(GPIO_Type *base, gpio_checker_attribute_t attribute)
+void GPIO_PinSetInterruptConfig(GPIO_Type *base, uint32_t pin, gpio_interrupt_mode_t pinInterruptMode)
 {
-#if defined(FSL_FEATURE_GPIO_REGISTERS_WIDTH) && (FSL_FEATURE_GPIO_REGISTERS_WIDTH == 8U)
-    base->GACR = ((uint8_t)attribute << GPIO_GACR_ACB_SHIFT);
-#else
-    base->GACR = ((uint32_t)attribute << GPIO_GACR_ACB0_SHIFT) | ((uint32_t)attribute << GPIO_GACR_ACB1_SHIFT) |
-                 ((uint32_t)attribute << GPIO_GACR_ACB2_SHIFT) | ((uint32_t)attribute << GPIO_GACR_ACB3_SHIFT);
-#endif /* FSL_FEATURE_GPIO_REGISTERS_WIDTH */
-}
-#endif
+    volatile uint32_t *icr;
+    uint32_t icrShift;
 
-#if defined(FSL_FEATURE_SOC_FGPIO_COUNT) && FSL_FEATURE_SOC_FGPIO_COUNT
+    icrShift = pin;
 
-/*******************************************************************************
- * Variables
- ******************************************************************************/
-#if !(defined(FSL_FEATURE_PORT_HAS_NO_INTERRUPT) && FSL_FEATURE_PORT_HAS_NO_INTERRUPT) && \
-    defined(FSL_FEATURE_SOC_PORT_COUNT)
-static FGPIO_Type *const s_fgpioBases[] = FGPIO_BASE_PTRS;
-#endif
-/*******************************************************************************
- * Prototypes
- ******************************************************************************/
-#if !(defined(FSL_FEATURE_PORT_HAS_NO_INTERRUPT) && FSL_FEATURE_PORT_HAS_NO_INTERRUPT) && \
-    defined(FSL_FEATURE_SOC_PORT_COUNT)
-/*!
- * @brief Gets the FGPIO instance according to the GPIO base
- *
- * @param base    FGPIO peripheral base pointer(PTA, PTB, PTC, etc.)
- * @retval FGPIO instance
- */
-static uint32_t FGPIO_GetInstance(FGPIO_Type *base);
-#endif
-/*******************************************************************************
- * Code
- ******************************************************************************/
-#if !(defined(FSL_FEATURE_PORT_HAS_NO_INTERRUPT) && FSL_FEATURE_PORT_HAS_NO_INTERRUPT) && \
-    defined(FSL_FEATURE_SOC_PORT_COUNT)
-static uint32_t FGPIO_GetInstance(FGPIO_Type *base)
-{
-    uint32_t instance;
+    /* Register reset to default value */
+    base->EDGE_SEL &= ~(1UL << pin);
 
-    /* Find the instance index from base address mappings. */
-    for (instance = 0; instance < ARRAY_SIZE(s_fgpioBases); instance++)
+    if (pin < 16U)
     {
-        if (s_fgpioBases[instance] == base)
-        {
-            break;
-        }
+        icr = &(base->ICR1);
     }
-
-    assert(instance < ARRAY_SIZE(s_fgpioBases));
-
-    return instance;
-}
-#endif
-#if defined(FSL_FEATURE_PCC_HAS_FGPIO_CLOCK_GATE_CONTROL) && FSL_FEATURE_PCC_HAS_FGPIO_CLOCK_GATE_CONTROL
-/*!
- * brief Initializes the FGPIO peripheral.
- *
- * This function ungates the FGPIO clock.
- *
- * param base   FGPIO peripheral base pointer (FGPIOA, FGPIOB, FGPIOC, and so on.)
- */
-void FGPIO_PortInit(FGPIO_Type *base)
-{
-#if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)
-    /* Ungate FGPIO periphral clock */
-    CLOCK_EnableClock(s_fgpioClockName[FGPIO_GetInstance(base)]);
-#endif /* FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL */
-}
-#endif /* FSL_FEATURE_PCC_HAS_FGPIO_CLOCK_GATE_CONTROL */
-
-/*!
- * brief Initializes a FGPIO pin used by the board.
- *
- * To initialize the FGPIO driver, define a pin configuration, as either input or output, in the user file.
- * Then, call the FGPIO_PinInit() function.
- *
- * This is an example to define an input pin or an output pin configuration:
- * code
- * Define a digital input pin configuration,
- * gpio_pin_config_t config =
- * {
- *   kGPIO_DigitalInput,
- *   0,
- * }
- * Define a digital output pin configuration,
- * gpio_pin_config_t config =
- * {
- *   kGPIO_DigitalOutput,
- *   0,
- * }
- * endcode
- *
- * param base   FGPIO peripheral base pointer (FGPIOA, FGPIOB, FGPIOC, and so on.)
- * param pin    FGPIO port pin number
- * param config FGPIO pin configuration pointer
- */
-void FGPIO_PinInit(FGPIO_Type *base, uint32_t pin, const gpio_pin_config_t *config)
-{
-    assert(NULL != config);
-
-    if (config->pinDirection == kGPIO_DigitalInput)
+    else
     {
-        base->PDDR &= ~(1UL << pin);
+        icr = &(base->ICR2);
+        icrShift -= 16U;
     }
-    else
+    switch (pinInterruptMode)
     {
-        FGPIO_PinWrite(base, pin, config->outputLogic);
-        base->PDDR |= (1UL << pin);
+        case (kGPIO_IntLowLevel):
+            *icr &= ~(3UL << (2UL * icrShift));
+            break;
+        case (kGPIO_IntHighLevel):
+            *icr = (*icr & (~(3UL << (2UL * icrShift)))) | (1UL << (2UL * icrShift));
+            break;
+        case (kGPIO_IntRisingEdge):
+            *icr = (*icr & (~(3UL << (2UL * icrShift)))) | (2UL << (2UL * icrShift));
+            break;
+        case (kGPIO_IntFallingEdge):
+            *icr |= (3UL << (2UL * icrShift));
+            break;
+        case (kGPIO_IntRisingOrFallingEdge):
+            base->EDGE_SEL |= (1UL << pin);
+            break;
+        default:; /* Intentional empty default */
+            break;
     }
 }
-#if !(defined(FSL_FEATURE_PORT_HAS_NO_INTERRUPT) && FSL_FEATURE_PORT_HAS_NO_INTERRUPT) && \
-    defined(FSL_FEATURE_SOC_PORT_COUNT)
-/*!
- * brief Reads the FGPIO port interrupt status flag.
- *
- * If a pin is configured to generate the DMA request, the corresponding flag
- * is cleared automatically at the completion of the requested DMA transfer.
- * Otherwise, the flag remains set until a logic one is written to that flag.
- * If configured for a level-sensitive interrupt that remains asserted, the flag
- * is set again immediately.
- *
- * param base FGPIO peripheral base pointer (FGPIOA, FGPIOB, FGPIOC, and so on.)
- * retval The current FGPIO port interrupt status flags, for example, 0x00010001 means the
- *         pin 0 and 17 have the interrupt.
- */
-uint32_t FGPIO_PortGetInterruptFlags(FGPIO_Type *base)
-{
-    uint8_t instance;
-    instance = (uint8_t)FGPIO_GetInstance(base);
-    PORT_Type *portBase;
-    portBase = s_portBases[instance];
-    return portBase->ISFR;
-}
-
-/*!
- * brief Clears the multiple FGPIO pin interrupt status flag.
- *
- * param base FGPIO peripheral base pointer (FGPIOA, FGPIOB, FGPIOC, and so on.)
- * param mask FGPIO pin number macro
- */
-void FGPIO_PortClearInterruptFlags(FGPIO_Type *base, uint32_t mask)
-{
-    uint8_t instance;
-    instance = (uint8_t)FGPIO_GetInstance(base);
-    PORT_Type *portBase;
-    portBase       = s_portBases[instance];
-    portBase->ISFR = mask;
-}
-#endif
-#if defined(FSL_FEATURE_FGPIO_HAS_ATTRIBUTE_CHECKER) && FSL_FEATURE_FGPIO_HAS_ATTRIBUTE_CHECKER
-/*!
- * brief The FGPIO module supports a device-specific number of data ports, organized as 32-bit
- * words. Each 32-bit data port includes a GACR register, which defines the byte-level
- * attributes required for a successful access to the GPIO programming model. The attribute controls for the 4 data
- * bytes in the GACR follow a standard little endian
- * data convention.
- *
- * param base      FGPIO peripheral base pointer (FGPIOA, FGPIOB, FGPIOC, and so on.)
- * param attribute FGPIO checker attribute
- */
-void FGPIO_CheckAttributeBytes(FGPIO_Type *base, gpio_checker_attribute_t attribute)
-{
-    base->GACR = ((uint32_t)attribute << FGPIO_GACR_ACB0_SHIFT) | ((uint32_t)attribute << FGPIO_GACR_ACB1_SHIFT) |
-                 ((uint32_t)attribute << FGPIO_GACR_ACB2_SHIFT) | ((uint32_t)attribute << FGPIO_GACR_ACB3_SHIFT);
-}
-#endif
-
-#endif /* FSL_FEATURE_SOC_FGPIO_COUNT */
