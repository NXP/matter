--- a/lfs.c
+++ b/lfs.c
@@ -1,33 +1,16 @@
 /*
  * The little filesystem
  *
- * Copyright (c) 2022, The littlefs authors.
  * Copyright (c) 2017, Arm Limited. All rights reserved.
  * SPDX-License-Identifier: BSD-3-Clause
  */
 #include "lfs.h"
 #include "lfs_util.h"
 
-
-// some constants used throughout the code
 #define LFS_BLOCK_NULL ((lfs_block_t)-1)
 #define LFS_BLOCK_INLINE ((lfs_block_t)-2)
 
-enum {
-    LFS_OK_RELOCATED = 1,
-    LFS_OK_DROPPED   = 2,
-    LFS_OK_ORPHANED  = 3,
-};
-
-enum {
-    LFS_CMP_EQ = 0,
-    LFS_CMP_LT = 1,
-    LFS_CMP_GT = 2,
-};
-
-
 /// Caching block device operations ///
-
 static inline void lfs_cache_drop(lfs_t *lfs, lfs_cache_t *rcache) {
     // do not zero, cheaper if cache is readonly or only going to be
     // written with identical data (during relocates)
@@ -46,8 +29,8 @@ static int lfs_bd_read(lfs_t *lfs,
         lfs_block_t block, lfs_off_t off,
         void *buffer, lfs_size_t size) {
     uint8_t *data = buffer;
-    if (off+size > lfs->cfg->block_size
-            || (lfs->block_count && block >= lfs->block_count)) {
+    if (block >= lfs->cfg->block_count ||
+            off+size > lfs->cfg->block_size) {
         return LFS_ERR_CORRUPT;
     }
 
@@ -104,7 +87,7 @@ static int lfs_bd_read(lfs_t *lfs,
         }
 
         // load to cache, first condition can no longer fail
-        LFS_ASSERT(!lfs->block_count || block < lfs->block_count);
+        LFS_ASSERT(block < lfs->cfg->block_count);
         rcache->block = block;
         rcache->off = lfs_aligndown(off, lfs->cfg->read_size);
         rcache->size = lfs_min(
@@ -124,6 +107,12 @@ static int lfs_bd_read(lfs_t *lfs,
     return 0;
 }
 
+enum {
+    LFS_CMP_EQ = 0,
+    LFS_CMP_LT = 1,
+    LFS_CMP_GT = 2,
+};
+
 static int lfs_bd_cmp(lfs_t *lfs,
         const lfs_cache_t *pcache, lfs_cache_t *rcache, lfs_size_t hint,
         lfs_block_t block, lfs_off_t off,
@@ -135,14 +124,14 @@ static int lfs_bd_cmp(lfs_t *lfs,
         uint8_t dat[8];
 
         diff = lfs_min(size-i, sizeof(dat));
-        int err = lfs_bd_read(lfs,
+        int res = lfs_bd_read(lfs,
                 pcache, rcache, hint-i,
                 block, off+i, &dat, diff);
-        if (err) {
-            return err;
+        if (res) {
+            return res;
         }
 
-        int res = memcmp(dat, data + i, diff);
+        res = memcmp(dat, data + i, diff);
         if (res) {
             return res < 0 ? LFS_CMP_LT : LFS_CMP_GT;
         }
@@ -151,32 +140,11 @@ static int lfs_bd_cmp(lfs_t *lfs,
     return LFS_CMP_EQ;
 }
 
-static int lfs_bd_crc(lfs_t *lfs,
-        const lfs_cache_t *pcache, lfs_cache_t *rcache, lfs_size_t hint,
-        lfs_block_t block, lfs_off_t off, lfs_size_t size, uint32_t *crc) {
-    lfs_size_t diff = 0;
-
-    for (lfs_off_t i = 0; i < size; i += diff) {
-        uint8_t dat[8];
-        diff = lfs_min(size-i, sizeof(dat));
-        int err = lfs_bd_read(lfs,
-                pcache, rcache, hint-i,
-                block, off+i, &dat, diff);
-        if (err) {
-            return err;
-        }
-
-        *crc = lfs_crc(*crc, &dat, diff);
-    }
-
-    return 0;
-}
-
 #ifndef LFS_READONLY
 static int lfs_bd_flush(lfs_t *lfs,
         lfs_cache_t *pcache, lfs_cache_t *rcache, bool validate) {
     if (pcache->block != LFS_BLOCK_NULL && pcache->block != LFS_BLOCK_INLINE) {
-        LFS_ASSERT(pcache->block < lfs->block_count);
+        LFS_ASSERT(pcache->block < lfs->cfg->block_count);
         lfs_size_t diff = lfs_alignup(pcache->size, lfs->cfg->prog_size);
         int err = lfs->cfg->prog(lfs->cfg, pcache->block,
                 pcache->off, pcache->buffer, diff);
@@ -229,7 +197,7 @@ static int lfs_bd_prog(lfs_t *lfs,
         lfs_block_t block, lfs_off_t off,
         const void *buffer, lfs_size_t size) {
     const uint8_t *data = buffer;
-    LFS_ASSERT(block == LFS_BLOCK_INLINE || block < lfs->block_count);
+    LFS_ASSERT(block == LFS_BLOCK_INLINE || block < lfs->cfg->block_count);
     LFS_ASSERT(off + size <= lfs->cfg->block_size);
 
     while (size > 0) {
@@ -273,7 +241,7 @@ static int lfs_bd_prog(lfs_t *lfs,
 
 #ifndef LFS_READONLY
 static int lfs_bd_erase(lfs_t *lfs, lfs_block_t block) {
-    LFS_ASSERT(block < lfs->block_count);
+    LFS_ASSERT(block < lfs->cfg->block_count);
     int err = lfs->cfg->erase(lfs->cfg, block);
     LFS_ASSERT(err <= 0);
     return err;
@@ -300,7 +268,7 @@ static inline int lfs_pair_cmp(
              paira[0] == pairb[1] || paira[1] == pairb[0]);
 }
 
-static inline bool lfs_pair_issync(
+static inline bool lfs_pair_sync(
         const lfs_block_t paira[2],
         const lfs_block_t pairb[2]) {
     return (paira[0] == pairb[0] && paira[1] == pairb[1]) ||
@@ -312,12 +280,10 @@ static inline void lfs_pair_fromle32(lfs_block_t pair[2]) {
     pair[1] = lfs_fromle32(pair[1]);
 }
 
-#ifndef LFS_READONLY
 static inline void lfs_pair_tole32(lfs_block_t pair[2]) {
     pair[0] = lfs_tole32(pair[0]);
     pair[1] = lfs_tole32(pair[1]);
 }
-#endif
 
 // operations on 32-bit entry tags
 typedef uint32_t lfs_tag_t;
@@ -344,10 +310,6 @@ static inline uint16_t lfs_tag_type1(lfs_tag_t tag) {
     return (tag & 0x70000000) >> 20;
 }
 
-static inline uint16_t lfs_tag_type2(lfs_tag_t tag) {
-    return (tag & 0x78000000) >> 20;
-}
-
 static inline uint16_t lfs_tag_type3(lfs_tag_t tag) {
     return (tag & 0x7ff00000) >> 20;
 }
@@ -403,23 +365,17 @@ static inline bool lfs_gstate_iszero(const lfs_gstate_t *a) {
     return true;
 }
 
-#ifndef LFS_READONLY
 static inline bool lfs_gstate_hasorphans(const lfs_gstate_t *a) {
     return lfs_tag_size(a->tag);
 }
 
 static inline uint8_t lfs_gstate_getorphans(const lfs_gstate_t *a) {
-    return lfs_tag_size(a->tag) & 0x1ff;
+    return lfs_tag_size(a->tag);
 }
 
 static inline bool lfs_gstate_hasmove(const lfs_gstate_t *a) {
     return lfs_tag_type1(a->tag);
 }
-#endif
-
-static inline bool lfs_gstate_needssuperblock(const lfs_gstate_t *a) {
-    return lfs_tag_size(a->tag) >> 9;
-}
 
 static inline bool lfs_gstate_hasmovehere(const lfs_gstate_t *a,
         const lfs_block_t *pair) {
@@ -432,31 +388,11 @@ static inline void lfs_gstate_fromle32(lfs_gstate_t *a) {
     a->pair[1] = lfs_fromle32(a->pair[1]);
 }
 
-#ifndef LFS_READONLY
 static inline void lfs_gstate_tole32(lfs_gstate_t *a) {
     a->tag     = lfs_tole32(a->tag);
     a->pair[0] = lfs_tole32(a->pair[0]);
     a->pair[1] = lfs_tole32(a->pair[1]);
 }
-#endif
-
-// operations on forward-CRCs used to track erased state
-struct lfs_fcrc {
-    lfs_size_t size;
-    uint32_t crc;
-};
-
-static void lfs_fcrc_fromle32(struct lfs_fcrc *fcrc) {
-    fcrc->size = lfs_fromle32(fcrc->size);
-    fcrc->crc = lfs_fromle32(fcrc->crc);
-}
-
-#ifndef LFS_READONLY
-static void lfs_fcrc_tole32(struct lfs_fcrc *fcrc) {
-    fcrc->size = lfs_tole32(fcrc->size);
-    fcrc->crc = lfs_tole32(fcrc->crc);
-}
-#endif
 
 // other endianness operations
 static void lfs_ctz_fromle32(struct lfs_ctz *ctz) {
@@ -480,7 +416,6 @@ static inline void lfs_superblock_fromle32(lfs_superblock_t *superblock) {
     superblock->attr_max    = lfs_fromle32(superblock->attr_max);
 }
 
-#ifndef LFS_READONLY
 static inline void lfs_superblock_tole32(lfs_superblock_t *superblock) {
     superblock->version     = lfs_tole32(superblock->version);
     superblock->block_size  = lfs_tole32(superblock->block_size);
@@ -489,7 +424,6 @@ static inline void lfs_superblock_tole32(lfs_superblock_t *superblock) {
     superblock->file_max    = lfs_tole32(superblock->file_max);
     superblock->attr_max    = lfs_tole32(superblock->attr_max);
 }
-#endif
 
 #ifndef LFS_NO_ASSERT
 static bool lfs_mlist_isopen(struct lfs_mlist *head,
@@ -518,28 +452,6 @@ static void lfs_mlist_append(lfs_t *lfs, struct lfs_mlist *mlist) {
     lfs->mlist = mlist;
 }
 
-// some other filesystem operations
-static uint32_t lfs_fs_disk_version(lfs_t *lfs) {
-    (void)lfs;
-#ifdef LFS_MULTIVERSION
-    if (lfs->cfg->disk_version) {
-        return lfs->cfg->disk_version;
-    } else
-#endif
-    {
-        return LFS_DISK_VERSION;
-    }
-}
-
-static uint16_t lfs_fs_disk_version_major(lfs_t *lfs) {
-    return 0xffff & (lfs_fs_disk_version(lfs) >> 16);
-
-}
-
-static uint16_t lfs_fs_disk_version_minor(lfs_t *lfs) {
-    return 0xffff & (lfs_fs_disk_version(lfs) >> 0);
-}
-
 
 /// Internal operations predeclared here ///
 #ifndef LFS_READONLY
@@ -548,15 +460,13 @@ static int lfs_dir_commit(lfs_t *lfs, lfs_mdir_t *dir,
 static int lfs_dir_compact(lfs_t *lfs,
         lfs_mdir_t *dir, const struct lfs_mattr *attrs, int attrcount,
         lfs_mdir_t *source, uint16_t begin, uint16_t end);
-static lfs_ssize_t lfs_file_flushedwrite(lfs_t *lfs, lfs_file_t *file,
-        const void *buffer, lfs_size_t size);
+
 static lfs_ssize_t lfs_file_rawwrite(lfs_t *lfs, lfs_file_t *file,
         const void *buffer, lfs_size_t size);
 static int lfs_file_rawsync(lfs_t *lfs, lfs_file_t *file);
 static int lfs_file_outline(lfs_t *lfs, lfs_file_t *file);
 static int lfs_file_flush(lfs_t *lfs, lfs_file_t *file);
 
-static int lfs_fs_deorphan(lfs_t *lfs, bool powerloss);
 static int lfs_fs_preporphans(lfs_t *lfs, int8_t orphans);
 static void lfs_fs_prepmove(lfs_t *lfs,
         uint16_t id, const lfs_block_t pair[2]);
@@ -564,11 +474,11 @@ static int lfs_fs_pred(lfs_t *lfs, const lfs_block_t dir[2],
         lfs_mdir_t *pdir);
 static lfs_stag_t lfs_fs_parent(lfs_t *lfs, const lfs_block_t dir[2],
         lfs_mdir_t *parent);
+static int lfs_fs_relocate(lfs_t *lfs,
+        const lfs_block_t oldpair[2], lfs_block_t newpair[2]);
 static int lfs_fs_forceconsistency(lfs_t *lfs);
 #endif
 
-static void lfs_fs_prepsuperblock(lfs_t *lfs, bool needssuperblock);
-
 #ifdef LFS_MIGRATE
 static int lfs1_traverse(lfs_t *lfs,
         int (*cb)(void*, lfs_block_t), void *data);
@@ -576,8 +486,6 @@ static int lfs1_traverse(lfs_t *lfs,
 
 static int lfs_dir_rawrewind(lfs_t *lfs, lfs_dir_t *dir);
 
-static lfs_ssize_t lfs_file_flushedread(lfs_t *lfs, lfs_file_t *file,
-        void *buffer, lfs_size_t size);
 static lfs_ssize_t lfs_file_rawread(lfs_t *lfs, lfs_file_t *file,
         void *buffer, lfs_size_t size);
 static int lfs_file_rawclose(lfs_t *lfs, lfs_file_t *file);
@@ -597,7 +505,7 @@ static int lfs_rawunmount(lfs_t *lfs);
 static int lfs_alloc_lookahead(void *p, lfs_block_t block) {
     lfs_t *lfs = (lfs_t*)p;
     lfs_block_t off = ((block - lfs->free.off)
-            + lfs->block_count) % lfs->block_count;
+            + lfs->cfg->block_count) % lfs->cfg->block_count;
 
     if (off < lfs->free.size) {
         lfs->free.buffer[off / 32] |= 1U << (off % 32);
@@ -611,7 +519,7 @@ static int lfs_alloc_lookahead(void *p, lfs_block_t block) {
 // is to prevent blocks from being garbage collected in the middle of a
 // commit operation
 static void lfs_alloc_ack(lfs_t *lfs) {
-    lfs->free.ack = lfs->block_count;
+    lfs->free.ack = lfs->cfg->block_count;
 }
 
 // drop the lookahead buffer, this is done during mounting and failed
@@ -622,26 +530,6 @@ static void lfs_alloc_drop(lfs_t *lfs) {
     lfs_alloc_ack(lfs);
 }
 
-#ifndef LFS_READONLY
-static int lfs_fs_rawgc(lfs_t *lfs) {
-    // Move free offset at the first unused block (lfs->free.i)
-    // lfs->free.i is equal lfs->free.size when all blocks are used
-    lfs->free.off = (lfs->free.off + lfs->free.i) % lfs->block_count;
-    lfs->free.size = lfs_min(8*lfs->cfg->lookahead_size, lfs->free.ack);
-    lfs->free.i = 0;
-
-    // find mask of free blocks from tree
-    memset(lfs->free.buffer, 0, lfs->cfg->lookahead_size);
-    int err = lfs_fs_rawtraverse(lfs, lfs_alloc_lookahead, lfs, true);
-    if (err) {
-        lfs_alloc_drop(lfs);
-        return err;
-    }
-
-    return 0;
-}
-#endif
-
 #ifndef LFS_READONLY
 static int lfs_alloc(lfs_t *lfs, lfs_block_t *block) {
     while (true) {
@@ -652,7 +540,7 @@ static int lfs_alloc(lfs_t *lfs, lfs_block_t *block) {
 
             if (!(lfs->free.buffer[off / 32] & (1U << (off % 32)))) {
                 // found a free block
-                *block = (lfs->free.off + off) % lfs->block_count;
+                *block = (lfs->free.off + off) % lfs->cfg->block_count;
 
                 // eagerly find next off so an alloc ack can
                 // discredit old lookahead blocks
@@ -674,8 +562,16 @@ static int lfs_alloc(lfs_t *lfs, lfs_block_t *block) {
             return LFS_ERR_NOSPC;
         }
 
-        int err = lfs_fs_rawgc(lfs);
-        if(err) {
+        lfs->free.off = (lfs->free.off + lfs->free.size)
+                % lfs->cfg->block_count;
+        lfs->free.size = lfs_min(8*lfs->cfg->lookahead_size, lfs->free.ack);
+        lfs->free.i = 0;
+
+        // find mask of free blocks from tree
+        memset(lfs->free.buffer, 0, lfs->cfg->lookahead_size);
+        int err = lfs_fs_rawtraverse(lfs, lfs_alloc_lookahead, lfs, true);
+        if (err) {
+            lfs_alloc_drop(lfs);
             return err;
         }
     }
@@ -830,7 +726,6 @@ static int lfs_dir_traverse_filter(void *p,
             (LFS_MKTAG(0x7ff, 0x3ff, 0) & tag) == (
                 LFS_MKTAG(LFS_TYPE_DELETE, 0, 0) |
                     (LFS_MKTAG(0, 0x3ff, 0) & *filtertag))) {
-        *filtertag = LFS_MKTAG(LFS_FROM_NOOP, 0, 0);
         return true;
     }
 
@@ -845,227 +740,98 @@ static int lfs_dir_traverse_filter(void *p,
 #endif
 
 #ifndef LFS_READONLY
-// maximum recursive depth of lfs_dir_traverse, the deepest call:
-//
-// traverse with commit
-// '-> traverse with move
-//     '-> traverse with filter
-//
-#define LFS_DIR_TRAVERSE_DEPTH 3
-
-struct lfs_dir_traverse {
-    const lfs_mdir_t *dir;
-    lfs_off_t off;
-    lfs_tag_t ptag;
-    const struct lfs_mattr *attrs;
-    int attrcount;
-
-    lfs_tag_t tmask;
-    lfs_tag_t ttag;
-    uint16_t begin;
-    uint16_t end;
-    int16_t diff;
-
-    int (*cb)(void *data, lfs_tag_t tag, const void *buffer);
-    void *data;
-
-    lfs_tag_t tag;
-    const void *buffer;
-    struct lfs_diskoff disk;
-};
-
 static int lfs_dir_traverse(lfs_t *lfs,
         const lfs_mdir_t *dir, lfs_off_t off, lfs_tag_t ptag,
         const struct lfs_mattr *attrs, int attrcount,
         lfs_tag_t tmask, lfs_tag_t ttag,
         uint16_t begin, uint16_t end, int16_t diff,
         int (*cb)(void *data, lfs_tag_t tag, const void *buffer), void *data) {
-    // This function in inherently recursive, but bounded. To allow tool-based
-    // analysis without unnecessary code-cost we use an explicit stack
-    struct lfs_dir_traverse stack[LFS_DIR_TRAVERSE_DEPTH-1];
-    unsigned sp = 0;
-    int res;
-
     // iterate over directory and attrs
-    lfs_tag_t tag;
-    const void *buffer;
-    struct lfs_diskoff disk = {0};
     while (true) {
-        {
-            if (off+lfs_tag_dsize(ptag) < dir->off) {
-                off += lfs_tag_dsize(ptag);
-                int err = lfs_bd_read(lfs,
-                        NULL, &lfs->rcache, sizeof(tag),
-                        dir->pair[0], off, &tag, sizeof(tag));
-                if (err) {
-                    return err;
-                }
+        lfs_tag_t tag;
+        const void *buffer;
+        struct lfs_diskoff disk;
+        if (off+lfs_tag_dsize(ptag) < dir->off) {
+            off += lfs_tag_dsize(ptag);
+            int err = lfs_bd_read(lfs,
+                    NULL, &lfs->rcache, sizeof(tag),
+                    dir->pair[0], off, &tag, sizeof(tag));
+            if (err) {
+                return err;
+            }
 
-                tag = (lfs_frombe32(tag) ^ ptag) | 0x80000000;
-                disk.block = dir->pair[0];
-                disk.off = off+sizeof(lfs_tag_t);
-                buffer = &disk;
-                ptag = tag;
-            } else if (attrcount > 0) {
-                tag = attrs[0].tag;
-                buffer = attrs[0].buffer;
-                attrs += 1;
-                attrcount -= 1;
-            } else {
-                // finished traversal, pop from stack?
-                res = 0;
-                break;
+            tag = (lfs_frombe32(tag) ^ ptag) | 0x80000000;
+            disk.block = dir->pair[0];
+            disk.off = off+sizeof(lfs_tag_t);
+            buffer = &disk;
+            ptag = tag;
+        } else if (attrcount > 0) {
+            tag = attrs[0].tag;
+            buffer = attrs[0].buffer;
+            attrs += 1;
+            attrcount -= 1;
+        } else {
+            return 0;
+        }
+
+        lfs_tag_t mask = LFS_MKTAG(0x7ff, 0, 0);
+        if ((mask & tmask & tag) != (mask & tmask & ttag)) {
+            continue;
+        }
+
+        // do we need to filter? inlining the filtering logic here allows
+        // for some minor optimizations
+        if (lfs_tag_id(tmask) != 0) {
+            // scan for duplicates and update tag based on creates/deletes
+            int filter = lfs_dir_traverse(lfs,
+                    dir, off, ptag, attrs, attrcount,
+                    0, 0, 0, 0, 0,
+                    lfs_dir_traverse_filter, &tag);
+            if (filter < 0) {
+                return filter;
             }
 
-            // do we need to filter?
-            lfs_tag_t mask = LFS_MKTAG(0x7ff, 0, 0);
-            if ((mask & tmask & tag) != (mask & tmask & ttag)) {
+            if (filter) {
                 continue;
             }
 
-            if (lfs_tag_id(tmask) != 0) {
-                LFS_ASSERT(sp < LFS_DIR_TRAVERSE_DEPTH);
-                // recurse, scan for duplicates, and update tag based on
-                // creates/deletes
-                stack[sp] = (struct lfs_dir_traverse){
-                    .dir        = dir,
-                    .off        = off,
-                    .ptag       = ptag,
-                    .attrs      = attrs,
-                    .attrcount  = attrcount,
-                    .tmask      = tmask,
-                    .ttag       = ttag,
-                    .begin      = begin,
-                    .end        = end,
-                    .diff       = diff,
-                    .cb         = cb,
-                    .data       = data,
-                    .tag        = tag,
-                    .buffer     = buffer,
-                    .disk       = disk,
-                };
-                sp += 1;
-
-                tmask = 0;
-                ttag = 0;
-                begin = 0;
-                end = 0;
-                diff = 0;
-                cb = lfs_dir_traverse_filter;
-                data = &stack[sp-1].tag;
+            // in filter range?
+            if (!(lfs_tag_id(tag) >= begin && lfs_tag_id(tag) < end)) {
                 continue;
             }
         }
 
-popped:
-        // in filter range?
-        if (lfs_tag_id(tmask) != 0 &&
-                !(lfs_tag_id(tag) >= begin && lfs_tag_id(tag) < end)) {
-            continue;
-        }
-
         // handle special cases for mcu-side operations
         if (lfs_tag_type3(tag) == LFS_FROM_NOOP) {
             // do nothing
         } else if (lfs_tag_type3(tag) == LFS_FROM_MOVE) {
-            // Without this condition, lfs_dir_traverse can exhibit an
-            // extremely expensive O(n^3) of nested loops when renaming.
-            // This happens because lfs_dir_traverse tries to filter tags by
-            // the tags in the source directory, triggering a second
-            // lfs_dir_traverse with its own filter operation.
-            //
-            // traverse with commit
-            // '-> traverse with filter
-            //     '-> traverse with move
-            //         '-> traverse with filter
-            //
-            // However we don't actually care about filtering the second set of
-            // tags, since duplicate tags have no effect when filtering.
-            //
-            // This check skips this unnecessary recursive filtering explicitly,
-            // reducing this runtime from O(n^3) to O(n^2).
-            if (cb == lfs_dir_traverse_filter) {
-                continue;
-            }
-
-            // recurse into move
-            stack[sp] = (struct lfs_dir_traverse){
-                .dir        = dir,
-                .off        = off,
-                .ptag       = ptag,
-                .attrs      = attrs,
-                .attrcount  = attrcount,
-                .tmask      = tmask,
-                .ttag       = ttag,
-                .begin      = begin,
-                .end        = end,
-                .diff       = diff,
-                .cb         = cb,
-                .data       = data,
-                .tag        = LFS_MKTAG(LFS_FROM_NOOP, 0, 0),
-            };
-            sp += 1;
-
             uint16_t fromid = lfs_tag_size(tag);
             uint16_t toid = lfs_tag_id(tag);
-            dir = buffer;
-            off = 0;
-            ptag = 0xffffffff;
-            attrs = NULL;
-            attrcount = 0;
-            tmask = LFS_MKTAG(0x600, 0x3ff, 0);
-            ttag = LFS_MKTAG(LFS_TYPE_STRUCT, 0, 0);
-            begin = fromid;
-            end = fromid+1;
-            diff = toid-fromid+diff;
+            int err = lfs_dir_traverse(lfs,
+                    buffer, 0, 0xffffffff, NULL, 0,
+                    LFS_MKTAG(0x600, 0x3ff, 0),
+                    LFS_MKTAG(LFS_TYPE_STRUCT, 0, 0),
+                    fromid, fromid+1, toid-fromid+diff,
+                    cb, data);
+            if (err) {
+                return err;
+            }
         } else if (lfs_tag_type3(tag) == LFS_FROM_USERATTRS) {
             for (unsigned i = 0; i < lfs_tag_size(tag); i++) {
                 const struct lfs_attr *a = buffer;
-                res = cb(data, LFS_MKTAG(LFS_TYPE_USERATTR + a[i].type,
+                int err = cb(data, LFS_MKTAG(LFS_TYPE_USERATTR + a[i].type,
                         lfs_tag_id(tag) + diff, a[i].size), a[i].buffer);
-                if (res < 0) {
-                    return res;
-                }
-
-                if (res) {
-                    break;
+                if (err) {
+                    return err;
                 }
             }
         } else {
-            res = cb(data, tag + LFS_MKTAG(0, diff, 0), buffer);
-            if (res < 0) {
-                return res;
-            }
-
-            if (res) {
-                break;
+            int err = cb(data, tag + LFS_MKTAG(0, diff, 0), buffer);
+            if (err) {
+                return err;
             }
         }
     }
-
-    if (sp > 0) {
-        // pop from the stack and return, fortunately all pops share
-        // a destination
-        dir         = stack[sp-1].dir;
-        off         = stack[sp-1].off;
-        ptag        = stack[sp-1].ptag;
-        attrs       = stack[sp-1].attrs;
-        attrcount   = stack[sp-1].attrcount;
-        tmask       = stack[sp-1].tmask;
-        ttag        = stack[sp-1].ttag;
-        begin       = stack[sp-1].begin;
-        end         = stack[sp-1].end;
-        diff        = stack[sp-1].diff;
-        cb          = stack[sp-1].cb;
-        data        = stack[sp-1].data;
-        tag         = stack[sp-1].tag;
-        buffer      = stack[sp-1].buffer;
-        disk        = stack[sp-1].disk;
-        sp -= 1;
-        goto popped;
-    } else {
-        return res;
-    }
 }
 #endif
 
@@ -1079,8 +845,7 @@ static lfs_stag_t lfs_dir_fetchmatch(lfs_t *lfs,
 
     // if either block address is invalid we return LFS_ERR_CORRUPT here,
     // otherwise later writes to the pair could fail
-    if (lfs->block_count 
-            && (pair[0] >= lfs->block_count || pair[1] >= lfs->block_count)) {
+    if (pair[0] >= lfs->cfg->block_count || pair[1] >= lfs->cfg->block_count) {
         return LFS_ERR_CORRUPT;
     }
 
@@ -1117,11 +882,6 @@ static lfs_stag_t lfs_dir_fetchmatch(lfs_t *lfs,
         bool tempsplit = false;
         lfs_stag_t tempbesttag = besttag;
 
-        // assume not erased until proven otherwise
-        bool maybeerased = false;
-        bool hasfcrc = false;
-        struct lfs_fcrc fcrc;
-
         dir->rev = lfs_tole32(dir->rev);
         uint32_t crc = lfs_crc(0xffffffff, &dir->rev, sizeof(dir->rev));
         dir->rev = lfs_fromle32(dir->rev);
@@ -1136,6 +896,7 @@ static lfs_stag_t lfs_dir_fetchmatch(lfs_t *lfs,
             if (err) {
                 if (err == LFS_ERR_CORRUPT) {
                     // can't continue?
+                    dir->erased = false;
                     break;
                 }
                 return err;
@@ -1144,19 +905,19 @@ static lfs_stag_t lfs_dir_fetchmatch(lfs_t *lfs,
             crc = lfs_crc(crc, &tag, sizeof(tag));
             tag = lfs_frombe32(tag) ^ ptag;
 
-            // next commit not yet programmed?
+            // next commit not yet programmed or we're not in valid range
             if (!lfs_tag_isvalid(tag)) {
-                // we only might be erased if the last tag was a crc
-                maybeerased = (lfs_tag_type2(ptag) == LFS_TYPE_CCRC);
+                dir->erased = (lfs_tag_type1(ptag) == LFS_TYPE_CRC &&
+                        dir->off % lfs->cfg->prog_size == 0);
                 break;
-            // out of range?
             } else if (off + lfs_tag_dsize(tag) > lfs->cfg->block_size) {
+                dir->erased = false;
                 break;
             }
 
             ptag = tag;
 
-            if (lfs_tag_type2(tag) == LFS_TYPE_CCRC) {
+            if (lfs_tag_type1(tag) == LFS_TYPE_CRC) {
                 // check the crc attr
                 uint32_t dcrc;
                 err = lfs_bd_read(lfs,
@@ -1164,6 +925,7 @@ static lfs_stag_t lfs_dir_fetchmatch(lfs_t *lfs,
                         dir->pair[0], off+sizeof(tag), &dcrc, sizeof(dcrc));
                 if (err) {
                     if (err == LFS_ERR_CORRUPT) {
+                        dir->erased = false;
                         break;
                     }
                     return err;
@@ -1171,6 +933,7 @@ static lfs_stag_t lfs_dir_fetchmatch(lfs_t *lfs,
                 dcrc = lfs_fromle32(dcrc);
 
                 if (crc != dcrc) {
+                    dir->erased = false;
                     break;
                 }
 
@@ -1192,21 +955,26 @@ static lfs_stag_t lfs_dir_fetchmatch(lfs_t *lfs,
                 dir->tail[1] = temptail[1];
                 dir->split = tempsplit;
 
-                // reset crc, hasfcrc
+                // reset crc
                 crc = 0xffffffff;
                 continue;
             }
 
             // crc the entry first, hopefully leaving it in the cache
-            err = lfs_bd_crc(lfs,
-                    NULL, &lfs->rcache, lfs->cfg->block_size,
-                    dir->pair[0], off+sizeof(tag),
-                    lfs_tag_dsize(tag)-sizeof(tag), &crc);
-            if (err) {
-                if (err == LFS_ERR_CORRUPT) {
-                    break;
+            for (lfs_off_t j = sizeof(tag); j < lfs_tag_dsize(tag); j++) {
+                uint8_t dat;
+                err = lfs_bd_read(lfs,
+                        NULL, &lfs->rcache, lfs->cfg->block_size,
+                        dir->pair[0], off+j, &dat, 1);
+                if (err) {
+                    if (err == LFS_ERR_CORRUPT) {
+                        dir->erased = false;
+                        break;
+                    }
+                    return err;
                 }
-                return err;
+
+                crc = lfs_crc(crc, &dat, 1);
             }
 
             // directory modification tags?
@@ -1233,24 +1001,11 @@ static lfs_stag_t lfs_dir_fetchmatch(lfs_t *lfs,
                         dir->pair[0], off+sizeof(tag), &temptail, 8);
                 if (err) {
                     if (err == LFS_ERR_CORRUPT) {
+                        dir->erased = false;
                         break;
                     }
-                    return err;
                 }
                 lfs_pair_fromle32(temptail);
-            } else if (lfs_tag_type3(tag) == LFS_TYPE_FCRC) {
-                err = lfs_bd_read(lfs,
-                        NULL, &lfs->rcache, lfs->cfg->block_size,
-                        dir->pair[0], off+sizeof(tag),
-                        &fcrc, sizeof(fcrc));
-                if (err) {
-                    if (err == LFS_ERR_CORRUPT) {
-                        break;
-                    }
-                }
-
-                lfs_fcrc_fromle32(&fcrc);
-                hasfcrc = true;
             }
 
             // found a match for our fetcher?
@@ -1259,6 +1014,7 @@ static lfs_stag_t lfs_dir_fetchmatch(lfs_t *lfs,
                         dir->pair[0], off+sizeof(tag)});
                 if (res < 0) {
                     if (res == LFS_ERR_CORRUPT) {
+                        dir->erased = false;
                         break;
                     }
                     return res;
@@ -1280,67 +1036,35 @@ static lfs_stag_t lfs_dir_fetchmatch(lfs_t *lfs,
             }
         }
 
-        // found no valid commits?
-        if (dir->off == 0) {
-            // try the other block?
-            lfs_pair_swap(dir->pair);
-            dir->rev = revs[(r+1)%2];
-            continue;
-        }
-
-        // did we end on a valid commit? we may have an erased block
-        dir->erased = false;
-        if (maybeerased && dir->off % lfs->cfg->prog_size == 0) {
-        #ifdef LFS_MULTIVERSION
-            // note versions < lfs2.1 did not have fcrc tags, if
-            // we're < lfs2.1 treat missing fcrc as erased data
-            //
-            // we don't strictly need to do this, but otherwise writing
-            // to lfs2.0 disks becomes very inefficient
-            if (lfs_fs_disk_version(lfs) < 0x00020001) {
-                dir->erased = true;
-
-            } else
-        #endif
-            if (hasfcrc) {
-                // check for an fcrc matching the next prog's erased state, if
-                // this failed most likely a previous prog was interrupted, we
-                // need a new erase
-                uint32_t fcrc_ = 0xffffffff;
-                int err = lfs_bd_crc(lfs,
-                        NULL, &lfs->rcache, lfs->cfg->block_size,
-                        dir->pair[0], dir->off, fcrc.size, &fcrc_);
-                if (err && err != LFS_ERR_CORRUPT) {
-                    return err;
+        // consider what we have good enough
+        if (dir->off > 0) {
+            // synthetic move
+            if (lfs_gstate_hasmovehere(&lfs->gdisk, dir->pair)) {
+                if (lfs_tag_id(lfs->gdisk.tag) == lfs_tag_id(besttag)) {
+                    besttag |= 0x80000000;
+                } else if (besttag != -1 &&
+                        lfs_tag_id(lfs->gdisk.tag) < lfs_tag_id(besttag)) {
+                    besttag -= LFS_MKTAG(0, 1, 0);
                 }
-
-                // found beginning of erased part?
-                dir->erased = (fcrc_ == fcrc.crc);
             }
-        }
 
-        // synthetic move
-        if (lfs_gstate_hasmovehere(&lfs->gdisk, dir->pair)) {
-            if (lfs_tag_id(lfs->gdisk.tag) == lfs_tag_id(besttag)) {
-                besttag |= 0x80000000;
-            } else if (besttag != -1 &&
-                    lfs_tag_id(lfs->gdisk.tag) < lfs_tag_id(besttag)) {
-                besttag -= LFS_MKTAG(0, 1, 0);
+            // found tag? or found best id?
+            if (id) {
+                *id = lfs_min(lfs_tag_id(besttag), dir->count);
             }
-        }
 
-        // found tag? or found best id?
-        if (id) {
-            *id = lfs_min(lfs_tag_id(besttag), dir->count);
+            if (lfs_tag_isvalid(besttag)) {
+                return besttag;
+            } else if (lfs_tag_id(besttag) < dir->count) {
+                return LFS_ERR_NOENT;
+            } else {
+                return 0;
+            }
         }
 
-        if (lfs_tag_isvalid(besttag)) {
-            return besttag;
-        } else if (lfs_tag_id(besttag) < dir->count) {
-            return LFS_ERR_NOENT;
-        } else {
-            return 0;
-        }
+        // failed, try the other block?
+        lfs_pair_swap(dir->pair);
+        dir->rev = revs[(r+1)%2];
     }
 
     LFS_ERROR("Corrupted dir pair at {0x%"PRIx32", 0x%"PRIx32"}",
@@ -1614,15 +1338,9 @@ static int lfs_dir_commitattr(lfs_t *lfs, struct lfs_commit *commit,
 #endif
 
 #ifndef LFS_READONLY
-
 static int lfs_dir_commitcrc(lfs_t *lfs, struct lfs_commit *commit) {
     // align to program units
-    //
-    // this gets a bit complex as we have two types of crcs:
-    // - 5-word crc with fcrc to check following prog (middle of block)
-    // - 2-word crc with no following prog (end of block)
-    const lfs_off_t end = lfs_alignup(
-            lfs_min(commit->off + 5*sizeof(uint32_t), lfs->cfg->block_size),
+    const lfs_off_t end = lfs_alignup(commit->off + 2*sizeof(uint32_t),
             lfs->cfg->prog_size);
 
     lfs_off_t off1 = 0;
@@ -1632,128 +1350,89 @@ static int lfs_dir_commitcrc(lfs_t *lfs, struct lfs_commit *commit) {
     // padding is not crced, which lets fetches skip padding but
     // makes committing a bit more complicated
     while (commit->off < end) {
-        lfs_off_t noff = (
-                lfs_min(end - (commit->off+sizeof(lfs_tag_t)), 0x3fe)
-                + (commit->off+sizeof(lfs_tag_t)));
-        // too large for crc tag? need padding commits
+        lfs_off_t off = commit->off + sizeof(lfs_tag_t);
+        lfs_off_t noff = lfs_min(end - off, 0x3fe) + off;
         if (noff < end) {
-            noff = lfs_min(noff, end - 5*sizeof(uint32_t));
+            noff = lfs_min(noff, end - 2*sizeof(uint32_t));
         }
 
-        // space for fcrc?
-        uint8_t eperturb = (uint8_t)-1;
-        if (noff >= end && noff <= lfs->cfg->block_size - lfs->cfg->prog_size) {
-            // first read the leading byte, this always contains a bit
-            // we can perturb to avoid writes that don't change the fcrc
-            int err = lfs_bd_read(lfs,
-                    NULL, &lfs->rcache, lfs->cfg->prog_size,
-                    commit->block, noff, &eperturb, 1);
-            if (err && err != LFS_ERR_CORRUPT) {
-                return err;
-            }
-
-        #ifdef LFS_MULTIVERSION
-            // unfortunately fcrcs break mdir fetching < lfs2.1, so only write
-            // these if we're a >= lfs2.1 filesystem
-            if (lfs_fs_disk_version(lfs) <= 0x00020000) {
-                // don't write fcrc
-            } else
-        #endif
-            {
-                // find the expected fcrc, don't bother avoiding a reread
-                // of the eperturb, it should still be in our cache
-                struct lfs_fcrc fcrc = {
-                    .size = lfs->cfg->prog_size,
-                    .crc = 0xffffffff
-                };
-                err = lfs_bd_crc(lfs,
-                        NULL, &lfs->rcache, lfs->cfg->prog_size,
-                        commit->block, noff, fcrc.size, &fcrc.crc);
-                if (err && err != LFS_ERR_CORRUPT) {
-                    return err;
-                }
-
-                lfs_fcrc_tole32(&fcrc);
-                err = lfs_dir_commitattr(lfs, commit,
-                        LFS_MKTAG(LFS_TYPE_FCRC, 0x3ff, sizeof(struct lfs_fcrc)),
-                        &fcrc);
-                if (err) {
-                    return err;
-                }
-            }
+        // read erased state from next program unit
+        lfs_tag_t tag = 0xffffffff;
+        int err = lfs_bd_read(lfs,
+                NULL, &lfs->rcache, sizeof(tag),
+                commit->block, noff, &tag, sizeof(tag));
+        if (err && err != LFS_ERR_CORRUPT) {
+            return err;
         }
 
-        // build commit crc
-        struct {
-            lfs_tag_t tag;
-            uint32_t crc;
-        } ccrc;
-        lfs_tag_t ntag = LFS_MKTAG(
-                LFS_TYPE_CCRC + (((uint8_t)~eperturb) >> 7), 0x3ff,
-                noff - (commit->off+sizeof(lfs_tag_t)));
-        ccrc.tag = lfs_tobe32(ntag ^ commit->ptag);
-        commit->crc = lfs_crc(commit->crc, &ccrc.tag, sizeof(lfs_tag_t));
-        ccrc.crc = lfs_tole32(commit->crc);
-
-        int err = lfs_bd_prog(lfs,
+        // build crc tag
+        bool reset = ~lfs_frombe32(tag) >> 31;
+        tag = LFS_MKTAG(LFS_TYPE_CRC + reset, 0x3ff, noff - off);
+
+        // write out crc
+        uint32_t footer[2];
+        footer[0] = lfs_tobe32(tag ^ commit->ptag);
+        commit->crc = lfs_crc(commit->crc, &footer[0], sizeof(footer[0]));
+        footer[1] = lfs_tole32(commit->crc);
+        err = lfs_bd_prog(lfs,
                 &lfs->pcache, &lfs->rcache, false,
-                commit->block, commit->off, &ccrc, sizeof(ccrc));
+                commit->block, commit->off, &footer, sizeof(footer));
         if (err) {
             return err;
         }
 
         // keep track of non-padding checksum to verify
         if (off1 == 0) {
-            off1 = commit->off + sizeof(lfs_tag_t);
+            off1 = commit->off + sizeof(uint32_t);
             crc1 = commit->crc;
         }
 
-        commit->off = noff;
-        // perturb valid bit?
-        commit->ptag = ntag ^ ((0x80UL & ~eperturb) << 24);
-        // reset crc for next commit
-        commit->crc = 0xffffffff;
-
-        // manually flush here since we don't prog the padding, this confuses
-        // the caching layer
-        if (noff >= end || noff >= lfs->pcache.off + lfs->cfg->cache_size) {
-            // flush buffers
-            int err = lfs_bd_sync(lfs, &lfs->pcache, &lfs->rcache, false);
-            if (err) {
-                return err;
-            }
-        }
+        commit->off += sizeof(tag)+lfs_tag_size(tag);
+        commit->ptag = tag ^ ((lfs_tag_t)reset << 31);
+        commit->crc = 0xffffffff; // reset crc for next "commit"
     }
 
-    // successful commit, check checksums to make sure
-    //
-    // note that we don't need to check padding commits, worst
-    // case if they are corrupted we would have had to compact anyways
-    lfs_off_t off = commit->begin;
-    uint32_t crc = 0xffffffff;
-    int err = lfs_bd_crc(lfs,
-            NULL, &lfs->rcache, off1+sizeof(uint32_t),
-            commit->block, off, off1-off, &crc);
+    // flush buffers
+    int err = lfs_bd_sync(lfs, &lfs->pcache, &lfs->rcache, false);
     if (err) {
         return err;
     }
 
-    // check non-padding commits against known crc
-    if (crc != crc1) {
-        return LFS_ERR_CORRUPT;
-    }
+    // successful commit, check checksums to make sure
+    lfs_off_t off = commit->begin;
+    lfs_off_t noff = off1;
+    while (off < end) {
+        uint32_t crc = 0xffffffff;
+        for (lfs_off_t i = off; i < noff+sizeof(uint32_t); i++) {
+            // check against written crc, may catch blocks that
+            // become readonly and match our commit size exactly
+            if (i == off1 && crc != crc1) {
+                return LFS_ERR_CORRUPT;
+            }
 
-    // make sure to check crc in case we happen to pick
-    // up an unrelated crc (frozen block?)
-    err = lfs_bd_crc(lfs,
-            NULL, &lfs->rcache, sizeof(uint32_t),
-            commit->block, off1, sizeof(uint32_t), &crc);
-    if (err) {
-        return err;
-    }
+            // leave it up to caching to make this efficient
+            uint8_t dat;
+            err = lfs_bd_read(lfs,
+                    NULL, &lfs->rcache, noff+sizeof(uint32_t)-i,
+                    commit->block, i, &dat, 1);
+            if (err) {
+                return err;
+            }
 
-    if (crc != 0) {
-        return LFS_ERR_CORRUPT;
+            crc = lfs_crc(crc, &dat, 1);
+        }
+
+        // detected write error?
+        if (crc != 0) {
+            return LFS_ERR_CORRUPT;
+        }
+
+        // skip padding
+        off = lfs_min(end - noff, 0x3fe) + noff;
+        if (off < end) {
+            off = lfs_min(off, end - 2*sizeof(uint32_t));
+        }
+        noff = off + sizeof(uint32_t);
     }
 
     return 0;
@@ -1770,7 +1449,7 @@ static int lfs_dir_alloc(lfs_t *lfs, lfs_mdir_t *dir) {
         }
     }
 
-    // zero for reproducibility in case initial block is unreadable
+    // zero for reproducability in case initial block is unreadable
     dir->rev = 0;
 
     // rather than clobbering one of the blocks we just pretend
@@ -1829,7 +1508,8 @@ static int lfs_dir_drop(lfs_t *lfs, lfs_mdir_t *dir, lfs_mdir_t *tail) {
 static int lfs_dir_split(lfs_t *lfs,
         lfs_mdir_t *dir, const struct lfs_mattr *attrs, int attrcount,
         lfs_mdir_t *source, uint16_t split, uint16_t end) {
-    // create tail metadata pair
+    // create tail directory
+    lfs_alloc_ack(lfs);
     lfs_mdir_t tail;
     int err = lfs_dir_alloc(lfs, &tail);
     if (err) {
@@ -1840,10 +1520,9 @@ static int lfs_dir_split(lfs_t *lfs,
     tail.tail[0] = dir->tail[0];
     tail.tail[1] = dir->tail[1];
 
-    // note we don't care about LFS_OK_RELOCATED
-    int res = lfs_dir_compact(lfs, &tail, attrs, attrcount, source, split, end);
-    if (res < 0) {
-        return res;
+    err = lfs_dir_compact(lfs, &tail, attrs, attrcount, source, split, end);
+    if (err) {
+        return err;
     }
 
     dir->tail[0] = tail.pair[0];
@@ -1884,45 +1563,107 @@ static int lfs_dir_commit_commit(void *p, lfs_tag_t tag, const void *buffer) {
 }
 #endif
 
-#ifndef LFS_READONLY
-static bool lfs_dir_needsrelocation(lfs_t *lfs, lfs_mdir_t *dir) {
-    // If our revision count == n * block_cycles, we should force a relocation,
-    // this is how littlefs wear-levels at the metadata-pair level. Note that we
-    // actually use (block_cycles+1)|1, this is to avoid two corner cases:
-    // 1. block_cycles = 1, which would prevent relocations from terminating
-    // 2. block_cycles = 2n, which, due to aliasing, would only ever relocate
-    //    one metadata block in the pair, effectively making this useless
-    return (lfs->cfg->block_cycles > 0
-            && ((dir->rev + 1) % ((lfs->cfg->block_cycles+1)|1) == 0));
-}
-#endif
-
 #ifndef LFS_READONLY
 static int lfs_dir_compact(lfs_t *lfs,
         lfs_mdir_t *dir, const struct lfs_mattr *attrs, int attrcount,
         lfs_mdir_t *source, uint16_t begin, uint16_t end) {
     // save some state in case block is bad
+    const lfs_block_t oldpair[2] = {dir->pair[0], dir->pair[1]};
     bool relocated = false;
-    bool tired = lfs_dir_needsrelocation(lfs, dir);
+    bool tired = false;
+
+    // should we split?
+    while (end - begin > 1) {
+        // find size
+        lfs_size_t size = 0;
+        int err = lfs_dir_traverse(lfs,
+                source, 0, 0xffffffff, attrs, attrcount,
+                LFS_MKTAG(0x400, 0x3ff, 0),
+                LFS_MKTAG(LFS_TYPE_NAME, 0, 0),
+                begin, end, -begin,
+                lfs_dir_commit_size, &size);
+        if (err) {
+            return err;
+        }
+
+        // space is complicated, we need room for tail, crc, gstate,
+        // cleanup delete, and we cap at half a block to give room
+        // for metadata updates.
+        if (end - begin < 0xff &&
+                size <= lfs_min(lfs->cfg->block_size - 36,
+                    lfs_alignup((lfs->cfg->metadata_max ?
+                            lfs->cfg->metadata_max : lfs->cfg->block_size)/2,
+                        lfs->cfg->prog_size))) {
+            break;
+        }
+
+        // can't fit, need to split, we should really be finding the
+        // largest size that fits with a small binary search, but right now
+        // it's not worth the code size
+        uint16_t split = (end - begin) / 2;
+        err = lfs_dir_split(lfs, dir, attrs, attrcount,
+                source, begin+split, end);
+        if (err) {
+            // if we fail to split, we may be able to overcompact, unless
+            // we're too big for even the full block, in which case our
+            // only option is to error
+            if (err == LFS_ERR_NOSPC && size <= lfs->cfg->block_size - 36) {
+                break;
+            }
+            return err;
+        }
+
+        end = begin + split;
+    }
 
     // increment revision count
     dir->rev += 1;
+    // If our revision count == n * block_cycles, we should force a relocation,
+    // this is how littlefs wear-levels at the metadata-pair level. Note that we
+    // actually use (block_cycles+1)|1, this is to avoid two corner cases:
+    // 1. block_cycles = 1, which would prevent relocations from terminating
+    // 2. block_cycles = 2n, which, due to aliasing, would only ever relocate
+    //    one metadata block in the pair, effectively making this useless
+    if (lfs->cfg->block_cycles > 0 &&
+            (dir->rev % ((lfs->cfg->block_cycles+1)|1) == 0)) {
+        if (lfs_pair_cmp(dir->pair, (const lfs_block_t[2]){0, 1}) == 0) {
+            // oh no! we're writing too much to the superblock,
+            // should we expand?
+            lfs_ssize_t res = lfs_fs_rawsize(lfs);
+            if (res < 0) {
+                return res;
+            }
+
+            // do we have extra space? littlefs can't reclaim this space
+            // by itself, so expand cautiously
+            if ((lfs_size_t)res < lfs->cfg->block_count/2) {
+                LFS_DEBUG("Expanding superblock at rev %"PRIu32, dir->rev);
+                int err = lfs_dir_split(lfs, dir, attrs, attrcount,
+                        source, begin, end);
+                if (err && err != LFS_ERR_NOSPC) {
+                    return err;
+                }
 
-    // do not proactively relocate blocks during migrations, this
-    // can cause a number of failure states such: clobbering the
-    // v1 superblock if we relocate root, and invalidating directory
-    // pointers if we relocate the head of a directory. On top of
-    // this, relocations increase the overall complexity of
-    // lfs_migration, which is already a delicate operation.
+                // welp, we tried, if we ran out of space there's not much
+                // we can do, we'll error later if we've become frozen
+                if (!err) {
+                    end = begin;
+                }
+            }
 #ifdef LFS_MIGRATE
-    if (lfs->lfs1) {
-        tired = false;
-    }
+        } else if (lfs->lfs1) {
+            // do not proactively relocate blocks during migrations, this
+            // can cause a number of failure states such: clobbering the
+            // v1 superblock if we relocate root, and invalidating directory
+            // pointers if we relocate the head of a directory. On top of
+            // this, relocations increase the overall complexity of
+            // lfs_migration, which is already a delicate operation.
 #endif
-
-    if (tired && lfs_pair_cmp(dir->pair, (const lfs_block_t[2]){0, 1}) != 0) {
-        // we're writing too much, time to relocate
-        goto relocate;
+        } else {
+            // we're writing too much, time to relocate
+            tired = true;
+            goto relocate;
+        }
     }
 
     // begin loop to commit compaction to blocks until a compact sticks
@@ -2066,123 +1807,44 @@ relocate:
         continue;
     }
 
-    return relocated ? LFS_OK_RELOCATED : 0;
-}
-#endif
-
-#ifndef LFS_READONLY
-static int lfs_dir_splittingcompact(lfs_t *lfs, lfs_mdir_t *dir,
-        const struct lfs_mattr *attrs, int attrcount,
-        lfs_mdir_t *source, uint16_t begin, uint16_t end) {
-    while (true) {
-        // find size of first split, we do this by halving the split until
-        // the metadata is guaranteed to fit
-        //
-        // Note that this isn't a true binary search, we never increase the
-        // split size. This may result in poorly distributed metadata but isn't
-        // worth the extra code size or performance hit to fix.
-        lfs_size_t split = begin;
-        while (end - split > 1) {
-            lfs_size_t size = 0;
-            int err = lfs_dir_traverse(lfs,
-                    source, 0, 0xffffffff, attrs, attrcount,
-                    LFS_MKTAG(0x400, 0x3ff, 0),
-                    LFS_MKTAG(LFS_TYPE_NAME, 0, 0),
-                    split, end, -split,
-                    lfs_dir_commit_size, &size);
-            if (err) {
-                return err;
-            }
-
-            // space is complicated, we need room for:
-            //
-            // - tail:         4+2*4 = 12 bytes
-            // - gstate:       4+3*4 = 16 bytes
-            // - move delete:  4     = 4 bytes
-            // - crc:          4+4   = 8 bytes
-            //                 total = 40 bytes
-            //
-            // And we cap at half a block to avoid degenerate cases with
-            // nearly-full metadata blocks.
-            //
-            if (end - split < 0xff
-                    && size <= lfs_min(
-                        lfs->cfg->block_size - 40,
-                        lfs_alignup(
-                            (lfs->cfg->metadata_max
-                                ? lfs->cfg->metadata_max
-                                : lfs->cfg->block_size)/2,
-                            lfs->cfg->prog_size))) {
-                break;
-            }
-
-            split = split + ((end - split) / 2);
-        }
-
-        if (split == begin) {
-            // no split needed
-            break;
-        }
-
-        // split into two metadata pairs and continue
-        int err = lfs_dir_split(lfs, dir, attrs, attrcount,
-                source, split, end);
-        if (err && err != LFS_ERR_NOSPC) {
-            return err;
-        }
-
+    if (relocated) {
+        // update references if we relocated
+        LFS_DEBUG("Relocating {0x%"PRIx32", 0x%"PRIx32"} "
+                    "-> {0x%"PRIx32", 0x%"PRIx32"}",
+                oldpair[0], oldpair[1], dir->pair[0], dir->pair[1]);
+        int err = lfs_fs_relocate(lfs, oldpair, dir->pair);
         if (err) {
-            // we can't allocate a new block, try to compact with degraded
-            // performance
-            LFS_WARN("Unable to split {0x%"PRIx32", 0x%"PRIx32"}",
-                    dir->pair[0], dir->pair[1]);
-            break;
-        } else {
-            end = split;
+            return err;
         }
     }
 
-    if (lfs_dir_needsrelocation(lfs, dir)
-            && lfs_pair_cmp(dir->pair, (const lfs_block_t[2]){0, 1}) == 0) {
-        // oh no! we're writing too much to the superblock,
-        // should we expand?
-        lfs_ssize_t size = lfs_fs_rawsize(lfs);
-        if (size < 0) {
-            return size;
-        }
+    return 0;
+}
+#endif
 
-        // do we have extra space? littlefs can't reclaim this space
-        // by itself, so expand cautiously
-        if ((lfs_size_t)size < lfs->block_count/2) {
-            LFS_DEBUG("Expanding superblock at rev %"PRIu32, dir->rev);
-            int err = lfs_dir_split(lfs, dir, attrs, attrcount,
-                    source, begin, end);
-            if (err && err != LFS_ERR_NOSPC) {
+#ifndef LFS_READONLY
+static int lfs_dir_commit(lfs_t *lfs, lfs_mdir_t *dir,
+        const struct lfs_mattr *attrs, int attrcount) {
+    // check for any inline files that aren't RAM backed and
+    // forcefully evict them, needed for filesystem consistency
+    for (lfs_file_t *f = (lfs_file_t*)lfs->mlist; f; f = f->next) {
+        if (dir != &f->m && lfs_pair_cmp(f->m.pair, dir->pair) == 0 &&
+                f->type == LFS_TYPE_REG && (f->flags & LFS_F_INLINE) &&
+                f->ctz.size > lfs->cfg->cache_size) {
+            int err = lfs_file_outline(lfs, f);
+            if (err) {
                 return err;
             }
 
+            err = lfs_file_flush(lfs, f);
             if (err) {
-                // welp, we tried, if we ran out of space there's not much
-                // we can do, we'll error later if we've become frozen
-                LFS_WARN("Unable to expand superblock");
-            } else {
-                end = begin;
+                return err;
             }
         }
     }
 
-    return lfs_dir_compact(lfs, dir, attrs, attrcount, source, begin, end);
-}
-#endif
-
-#ifndef LFS_READONLY
-static int lfs_dir_relocatingcommit(lfs_t *lfs, lfs_mdir_t *dir,
-        const lfs_block_t pair[2],
-        const struct lfs_mattr *attrs, int attrcount,
-        lfs_mdir_t *pdir) {
-    int state = 0;
-
     // calculate changes to the directory
+    lfs_mdir_t olddir = *dir;
     bool hasdelete = false;
     for (int i = 0; i < attrcount; i++) {
         if (lfs_tag_type3(attrs[i].tag) == LFS_TYPE_CREATE) {
@@ -2201,19 +1863,23 @@ static int lfs_dir_relocatingcommit(lfs_t *lfs, lfs_mdir_t *dir,
 
     // should we actually drop the directory block?
     if (hasdelete && dir->count == 0) {
-        LFS_ASSERT(pdir);
-        int err = lfs_fs_pred(lfs, dir->pair, pdir);
+        lfs_mdir_t pdir;
+        int err = lfs_fs_pred(lfs, dir->pair, &pdir);
         if (err && err != LFS_ERR_NOENT) {
+            *dir = olddir;
             return err;
         }
 
-        if (err != LFS_ERR_NOENT && pdir->split) {
-            state = LFS_OK_DROPPED;
-            goto fixmlist;
+        if (err != LFS_ERR_NOENT && pdir.split) {
+            err = lfs_dir_drop(lfs, &pdir, dir);
+            if (err) {
+                *dir = olddir;
+                return err;
+            }
         }
     }
 
-    if (dir->erased) {
+    if (dir->erased || dir->count >= 0xff) {
         // try to commit
         struct lfs_commit commit = {
             .block = dir->pair[0],
@@ -2238,6 +1904,7 @@ static int lfs_dir_relocatingcommit(lfs_t *lfs, lfs_mdir_t *dir,
             if (err == LFS_ERR_NOSPC || err == LFS_ERR_CORRUPT) {
                 goto compact;
             }
+            *dir = olddir;
             return err;
         }
 
@@ -2250,6 +1917,7 @@ static int lfs_dir_relocatingcommit(lfs_t *lfs, lfs_mdir_t *dir,
         if (!lfs_gstate_iszero(&delta)) {
             err = lfs_dir_getgstate(lfs, dir, &delta);
             if (err) {
+                *dir = olddir;
                 return err;
             }
 
@@ -2261,6 +1929,7 @@ static int lfs_dir_relocatingcommit(lfs_t *lfs, lfs_mdir_t *dir,
                 if (err == LFS_ERR_NOSPC || err == LFS_ERR_CORRUPT) {
                     goto compact;
                 }
+                *dir = olddir;
                 return err;
             }
         }
@@ -2271,6 +1940,7 @@ static int lfs_dir_relocatingcommit(lfs_t *lfs, lfs_mdir_t *dir,
             if (err == LFS_ERR_NOSPC || err == LFS_ERR_CORRUPT) {
                 goto compact;
             }
+            *dir = olddir;
             return err;
         }
 
@@ -2281,23 +1951,19 @@ static int lfs_dir_relocatingcommit(lfs_t *lfs, lfs_mdir_t *dir,
         // and update gstate
         lfs->gdisk = lfs->gstate;
         lfs->gdelta = (lfs_gstate_t){0};
-
-        goto fixmlist;
-    }
-
+    } else {
 compact:
-    // fall back to compaction
-    lfs_cache_drop(lfs, &lfs->pcache);
+        // fall back to compaction
+        lfs_cache_drop(lfs, &lfs->pcache);
 
-    state = lfs_dir_splittingcompact(lfs, dir, attrs, attrcount,
-            dir, 0, dir->count);
-    if (state < 0) {
-        return state;
+        int err = lfs_dir_compact(lfs, dir, attrs, attrcount,
+                dir, 0, dir->count);
+        if (err) {
+            *dir = olddir;
+            return err;
+        }
     }
 
-    goto fixmlist;
-
-fixmlist:;
     // this complicated bit of logic is for fixing up any active
     // metadata-pairs that we may have affected
     //
@@ -2305,32 +1971,33 @@ fixmlist:;
     // lfs_dir_commit could also be in this list, and even then
     // we need to copy the pair so they don't get clobbered if we refetch
     // our mdir.
-    lfs_block_t oldpair[2] = {pair[0], pair[1]};
     for (struct lfs_mlist *d = lfs->mlist; d; d = d->next) {
-        if (lfs_pair_cmp(d->m.pair, oldpair) == 0) {
+        if (&d->m != dir && lfs_pair_cmp(d->m.pair, olddir.pair) == 0) {
             d->m = *dir;
-            if (d->m.pair != pair) {
-                for (int i = 0; i < attrcount; i++) {
-                    if (lfs_tag_type3(attrs[i].tag) == LFS_TYPE_DELETE &&
-                            d->id == lfs_tag_id(attrs[i].tag)) {
-                        d->m.pair[0] = LFS_BLOCK_NULL;
-                        d->m.pair[1] = LFS_BLOCK_NULL;
-                    } else if (lfs_tag_type3(attrs[i].tag) == LFS_TYPE_DELETE &&
-                            d->id > lfs_tag_id(attrs[i].tag)) {
-                        d->id -= 1;
-                        if (d->type == LFS_TYPE_DIR) {
-                            ((lfs_dir_t*)d)->pos -= 1;
-                        }
-                    } else if (lfs_tag_type3(attrs[i].tag) == LFS_TYPE_CREATE &&
-                            d->id >= lfs_tag_id(attrs[i].tag)) {
-                        d->id += 1;
-                        if (d->type == LFS_TYPE_DIR) {
-                            ((lfs_dir_t*)d)->pos += 1;
-                        }
+            for (int i = 0; i < attrcount; i++) {
+                if (lfs_tag_type3(attrs[i].tag) == LFS_TYPE_DELETE &&
+                        d->id == lfs_tag_id(attrs[i].tag)) {
+                    d->m.pair[0] = LFS_BLOCK_NULL;
+                    d->m.pair[1] = LFS_BLOCK_NULL;
+                } else if (lfs_tag_type3(attrs[i].tag) == LFS_TYPE_DELETE &&
+                        d->id > lfs_tag_id(attrs[i].tag)) {
+                    d->id -= 1;
+                    if (d->type == LFS_TYPE_DIR) {
+                        ((lfs_dir_t*)d)->pos -= 1;
+                    }
+                } else if (lfs_tag_type3(attrs[i].tag) == LFS_TYPE_CREATE &&
+                        d->id >= lfs_tag_id(attrs[i].tag)) {
+                    d->id += 1;
+                    if (d->type == LFS_TYPE_DIR) {
+                        ((lfs_dir_t*)d)->pos += 1;
                     }
                 }
             }
+        }
+    }
 
+    for (struct lfs_mlist *d = lfs->mlist; d; d = d->next) {
+        if (lfs_pair_cmp(d->m.pair, olddir.pair) == 0) {
             while (d->id >= d->m.count && d->m.split) {
                 // we split and id is on tail now
                 d->id -= d->m.count;
@@ -2342,221 +2009,6 @@ fixmlist:;
         }
     }
 
-    return state;
-}
-#endif
-
-#ifndef LFS_READONLY
-static int lfs_dir_orphaningcommit(lfs_t *lfs, lfs_mdir_t *dir,
-        const struct lfs_mattr *attrs, int attrcount) {
-    // check for any inline files that aren't RAM backed and
-    // forcefully evict them, needed for filesystem consistency
-    for (lfs_file_t *f = (lfs_file_t*)lfs->mlist; f; f = f->next) {
-        if (dir != &f->m && lfs_pair_cmp(f->m.pair, dir->pair) == 0 &&
-                f->type == LFS_TYPE_REG && (f->flags & LFS_F_INLINE) &&
-                f->ctz.size > lfs->cfg->cache_size) {
-            int err = lfs_file_outline(lfs, f);
-            if (err) {
-                return err;
-            }
-
-            err = lfs_file_flush(lfs, f);
-            if (err) {
-                return err;
-            }
-        }
-    }
-
-    lfs_block_t lpair[2] = {dir->pair[0], dir->pair[1]};
-    lfs_mdir_t ldir = *dir;
-    lfs_mdir_t pdir;
-    int state = lfs_dir_relocatingcommit(lfs, &ldir, dir->pair,
-            attrs, attrcount, &pdir);
-    if (state < 0) {
-        return state;
-    }
-
-    // update if we're not in mlist, note we may have already been
-    // updated if we are in mlist
-    if (lfs_pair_cmp(dir->pair, lpair) == 0) {
-        *dir = ldir;
-    }
-
-    // commit was successful, but may require other changes in the
-    // filesystem, these would normally be tail recursive, but we have
-    // flattened them here avoid unbounded stack usage
-
-    // need to drop?
-    if (state == LFS_OK_DROPPED) {
-        // steal state
-        int err = lfs_dir_getgstate(lfs, dir, &lfs->gdelta);
-        if (err) {
-            return err;
-        }
-
-        // steal tail, note that this can't create a recursive drop
-        lpair[0] = pdir.pair[0];
-        lpair[1] = pdir.pair[1];
-        lfs_pair_tole32(dir->tail);
-        state = lfs_dir_relocatingcommit(lfs, &pdir, lpair, LFS_MKATTRS(
-                    {LFS_MKTAG(LFS_TYPE_TAIL + dir->split, 0x3ff, 8),
-                        dir->tail}),
-                NULL);
-        lfs_pair_fromle32(dir->tail);
-        if (state < 0) {
-            return state;
-        }
-
-        ldir = pdir;
-    }
-
-    // need to relocate?
-    bool orphans = false;
-    while (state == LFS_OK_RELOCATED) {
-        LFS_DEBUG("Relocating {0x%"PRIx32", 0x%"PRIx32"} "
-                    "-> {0x%"PRIx32", 0x%"PRIx32"}",
-                lpair[0], lpair[1], ldir.pair[0], ldir.pair[1]);
-        state = 0;
-
-        // update internal root
-        if (lfs_pair_cmp(lpair, lfs->root) == 0) {
-            lfs->root[0] = ldir.pair[0];
-            lfs->root[1] = ldir.pair[1];
-        }
-
-        // update internally tracked dirs
-        for (struct lfs_mlist *d = lfs->mlist; d; d = d->next) {
-            if (lfs_pair_cmp(lpair, d->m.pair) == 0) {
-                d->m.pair[0] = ldir.pair[0];
-                d->m.pair[1] = ldir.pair[1];
-            }
-
-            if (d->type == LFS_TYPE_DIR &&
-                    lfs_pair_cmp(lpair, ((lfs_dir_t*)d)->head) == 0) {
-                ((lfs_dir_t*)d)->head[0] = ldir.pair[0];
-                ((lfs_dir_t*)d)->head[1] = ldir.pair[1];
-            }
-        }
-
-        // find parent
-        lfs_stag_t tag = lfs_fs_parent(lfs, lpair, &pdir);
-        if (tag < 0 && tag != LFS_ERR_NOENT) {
-            return tag;
-        }
-
-        bool hasparent = (tag != LFS_ERR_NOENT);
-        if (tag != LFS_ERR_NOENT) {
-            // note that if we have a parent, we must have a pred, so this will
-            // always create an orphan
-            int err = lfs_fs_preporphans(lfs, +1);
-            if (err) {
-                return err;
-            }
-
-            // fix pending move in this pair? this looks like an optimization but
-            // is in fact _required_ since relocating may outdate the move.
-            uint16_t moveid = 0x3ff;
-            if (lfs_gstate_hasmovehere(&lfs->gstate, pdir.pair)) {
-                moveid = lfs_tag_id(lfs->gstate.tag);
-                LFS_DEBUG("Fixing move while relocating "
-                        "{0x%"PRIx32", 0x%"PRIx32"} 0x%"PRIx16"\n",
-                        pdir.pair[0], pdir.pair[1], moveid);
-                lfs_fs_prepmove(lfs, 0x3ff, NULL);
-                if (moveid < lfs_tag_id(tag)) {
-                    tag -= LFS_MKTAG(0, 1, 0);
-                }
-            }
-
-            lfs_block_t ppair[2] = {pdir.pair[0], pdir.pair[1]};
-            lfs_pair_tole32(ldir.pair);
-            state = lfs_dir_relocatingcommit(lfs, &pdir, ppair, LFS_MKATTRS(
-                        {LFS_MKTAG_IF(moveid != 0x3ff,
-                            LFS_TYPE_DELETE, moveid, 0), NULL},
-                        {tag, ldir.pair}),
-                    NULL);
-            lfs_pair_fromle32(ldir.pair);
-            if (state < 0) {
-                return state;
-            }
-
-            if (state == LFS_OK_RELOCATED) {
-                lpair[0] = ppair[0];
-                lpair[1] = ppair[1];
-                ldir = pdir;
-                orphans = true;
-                continue;
-            }
-        }
-
-        // find pred
-        int err = lfs_fs_pred(lfs, lpair, &pdir);
-        if (err && err != LFS_ERR_NOENT) {
-            return err;
-        }
-        LFS_ASSERT(!(hasparent && err == LFS_ERR_NOENT));
-
-        // if we can't find dir, it must be new
-        if (err != LFS_ERR_NOENT) {
-            if (lfs_gstate_hasorphans(&lfs->gstate)) {
-                // next step, clean up orphans
-                err = lfs_fs_preporphans(lfs, -hasparent);
-                if (err) {
-                    return err;
-                }
-            }
-
-            // fix pending move in this pair? this looks like an optimization
-            // but is in fact _required_ since relocating may outdate the move.
-            uint16_t moveid = 0x3ff;
-            if (lfs_gstate_hasmovehere(&lfs->gstate, pdir.pair)) {
-                moveid = lfs_tag_id(lfs->gstate.tag);
-                LFS_DEBUG("Fixing move while relocating "
-                        "{0x%"PRIx32", 0x%"PRIx32"} 0x%"PRIx16"\n",
-                        pdir.pair[0], pdir.pair[1], moveid);
-                lfs_fs_prepmove(lfs, 0x3ff, NULL);
-            }
-
-            // replace bad pair, either we clean up desync, or no desync occured
-            lpair[0] = pdir.pair[0];
-            lpair[1] = pdir.pair[1];
-            lfs_pair_tole32(ldir.pair);
-            state = lfs_dir_relocatingcommit(lfs, &pdir, lpair, LFS_MKATTRS(
-                        {LFS_MKTAG_IF(moveid != 0x3ff,
-                            LFS_TYPE_DELETE, moveid, 0), NULL},
-                        {LFS_MKTAG(LFS_TYPE_TAIL + pdir.split, 0x3ff, 8),
-                            ldir.pair}),
-                    NULL);
-            lfs_pair_fromle32(ldir.pair);
-            if (state < 0) {
-                return state;
-            }
-
-            ldir = pdir;
-        }
-    }
-
-    return orphans ? LFS_OK_ORPHANED : 0;
-}
-#endif
-
-#ifndef LFS_READONLY
-static int lfs_dir_commit(lfs_t *lfs, lfs_mdir_t *dir,
-        const struct lfs_mattr *attrs, int attrcount) {
-    int orphans = lfs_dir_orphaningcommit(lfs, dir, attrs, attrcount);
-    if (orphans < 0) {
-        return orphans;
-    }
-
-    if (orphans) {
-        // make sure we've removed all orphans, this is a noop if there
-        // are none, but if we had nested blocks failures we may have
-        // created some
-        int err = lfs_fs_deorphan(lfs, false);
-        if (err) {
-            return err;
-        }
-    }
-
     return 0;
 }
 #endif
@@ -2611,7 +2063,7 @@ static int lfs_rawmkdir(lfs_t *lfs, const char *path) {
         return err;
     }
 
-    // current block not end of list?
+    // current block end of list?
     if (cwd.m.split) {
         // update tails, this creates a desync
         err = lfs_fs_preporphans(lfs, +1);
@@ -2771,6 +2223,11 @@ static int lfs_dir_rawseek(lfs_t *lfs, lfs_dir_t *dir, lfs_off_t off) {
     dir->id = (off > 0 && lfs_pair_cmp(dir->head, lfs->root) == 0);
 
     while (off > 0) {
+        int diff = lfs_min(dir->m.count - dir->id, off);
+        dir->id += diff;
+        dir->pos += diff;
+        off -= diff;
+
         if (dir->id == dir->m.count) {
             if (!dir->m.split) {
                 return LFS_ERR_INVAL;
@@ -2783,11 +2240,6 @@ static int lfs_dir_rawseek(lfs_t *lfs, lfs_dir_t *dir, lfs_off_t off) {
 
             dir->id = 0;
         }
-
-        int diff = lfs_min(dir->m.count - dir->id, off);
-        dir->id += diff;
-        dir->pos += diff;
-        off -= diff;
     }
 
     return 0;
@@ -3061,11 +2513,8 @@ static int lfs_file_rawopencfg(lfs_t *lfs, lfs_file_t *file,
                 {LFS_MKTAG(LFS_TYPE_CREATE, file->id, 0), NULL},
                 {LFS_MKTAG(LFS_TYPE_REG, file->id, nlen), path},
                 {LFS_MKTAG(LFS_TYPE_INLINESTRUCT, file->id, 0), NULL}));
-
-        // it may happen that the file name doesn't fit in the metadata blocks, e.g., a 256 byte file name will
-        // not fit in a 128 byte block.
-        err = (err == LFS_ERR_NOSPC) ? LFS_ERR_NAMETOOLONG : err;
         if (err) {
+            err = LFS_ERR_NAMETOOLONG;
             goto cleanup;
         }
 
@@ -3170,14 +2619,12 @@ cleanup:
     return err;
 }
 
-#ifndef LFS_NO_MALLOC
 static int lfs_file_rawopen(lfs_t *lfs, lfs_file_t *file,
         const char *path, int flags) {
     static const struct lfs_file_config defaults = {0};
     int err = lfs_file_rawopencfg(lfs, file, path, flags, &defaults);
     return err;
 }
-#endif
 
 static int lfs_file_rawclose(lfs_t *lfs, lfs_file_t *file) {
 #ifndef LFS_READONLY
@@ -3283,6 +2730,7 @@ static int lfs_file_outline(lfs_t *lfs, lfs_file_t *file) {
 }
 #endif
 
+#ifndef LFS_READONLY
 static int lfs_file_flush(lfs_t *lfs, lfs_file_t *file) {
     if (file->flags & LFS_F_READING) {
         if (!(file->flags & LFS_F_INLINE)) {
@@ -3291,7 +2739,6 @@ static int lfs_file_flush(lfs_t *lfs, lfs_file_t *file) {
         file->flags &= ~LFS_F_READING;
     }
 
-#ifndef LFS_READONLY
     if (file->flags & LFS_F_WRITING) {
         lfs_off_t pos = file->pos;
 
@@ -3310,12 +2757,12 @@ static int lfs_file_flush(lfs_t *lfs, lfs_file_t *file) {
                 // copy over a byte at a time, leave it up to caching
                 // to make this efficient
                 uint8_t data;
-                lfs_ssize_t res = lfs_file_flushedread(lfs, &orig, &data, 1);
+                lfs_ssize_t res = lfs_file_rawread(lfs, &orig, &data, 1);
                 if (res < 0) {
                     return res;
                 }
 
-                res = lfs_file_flushedwrite(lfs, file, &data, 1);
+                res = lfs_file_rawwrite(lfs, file, &data, 1);
                 if (res < 0) {
                     return res;
                 }
@@ -3358,10 +2805,10 @@ relocate:
 
         file->pos = pos;
     }
-#endif
 
     return 0;
 }
+#endif
 
 #ifndef LFS_READONLY
 static int lfs_file_rawsync(lfs_t *lfs, lfs_file_t *file) {
@@ -3416,11 +2863,23 @@ static int lfs_file_rawsync(lfs_t *lfs, lfs_file_t *file) {
 }
 #endif
 
-static lfs_ssize_t lfs_file_flushedread(lfs_t *lfs, lfs_file_t *file,
+static lfs_ssize_t lfs_file_rawread(lfs_t *lfs, lfs_file_t *file,
         void *buffer, lfs_size_t size) {
+    LFS_ASSERT((file->flags & LFS_O_RDONLY) == LFS_O_RDONLY);
+
     uint8_t *data = buffer;
     lfs_size_t nsize = size;
 
+#ifndef LFS_READONLY
+    if (file->flags & LFS_F_WRITING) {
+        // flush out any writes
+        int err = lfs_file_flush(lfs, file);
+        if (err) {
+            return err;
+        }
+    }
+#endif
+
     if (file->pos >= file->ctz.size) {
         // eof if past end
         return 0;
@@ -3477,29 +2936,43 @@ static lfs_ssize_t lfs_file_flushedread(lfs_t *lfs, lfs_file_t *file,
     return size;
 }
 
-static lfs_ssize_t lfs_file_rawread(lfs_t *lfs, lfs_file_t *file,
-        void *buffer, lfs_size_t size) {
-    LFS_ASSERT((file->flags & LFS_O_RDONLY) == LFS_O_RDONLY);
-
 #ifndef LFS_READONLY
-    if (file->flags & LFS_F_WRITING) {
-        // flush out any writes
+static lfs_ssize_t lfs_file_rawwrite(lfs_t *lfs, lfs_file_t *file,
+        const void *buffer, lfs_size_t size) {
+    LFS_ASSERT((file->flags & LFS_O_WRONLY) == LFS_O_WRONLY);
+
+    const uint8_t *data = buffer;
+    lfs_size_t nsize = size;
+
+    if (file->flags & LFS_F_READING) {
+        // drop any reads
         int err = lfs_file_flush(lfs, file);
         if (err) {
             return err;
         }
     }
-#endif
 
-    return lfs_file_flushedread(lfs, file, buffer, size);
-}
+    if ((file->flags & LFS_O_APPEND) && file->pos < file->ctz.size) {
+        file->pos = file->ctz.size;
+    }
+
+    if (file->pos + size > lfs->file_max) {
+        // Larger than file limit?
+        return LFS_ERR_FBIG;
+    }
 
+    if (!(file->flags & LFS_F_WRITING) && file->pos > file->ctz.size) {
+        // fill with zeros
+        lfs_off_t pos = file->pos;
+        file->pos = file->ctz.size;
 
-#ifndef LFS_READONLY
-static lfs_ssize_t lfs_file_flushedwrite(lfs_t *lfs, lfs_file_t *file,
-        const void *buffer, lfs_size_t size) {
-    const uint8_t *data = buffer;
-    lfs_size_t nsize = size;
+        while (file->pos < pos) {
+            lfs_ssize_t res = lfs_file_rawwrite(lfs, file, &(uint8_t){0}, 1);
+            if (res < 0) {
+                return res;
+            }
+        }
+    }
 
     if ((file->flags & LFS_F_INLINE) &&
             lfs_max(file->pos+nsize, file->ctz.size) >
@@ -3524,7 +2997,7 @@ static lfs_ssize_t lfs_file_flushedwrite(lfs_t *lfs, lfs_file_t *file,
                     // find out which block we're extending from
                     int err = lfs_ctz_find(lfs, NULL, &file->cache,
                             file->ctz.head, file->ctz.size,
-                            file->pos-1, &file->block, &(lfs_off_t){0});
+                            file->pos-1, &file->block, &file->off);
                     if (err) {
                         file->flags |= LFS_F_ERRED;
                         return err;
@@ -3581,50 +3054,8 @@ relocate:
         lfs_alloc_ack(lfs);
     }
 
-    return size;
-}
-
-static lfs_ssize_t lfs_file_rawwrite(lfs_t *lfs, lfs_file_t *file,
-        const void *buffer, lfs_size_t size) {
-    LFS_ASSERT((file->flags & LFS_O_WRONLY) == LFS_O_WRONLY);
-
-    if (file->flags & LFS_F_READING) {
-        // drop any reads
-        int err = lfs_file_flush(lfs, file);
-        if (err) {
-            return err;
-        }
-    }
-
-    if ((file->flags & LFS_O_APPEND) && file->pos < file->ctz.size) {
-        file->pos = file->ctz.size;
-    }
-
-    if (file->pos + size > lfs->file_max) {
-        // Larger than file limit?
-        return LFS_ERR_FBIG;
-    }
-
-    if (!(file->flags & LFS_F_WRITING) && file->pos > file->ctz.size) {
-        // fill with zeros
-        lfs_off_t pos = file->pos;
-        file->pos = file->ctz.size;
-
-        while (file->pos < pos) {
-            lfs_ssize_t res = lfs_file_flushedwrite(lfs, file, &(uint8_t){0}, 1);
-            if (res < 0) {
-                return res;
-            }
-        }
-    }
-
-    lfs_ssize_t nsize = lfs_file_flushedwrite(lfs, file, buffer, size);
-    if (nsize < 0) {
-        return nsize;
-    }
-
     file->flags &= ~LFS_F_ERRED;
-    return nsize;
+    return size;
 }
 #endif
 
@@ -3635,18 +3066,9 @@ static lfs_soff_t lfs_file_rawseek(lfs_t *lfs, lfs_file_t *file,
     if (whence == LFS_SEEK_SET) {
         npos = off;
     } else if (whence == LFS_SEEK_CUR) {
-        if ((lfs_soff_t)file->pos + off < 0) {
-            return LFS_ERR_INVAL;
-        } else {
-            npos = file->pos + off;
-        }
+        npos = file->pos + off;
     } else if (whence == LFS_SEEK_END) {
-        lfs_soff_t res = lfs_file_rawsize(lfs, file) + off;
-        if (res < 0) {
-            return LFS_ERR_INVAL;
-        } else {
-            npos = res;
-        }
+        npos = lfs_file_rawsize(lfs, file) + off;
     }
 
     if (npos > lfs->file_max) {
@@ -3659,32 +3081,13 @@ static lfs_soff_t lfs_file_rawseek(lfs_t *lfs, lfs_file_t *file,
         return npos;
     }
 
-    // if we're only reading and our new offset is still in the file's cache
-    // we can avoid flushing and needing to reread the data
-    if (
 #ifndef LFS_READONLY
-        !(file->flags & LFS_F_WRITING)
-#else
-        true
-#endif
-            ) {
-        int oindex = lfs_ctz_index(lfs, &(lfs_off_t){file->pos});
-        lfs_off_t noff = npos;
-        int nindex = lfs_ctz_index(lfs, &noff);
-        if (oindex == nindex
-                && noff >= file->cache.off
-                && noff < file->cache.off + file->cache.size) {
-            file->pos = npos;
-            file->off = noff;
-            return npos;
-        }
-    }
-
     // write out everything beforehand, may be noop if rdonly
     int err = lfs_file_flush(lfs, file);
     if (err) {
         return err;
     }
+#endif
 
     // update pos
     file->pos = npos;
@@ -3695,62 +3098,33 @@ static lfs_soff_t lfs_file_rawseek(lfs_t *lfs, lfs_file_t *file,
 static int lfs_file_rawtruncate(lfs_t *lfs, lfs_file_t *file, lfs_off_t size) {
     LFS_ASSERT((file->flags & LFS_O_WRONLY) == LFS_O_WRONLY);
 
-    if (size > LFS_FILE_MAX) {
-        return LFS_ERR_INVAL;
-    }
-
-    lfs_off_t pos = file->pos;
-    lfs_off_t oldsize = lfs_file_rawsize(lfs, file);
-    if (size < oldsize) {
-        // revert to inline file?
-        if (size <= lfs_min(0x3fe, lfs_min(
-                lfs->cfg->cache_size,
-                (lfs->cfg->metadata_max ?
-                    lfs->cfg->metadata_max : lfs->cfg->block_size) / 8))) {
-            // flush+seek to head
-            lfs_soff_t res = lfs_file_rawseek(lfs, file, 0, LFS_SEEK_SET);
-            if (res < 0) {
-                return (int)res;
-            }
-
-            // read our data into rcache temporarily
-            lfs_cache_drop(lfs, &lfs->rcache);
-            res = lfs_file_flushedread(lfs, file,
-                    lfs->rcache.buffer, size);
-            if (res < 0) {
-                return (int)res;
-            }
-
-            file->ctz.head = LFS_BLOCK_INLINE;
-            file->ctz.size = size;
-            file->flags |= LFS_F_DIRTY | LFS_F_READING | LFS_F_INLINE;
-            file->cache.block = file->ctz.head;
-            file->cache.off = 0;
-            file->cache.size = lfs->cfg->cache_size;
-            memcpy(file->cache.buffer, lfs->rcache.buffer, size);
-
-        } else {
-            // need to flush since directly changing metadata
-            int err = lfs_file_flush(lfs, file);
-            if (err) {
-                return err;
-            }
+    if (size > LFS_FILE_MAX) {
+        return LFS_ERR_INVAL;
+    }
 
-            // lookup new head in ctz skip list
-            err = lfs_ctz_find(lfs, NULL, &file->cache,
-                    file->ctz.head, file->ctz.size,
-                    size-1, &file->block, &(lfs_off_t){0});
-            if (err) {
-                return err;
-            }
+    lfs_off_t pos = file->pos;
+    lfs_off_t oldsize = lfs_file_rawsize(lfs, file);
+    if (size < oldsize) {
+        // need to flush since directly changing metadata
+        int err = lfs_file_flush(lfs, file);
+        if (err) {
+            return err;
+        }
 
-            // need to set pos/block/off consistently so seeking back to
-            // the old position does not get confused
-            file->pos = size;
-            file->ctz.head = file->block;
-            file->ctz.size = size;
-            file->flags |= LFS_F_DIRTY | LFS_F_READING;
+        // lookup new head in ctz skip list
+        err = lfs_ctz_find(lfs, NULL, &file->cache,
+                file->ctz.head, file->ctz.size,
+                size, &file->block, &file->off);
+        if (err) {
+            return err;
         }
+
+        // need to set pos/block/off consistently so seeking back to
+        // the old position does not get confused
+        file->pos = size;
+        file->ctz.head = file->block;
+        file->ctz.size = size;
+        file->flags |= LFS_F_DIRTY | LFS_F_READING;
     } else if (size > oldsize) {
         // flush+seek if not already at end
         lfs_soff_t res = lfs_file_rawseek(lfs, file, 0, LFS_SEEK_END);
@@ -4007,8 +3381,7 @@ static int lfs_rawrename(lfs_t *lfs, const char *oldpath, const char *newpath) {
     }
 
     lfs->mlist = prevdir.next;
-    if (prevtag != LFS_ERR_NOENT
-            && lfs_tag_type3(prevtag) == LFS_TYPE_DIR) {
+    if (prevtag != LFS_ERR_NOENT && lfs_tag_type3(prevtag) == LFS_TYPE_DIR) {
         // fix orphan
         err = lfs_fs_preporphans(lfs, -1);
         if (err) {
@@ -4108,24 +3481,8 @@ static int lfs_rawremoveattr(lfs_t *lfs, const char *path, uint8_t type) {
 /// Filesystem operations ///
 static int lfs_init(lfs_t *lfs, const struct lfs_config *cfg) {
     lfs->cfg = cfg;
-    lfs->block_count = cfg->block_count;  // May be 0
     int err = 0;
 
-#ifdef LFS_MULTIVERSION
-    // this driver only supports minor version < current minor version
-    LFS_ASSERT(!lfs->cfg->disk_version || (
-            (0xffff & (lfs->cfg->disk_version >> 16))
-                    == LFS_DISK_VERSION_MAJOR
-                && (0xffff & (lfs->cfg->disk_version >> 0))
-                    <= LFS_DISK_VERSION_MINOR));
-#endif
-
-    // check that bool is a truthy-preserving type
-    //
-    // note the most common reason for this failure is a before-c99 compiler,
-    // which littlefs currently does not support
-    LFS_ASSERT((bool)0x80000000);
-
     // validate that the lfs-cfg sizes were initiated properly before
     // performing any arithmetic logics with them
     LFS_ASSERT(lfs->cfg->read_size != 0);
@@ -4138,10 +3495,7 @@ static int lfs_init(lfs_t *lfs, const struct lfs_config *cfg) {
     LFS_ASSERT(lfs->cfg->cache_size % lfs->cfg->prog_size == 0);
     LFS_ASSERT(lfs->cfg->block_size % lfs->cfg->cache_size == 0);
 
-    // check that the block size is large enough to fit all ctz pointers
-    LFS_ASSERT(lfs->cfg->block_size >= 128);
-    // this is the exact calculation for all ctz pointers, if this fails
-    // and the simpler assert above does not, math must be broken
+    // check that the block size is large enough to fit ctz pointers
     LFS_ASSERT(4*lfs_npw2(0xffffffff / (lfs->cfg->block_size-2*4))
             <= lfs->cfg->block_size);
 
@@ -4251,8 +3605,6 @@ static int lfs_deinit(lfs_t *lfs) {
     return 0;
 }
 
-
-
 #ifndef LFS_READONLY
 static int lfs_rawformat(lfs_t *lfs, const struct lfs_config *cfg) {
     int err = 0;
@@ -4262,13 +3614,11 @@ static int lfs_rawformat(lfs_t *lfs, const struct lfs_config *cfg) {
             return err;
         }
 
-        LFS_ASSERT(cfg->block_count != 0);
-
         // create free lookahead
         memset(lfs->free.buffer, 0, lfs->cfg->lookahead_size);
         lfs->free.off = 0;
         lfs->free.size = lfs_min(8*lfs->cfg->lookahead_size,
-                lfs->block_count);
+                lfs->cfg->block_count);
         lfs->free.i = 0;
         lfs_alloc_ack(lfs);
 
@@ -4281,9 +3631,9 @@ static int lfs_rawformat(lfs_t *lfs, const struct lfs_config *cfg) {
 
         // write one superblock
         lfs_superblock_t superblock = {
-            .version     = lfs_fs_disk_version(lfs),
+            .version     = LFS_DISK_VERSION,
             .block_size  = lfs->cfg->block_size,
-            .block_count = lfs->block_count,
+            .block_count = lfs->cfg->block_count,
             .name_max    = lfs->name_max,
             .file_max    = lfs->file_max,
             .attr_max    = lfs->attr_max,
@@ -4329,23 +3679,14 @@ static int lfs_rawmount(lfs_t *lfs, const struct lfs_config *cfg) {
 
     // scan directory blocks for superblock and any global updates
     lfs_mdir_t dir = {.tail = {0, 1}};
-    lfs_block_t tortoise[2] = {LFS_BLOCK_NULL, LFS_BLOCK_NULL};
-    lfs_size_t tortoise_i = 1;
-    lfs_size_t tortoise_period = 1;
+    lfs_block_t cycle = 0;
     while (!lfs_pair_isnull(dir.tail)) {
-        // detect cycles with Brent's algorithm
-        if (lfs_pair_issync(dir.tail, tortoise)) {
-            LFS_WARN("Cycle detected in tail list");
+        if (cycle >= lfs->cfg->block_count/2) {
+            // loop detected
             err = LFS_ERR_CORRUPT;
             goto cleanup;
         }
-        if (tortoise_i == tortoise_period) {
-            tortoise[0] = dir.tail[0];
-            tortoise[1] = dir.tail[1];
-            tortoise_i = 0;
-            tortoise_period *= 2;
-        }
-        tortoise_i += 1;
+        cycle += 1;
 
         // fetch next block in tail list
         lfs_stag_t tag = lfs_dir_fetchmatch(lfs, &dir, dir.tail,
@@ -4379,33 +3720,14 @@ static int lfs_rawmount(lfs_t *lfs, const struct lfs_config *cfg) {
             // check version
             uint16_t major_version = (0xffff & (superblock.version >> 16));
             uint16_t minor_version = (0xffff & (superblock.version >>  0));
-            if (major_version != lfs_fs_disk_version_major(lfs)
-                    || minor_version > lfs_fs_disk_version_minor(lfs)) {
-                LFS_ERROR("Invalid version "
-                        "v%"PRIu16".%"PRIu16" != v%"PRIu16".%"PRIu16,
-                        major_version,
-                        minor_version,
-                        lfs_fs_disk_version_major(lfs),
-                        lfs_fs_disk_version_minor(lfs));
+            if ((major_version != LFS_DISK_VERSION_MAJOR ||
+                 minor_version > LFS_DISK_VERSION_MINOR)) {
+                LFS_ERROR("Invalid version v%"PRIu16".%"PRIu16,
+                        major_version, minor_version);
                 err = LFS_ERR_INVAL;
                 goto cleanup;
             }
 
-            // found older minor version? set an in-device only bit in the
-            // gstate so we know we need to rewrite the superblock before
-            // the first write
-            if (minor_version < lfs_fs_disk_version_minor(lfs)) {
-                LFS_DEBUG("Found older minor version "
-                        "v%"PRIu16".%"PRIu16" < v%"PRIu16".%"PRIu16,
-                        major_version,
-                        minor_version,
-                        lfs_fs_disk_version_major(lfs),
-                        lfs_fs_disk_version_minor(lfs));
-                // note this bit is reserved on disk, so fetching more gstate
-                // will not interfere here
-                lfs_fs_prepsuperblock(lfs, true);
-            }
-
             // check superblock configuration
             if (superblock.name_max) {
                 if (superblock.name_max > lfs->name_max) {
@@ -4439,24 +3761,6 @@ static int lfs_rawmount(lfs_t *lfs, const struct lfs_config *cfg) {
 
                 lfs->attr_max = superblock.attr_max;
             }
-
-            // this is where we get the block_count from disk if block_count=0
-            if (lfs->cfg->block_count
-                    && superblock.block_count != lfs->cfg->block_count) {
-                LFS_ERROR("Invalid block count (%"PRIu32" != %"PRIu32")",
-                        superblock.block_count, lfs->cfg->block_count);
-                err = LFS_ERR_INVAL;
-                goto cleanup;
-            }
-
-            lfs->block_count = superblock.block_count;
-
-            if (superblock.block_size != lfs->cfg->block_size) {
-                LFS_ERROR("Invalid block size (%"PRIu32" != %"PRIu32")",
-                        superblock.block_size, lfs->cfg->block_size);
-                err = LFS_ERR_INVAL;
-                goto cleanup;
-            }
         }
 
         // has gstate?
@@ -4466,6 +3770,12 @@ static int lfs_rawmount(lfs_t *lfs, const struct lfs_config *cfg) {
         }
     }
 
+    // found superblock?
+    if (lfs_pair_isnull(lfs->root)) {
+        err = LFS_ERR_INVAL;
+        goto cleanup;
+    }
+
     // update littlefs with gstate
     if (!lfs_gstate_iszero(&lfs->gstate)) {
         LFS_DEBUG("Found pending gstate 0x%08"PRIx32"%08"PRIx32"%08"PRIx32,
@@ -4478,7 +3788,7 @@ static int lfs_rawmount(lfs_t *lfs, const struct lfs_config *cfg) {
 
     // setup free lookahead, to distribute allocations uniformly across
     // boots, we start the allocator at a random location
-    lfs->free.off = lfs->seed % lfs->block_count;
+    lfs->free.off = lfs->seed % lfs->cfg->block_count;
     lfs_alloc_drop(lfs);
 
     return 0;
@@ -4494,46 +3804,6 @@ static int lfs_rawunmount(lfs_t *lfs) {
 
 
 /// Filesystem filesystem operations ///
-static int lfs_fs_rawstat(lfs_t *lfs, struct lfs_fsinfo *fsinfo) {
-    // if the superblock is up-to-date, we must be on the most recent
-    // minor version of littlefs
-    if (!lfs_gstate_needssuperblock(&lfs->gstate)) {
-        fsinfo->disk_version = lfs_fs_disk_version(lfs);
-
-    // otherwise we need to read the minor version on disk
-    } else {
-        // fetch the superblock
-        lfs_mdir_t dir;
-        int err = lfs_dir_fetch(lfs, &dir, lfs->root);
-        if (err) {
-            return err;
-        }
-
-        lfs_superblock_t superblock;
-        lfs_stag_t tag = lfs_dir_get(lfs, &dir, LFS_MKTAG(0x7ff, 0x3ff, 0),
-                LFS_MKTAG(LFS_TYPE_INLINESTRUCT, 0, sizeof(superblock)),
-                &superblock);
-        if (tag < 0) {
-            return tag;
-        }
-        lfs_superblock_fromle32(&superblock);
-
-        // read the on-disk version
-        fsinfo->disk_version = superblock.version;
-    }
-
-    // filesystem geometry
-    fsinfo->block_size = lfs->cfg->block_size;
-    fsinfo->block_count = lfs->block_count;
-
-    // other on-disk configuration, we cache all of these for internal use
-    fsinfo->name_max = lfs->name_max;
-    fsinfo->file_max = lfs->file_max;
-    fsinfo->attr_max = lfs->attr_max;
-
-    return 0;
-}
-
 int lfs_fs_rawtraverse(lfs_t *lfs,
         int (*cb)(void *data, lfs_block_t block), void *data,
         bool includeorphans) {
@@ -4553,22 +3823,13 @@ int lfs_fs_rawtraverse(lfs_t *lfs,
     }
 #endif
 
-    lfs_block_t tortoise[2] = {LFS_BLOCK_NULL, LFS_BLOCK_NULL};
-    lfs_size_t tortoise_i = 1;
-    lfs_size_t tortoise_period = 1;
+    lfs_block_t cycle = 0;
     while (!lfs_pair_isnull(dir.tail)) {
-        // detect cycles with Brent's algorithm
-        if (lfs_pair_issync(dir.tail, tortoise)) {
-            LFS_WARN("Cycle detected in tail list");
+        if (cycle >= lfs->cfg->block_count/2) {
+            // loop detected
             return LFS_ERR_CORRUPT;
         }
-        if (tortoise_i == tortoise_period) {
-            tortoise[0] = dir.tail[0];
-            tortoise[1] = dir.tail[1];
-            tortoise_i = 0;
-            tortoise_period *= 2;
-        }
-        tortoise_i += 1;
+        cycle += 1;
 
         for (int i = 0; i < 2; i++) {
             int err = cb(data, dir.tail[i]);
@@ -4647,22 +3908,13 @@ static int lfs_fs_pred(lfs_t *lfs,
     // iterate over all directory directory entries
     pdir->tail[0] = 0;
     pdir->tail[1] = 1;
-    lfs_block_t tortoise[2] = {LFS_BLOCK_NULL, LFS_BLOCK_NULL};
-    lfs_size_t tortoise_i = 1;
-    lfs_size_t tortoise_period = 1;
+    lfs_block_t cycle = 0;
     while (!lfs_pair_isnull(pdir->tail)) {
-        // detect cycles with Brent's algorithm
-        if (lfs_pair_issync(pdir->tail, tortoise)) {
-            LFS_WARN("Cycle detected in tail list");
+        if (cycle >= lfs->cfg->block_count/2) {
+            // loop detected
             return LFS_ERR_CORRUPT;
         }
-        if (tortoise_i == tortoise_period) {
-            tortoise[0] = pdir->tail[0];
-            tortoise[1] = pdir->tail[1];
-            tortoise_i = 0;
-            tortoise_period *= 2;
-        }
-        tortoise_i += 1;
+        cycle += 1;
 
         if (lfs_pair_cmp(pdir->tail, pair) == 0) {
             return 0;
@@ -4712,22 +3964,13 @@ static lfs_stag_t lfs_fs_parent(lfs_t *lfs, const lfs_block_t pair[2],
     // use fetchmatch with callback to find pairs
     parent->tail[0] = 0;
     parent->tail[1] = 1;
-    lfs_block_t tortoise[2] = {LFS_BLOCK_NULL, LFS_BLOCK_NULL};
-    lfs_size_t tortoise_i = 1;
-    lfs_size_t tortoise_period = 1;
+    lfs_block_t cycle = 0;
     while (!lfs_pair_isnull(parent->tail)) {
-        // detect cycles with Brent's algorithm
-        if (lfs_pair_issync(parent->tail, tortoise)) {
-            LFS_WARN("Cycle detected in tail list");
+        if (cycle >= lfs->cfg->block_count/2) {
+            // loop detected
             return LFS_ERR_CORRUPT;
         }
-        if (tortoise_i == tortoise_period) {
-            tortoise[0] = parent->tail[0];
-            tortoise[1] = parent->tail[1];
-            tortoise_i = 0;
-            tortoise_period *= 2;
-        }
-        tortoise_i += 1;
+        cycle += 1;
 
         lfs_stag_t tag = lfs_dir_fetchmatch(lfs, parent, parent->tail,
                 LFS_MKTAG(0x7ff, 0, 0x3ff),
@@ -4744,15 +3987,112 @@ static lfs_stag_t lfs_fs_parent(lfs_t *lfs, const lfs_block_t pair[2],
 }
 #endif
 
-static void lfs_fs_prepsuperblock(lfs_t *lfs, bool needssuperblock) {
-    lfs->gstate.tag = (lfs->gstate.tag & ~LFS_MKTAG(0, 0, 0x200))
-            | (uint32_t)needssuperblock << 9;
+#ifndef LFS_READONLY
+static int lfs_fs_relocate(lfs_t *lfs,
+        const lfs_block_t oldpair[2], lfs_block_t newpair[2]) {
+    // update internal root
+    if (lfs_pair_cmp(oldpair, lfs->root) == 0) {
+        lfs->root[0] = newpair[0];
+        lfs->root[1] = newpair[1];
+    }
+
+    // update internally tracked dirs
+    for (struct lfs_mlist *d = lfs->mlist; d; d = d->next) {
+        if (lfs_pair_cmp(oldpair, d->m.pair) == 0) {
+            d->m.pair[0] = newpair[0];
+            d->m.pair[1] = newpair[1];
+        }
+
+        if (d->type == LFS_TYPE_DIR &&
+                lfs_pair_cmp(oldpair, ((lfs_dir_t*)d)->head) == 0) {
+            ((lfs_dir_t*)d)->head[0] = newpair[0];
+            ((lfs_dir_t*)d)->head[1] = newpair[1];
+        }
+    }
+
+    // find parent
+    lfs_mdir_t parent;
+    lfs_stag_t tag = lfs_fs_parent(lfs, oldpair, &parent);
+    if (tag < 0 && tag != LFS_ERR_NOENT) {
+        return tag;
+    }
+
+    if (tag != LFS_ERR_NOENT) {
+        // update disk, this creates a desync
+        int err = lfs_fs_preporphans(lfs, +1);
+        if (err) {
+            return err;
+        }
+
+        // fix pending move in this pair? this looks like an optimization but
+        // is in fact _required_ since relocating may outdate the move.
+        uint16_t moveid = 0x3ff;
+        if (lfs_gstate_hasmovehere(&lfs->gstate, parent.pair)) {
+            moveid = lfs_tag_id(lfs->gstate.tag);
+            LFS_DEBUG("Fixing move while relocating "
+                    "{0x%"PRIx32", 0x%"PRIx32"} 0x%"PRIx16"\n",
+                    parent.pair[0], parent.pair[1], moveid);
+            lfs_fs_prepmove(lfs, 0x3ff, NULL);
+            if (moveid < lfs_tag_id(tag)) {
+                tag -= LFS_MKTAG(0, 1, 0);
+            }
+        }
+
+        lfs_pair_tole32(newpair);
+        err = lfs_dir_commit(lfs, &parent, LFS_MKATTRS(
+                {LFS_MKTAG_IF(moveid != 0x3ff,
+                    LFS_TYPE_DELETE, moveid, 0), NULL},
+                {tag, newpair}));
+        lfs_pair_fromle32(newpair);
+        if (err) {
+            return err;
+        }
+
+        // next step, clean up orphans
+        err = lfs_fs_preporphans(lfs, -1);
+        if (err) {
+            return err;
+        }
+    }
+
+    // find pred
+    int err = lfs_fs_pred(lfs, oldpair, &parent);
+    if (err && err != LFS_ERR_NOENT) {
+        return err;
+    }
+
+    // if we can't find dir, it must be new
+    if (err != LFS_ERR_NOENT) {
+        // fix pending move in this pair? this looks like an optimization but
+        // is in fact _required_ since relocating may outdate the move.
+        uint16_t moveid = 0x3ff;
+        if (lfs_gstate_hasmovehere(&lfs->gstate, parent.pair)) {
+            moveid = lfs_tag_id(lfs->gstate.tag);
+            LFS_DEBUG("Fixing move while relocating "
+                    "{0x%"PRIx32", 0x%"PRIx32"} 0x%"PRIx16"\n",
+                    parent.pair[0], parent.pair[1], moveid);
+            lfs_fs_prepmove(lfs, 0x3ff, NULL);
+        }
+
+        // replace bad pair, either we clean up desync, or no desync occured
+        lfs_pair_tole32(newpair);
+        err = lfs_dir_commit(lfs, &parent, LFS_MKATTRS(
+                {LFS_MKTAG_IF(moveid != 0x3ff,
+                    LFS_TYPE_DELETE, moveid, 0), NULL},
+                {LFS_MKTAG(LFS_TYPE_TAIL + parent.split, 0x3ff, 8), newpair}));
+        lfs_pair_fromle32(newpair);
+        if (err) {
+            return err;
+        }
+    }
+
+    return 0;
 }
+#endif
 
 #ifndef LFS_READONLY
 static int lfs_fs_preporphans(lfs_t *lfs, int8_t orphans) {
-    LFS_ASSERT(lfs_tag_size(lfs->gstate.tag) > 0x000 || orphans >= 0);
-    LFS_ASSERT(lfs_tag_size(lfs->gstate.tag) < 0x1ff || orphans <= 0);
+    LFS_ASSERT(lfs_tag_size(lfs->gstate.tag) > 0 || orphans >= 0);
     lfs->gstate.tag += orphans;
     lfs->gstate.tag = ((lfs->gstate.tag & ~LFS_MKTAG(0x800, 0, 0)) |
             ((uint32_t)lfs_gstate_hasorphans(&lfs->gstate) << 31));
@@ -4771,45 +4111,6 @@ static void lfs_fs_prepmove(lfs_t *lfs,
 }
 #endif
 
-#ifndef LFS_READONLY
-static int lfs_fs_desuperblock(lfs_t *lfs) {
-    if (!lfs_gstate_needssuperblock(&lfs->gstate)) {
-        return 0;
-    }
-
-    LFS_DEBUG("Rewriting superblock {0x%"PRIx32", 0x%"PRIx32"}",
-            lfs->root[0],
-            lfs->root[1]);
-
-    lfs_mdir_t root;
-    int err = lfs_dir_fetch(lfs, &root, lfs->root);
-    if (err) {
-        return err;
-    }
-
-    // write a new superblock
-    lfs_superblock_t superblock = {
-        .version     = lfs_fs_disk_version(lfs),
-        .block_size  = lfs->cfg->block_size,
-        .block_count = lfs->block_count,
-        .name_max    = lfs->name_max,
-        .file_max    = lfs->file_max,
-        .attr_max    = lfs->attr_max,
-    };
-
-    lfs_superblock_tole32(&superblock);
-    err = lfs_dir_commit(lfs, &root, LFS_MKATTRS(
-            {LFS_MKTAG(LFS_TYPE_INLINESTRUCT, 0, sizeof(superblock)),
-                &superblock}));
-    if (err) {
-        return err;
-    }
-
-    lfs_fs_prepsuperblock(lfs, false);
-    return 0;
-}
-#endif
-
 #ifndef LFS_READONLY
 static int lfs_fs_demove(lfs_t *lfs) {
     if (!lfs_gstate_hasmove(&lfs->gdisk)) {
@@ -4822,10 +4123,6 @@ static int lfs_fs_demove(lfs_t *lfs) {
             lfs->gdisk.pair[1],
             lfs_tag_id(lfs->gdisk.tag));
 
-    // no other gstate is supported at this time, so if we found something else
-    // something most likely went wrong in gstate calculation
-    LFS_ASSERT(lfs_tag_type3(lfs->gdisk.tag) == LFS_TYPE_DELETE);
-
     // fetch and delete the moved entry
     lfs_mdir_t movedir;
     int err = lfs_dir_fetch(lfs, &movedir, lfs->gdisk.pair);
@@ -4847,129 +4144,73 @@ static int lfs_fs_demove(lfs_t *lfs) {
 #endif
 
 #ifndef LFS_READONLY
-static int lfs_fs_deorphan(lfs_t *lfs, bool powerloss) {
+static int lfs_fs_deorphan(lfs_t *lfs) {
     if (!lfs_gstate_hasorphans(&lfs->gstate)) {
         return 0;
     }
 
-    // Check for orphans in two separate passes:
-    // - 1 for half-orphans (relocations)
-    // - 2 for full-orphans (removes/renames)
-    //
-    // Two separate passes are needed as half-orphans can contain outdated
-    // references to full-orphans, effectively hiding them from the deorphan
-    // search.
-    //
-    int pass = 0;
-    while (pass < 2) {
-        // Fix any orphans
-        lfs_mdir_t pdir = {.split = true, .tail = {0, 1}};
-        lfs_mdir_t dir;
-        bool moreorphans = false;
-
-        // iterate over all directory directory entries
-        while (!lfs_pair_isnull(pdir.tail)) {
-            int err = lfs_dir_fetch(lfs, &dir, pdir.tail);
-            if (err) {
-                return err;
-            }
-
-            // check head blocks for orphans
-            if (!pdir.split) {
-                // check if we have a parent
-                lfs_mdir_t parent;
-                lfs_stag_t tag = lfs_fs_parent(lfs, pdir.tail, &parent);
-                if (tag < 0 && tag != LFS_ERR_NOENT) {
-                    return tag;
-                }
+    // Fix any orphans
+    lfs_mdir_t pdir = {.split = true, .tail = {0, 1}};
+    lfs_mdir_t dir;
 
-                if (pass == 0 && tag != LFS_ERR_NOENT) {
-                    lfs_block_t pair[2];
-                    lfs_stag_t state = lfs_dir_get(lfs, &parent,
-                            LFS_MKTAG(0x7ff, 0x3ff, 0), tag, pair);
-                    if (state < 0) {
-                        return state;
-                    }
-                    lfs_pair_fromle32(pair);
-
-                    if (!lfs_pair_issync(pair, pdir.tail)) {
-                        // we have desynced
-                        LFS_DEBUG("Fixing half-orphan "
-                                "{0x%"PRIx32", 0x%"PRIx32"} "
-                                "-> {0x%"PRIx32", 0x%"PRIx32"}",
-                                pdir.tail[0], pdir.tail[1], pair[0], pair[1]);
-
-                        // fix pending move in this pair? this looks like an
-                        // optimization but is in fact _required_ since
-                        // relocating may outdate the move.
-                        uint16_t moveid = 0x3ff;
-                        if (lfs_gstate_hasmovehere(&lfs->gstate, pdir.pair)) {
-                            moveid = lfs_tag_id(lfs->gstate.tag);
-                            LFS_DEBUG("Fixing move while fixing orphans "
-                                    "{0x%"PRIx32", 0x%"PRIx32"} 0x%"PRIx16"\n",
-                                    pdir.pair[0], pdir.pair[1], moveid);
-                            lfs_fs_prepmove(lfs, 0x3ff, NULL);
-                        }
+    // iterate over all directory directory entries
+    while (!lfs_pair_isnull(pdir.tail)) {
+        int err = lfs_dir_fetch(lfs, &dir, pdir.tail);
+        if (err) {
+            return err;
+        }
 
-                        lfs_pair_tole32(pair);
-                        state = lfs_dir_orphaningcommit(lfs, &pdir, LFS_MKATTRS(
-                                {LFS_MKTAG_IF(moveid != 0x3ff,
-                                    LFS_TYPE_DELETE, moveid, 0), NULL},
-                                {LFS_MKTAG(LFS_TYPE_SOFTTAIL, 0x3ff, 8),
-                                    pair}));
-                        lfs_pair_fromle32(pair);
-                        if (state < 0) {
-                            return state;
-                        }
+        // check head blocks for orphans
+        if (!pdir.split) {
+            // check if we have a parent
+            lfs_mdir_t parent;
+            lfs_stag_t tag = lfs_fs_parent(lfs, pdir.tail, &parent);
+            if (tag < 0 && tag != LFS_ERR_NOENT) {
+                return tag;
+            }
 
-                        // did our commit create more orphans?
-                        if (state == LFS_OK_ORPHANED) {
-                            moreorphans = true;
-                        }
+            if (tag == LFS_ERR_NOENT) {
+                // we are an orphan
+                LFS_DEBUG("Fixing orphan {0x%"PRIx32", 0x%"PRIx32"}",
+                        pdir.tail[0], pdir.tail[1]);
 
-                        // refetch tail
-                        continue;
-                    }
+                err = lfs_dir_drop(lfs, &pdir, &dir);
+                if (err) {
+                    return err;
                 }
 
-                // note we only check for full orphans if we may have had a
-                // power-loss, otherwise orphans are created intentionally
-                // during operations such as lfs_mkdir
-                if (pass == 1 && tag == LFS_ERR_NOENT && powerloss) {
-                    // we are an orphan
-                    LFS_DEBUG("Fixing orphan {0x%"PRIx32", 0x%"PRIx32"}",
-                            pdir.tail[0], pdir.tail[1]);
-
-                    // steal state
-                    err = lfs_dir_getgstate(lfs, &dir, &lfs->gdelta);
-                    if (err) {
-                        return err;
-                    }
+                // refetch tail
+                continue;
+            }
 
-                    // steal tail
-                    lfs_pair_tole32(dir.tail);
-                    int state = lfs_dir_orphaningcommit(lfs, &pdir, LFS_MKATTRS(
-                            {LFS_MKTAG(LFS_TYPE_TAIL + dir.split, 0x3ff, 8),
-                                dir.tail}));
-                    lfs_pair_fromle32(dir.tail);
-                    if (state < 0) {
-                        return state;
-                    }
+            lfs_block_t pair[2];
+            lfs_stag_t res = lfs_dir_get(lfs, &parent,
+                    LFS_MKTAG(0x7ff, 0x3ff, 0), tag, pair);
+            if (res < 0) {
+                return res;
+            }
+            lfs_pair_fromle32(pair);
 
-                    // did our commit create more orphans?
-                    if (state == LFS_OK_ORPHANED) {
-                        moreorphans = true;
-                    }
+            if (!lfs_pair_sync(pair, pdir.tail)) {
+                // we have desynced
+                LFS_DEBUG("Fixing half-orphan {0x%"PRIx32", 0x%"PRIx32"} "
+                            "-> {0x%"PRIx32", 0x%"PRIx32"}",
+                        pdir.tail[0], pdir.tail[1], pair[0], pair[1]);
 
-                    // refetch tail
-                    continue;
+                lfs_pair_tole32(pair);
+                err = lfs_dir_commit(lfs, &pdir, LFS_MKATTRS(
+                        {LFS_MKTAG(LFS_TYPE_SOFTTAIL, 0x3ff, 8), pair}));
+                lfs_pair_fromle32(pair);
+                if (err) {
+                    return err;
                 }
-            }
 
-            pdir = dir;
+                // refetch tail
+                continue;
+            }
         }
 
-        pass = moreorphans ? 0 : pass+1;
+        pdir = dir;
     }
 
     // mark orphans as fixed
@@ -4979,51 +4220,16 @@ static int lfs_fs_deorphan(lfs_t *lfs, bool powerloss) {
 
 #ifndef LFS_READONLY
 static int lfs_fs_forceconsistency(lfs_t *lfs) {
-    int err = lfs_fs_desuperblock(lfs);
-    if (err) {
-        return err;
-    }
-
-    err = lfs_fs_demove(lfs);
-    if (err) {
-        return err;
-    }
-
-    err = lfs_fs_deorphan(lfs, true);
+    int err = lfs_fs_demove(lfs);
     if (err) {
         return err;
     }
 
-    return 0;
-}
-#endif
-
-#ifndef LFS_READONLY
-int lfs_fs_rawmkconsistent(lfs_t *lfs) {
-    // lfs_fs_forceconsistency does most of the work here
-    int err = lfs_fs_forceconsistency(lfs);
+    err = lfs_fs_deorphan(lfs);
     if (err) {
         return err;
     }
 
-    // do we have any pending gstate?
-    lfs_gstate_t delta = {0};
-    lfs_gstate_xor(&delta, &lfs->gdisk);
-    lfs_gstate_xor(&delta, &lfs->gstate);
-    if (!lfs_gstate_iszero(&delta)) {
-        // lfs_dir_commit will implicitly write out any pending gstate
-        lfs_mdir_t root;
-        err = lfs_dir_fetch(lfs, &root, lfs->root);
-        if (err) {
-            return err;
-        }
-
-        err = lfs_dir_commit(lfs, &root, NULL, 0);
-        if (err) {
-            return err;
-        }
-    }
-
     return 0;
 }
 #endif
@@ -5045,45 +4251,6 @@ static lfs_ssize_t lfs_fs_rawsize(lfs_t *lfs) {
     return size;
 }
 
-#ifndef LFS_READONLY
-int lfs_fs_rawgrow(lfs_t *lfs, lfs_size_t block_count) {
-    // shrinking is not supported
-    LFS_ASSERT(block_count >= lfs->block_count);
-
-    if (block_count > lfs->block_count) {
-        lfs->block_count = block_count;
-
-        // fetch the root
-        lfs_mdir_t root;
-        int err = lfs_dir_fetch(lfs, &root, lfs->root);
-        if (err) {
-            return err;
-        }
-
-        // update the superblock
-        lfs_superblock_t superblock;
-        lfs_stag_t tag = lfs_dir_get(lfs, &root, LFS_MKTAG(0x7ff, 0x3ff, 0),
-                LFS_MKTAG(LFS_TYPE_INLINESTRUCT, 0, sizeof(superblock)),
-                &superblock);
-        if (tag < 0) {
-            return tag;
-        }
-        lfs_superblock_fromle32(&superblock);
-
-        superblock.block_count = lfs->block_count;
-
-        lfs_superblock_tole32(&superblock);
-        err = lfs_dir_commit(lfs, &root, LFS_MKATTRS(
-                {tag, &superblock}));
-        if (err) {
-            return err;
-        }
-    }
-
-    return 0;
-}
-#endif
-
 #ifdef LFS_MIGRATE
 ////// Migration from littelfs v1 below this //////
 
@@ -5507,10 +4674,6 @@ static int lfs1_unmount(lfs_t *lfs) {
 /// v1 migration ///
 static int lfs_rawmigrate(lfs_t *lfs, const struct lfs_config *cfg) {
     struct lfs1 lfs1;
-
-    // Indeterminate filesystem size not allowed for migration.
-    LFS_ASSERT(cfg->block_count != 0);
-
     int err = lfs1_mount(lfs, &lfs1, cfg);
     if (err) {
         return err;
@@ -5919,7 +5082,6 @@ int lfs_removeattr(lfs_t *lfs, const char *path, uint8_t type) {
 }
 #endif
 
-#ifndef LFS_NO_MALLOC
 int lfs_file_open(lfs_t *lfs, lfs_file_t *file, const char *path, int flags) {
     int err = LFS_LOCK(lfs->cfg);
     if (err) {
@@ -5935,7 +5097,6 @@ int lfs_file_open(lfs_t *lfs, lfs_file_t *file, const char *path, int flags) {
     LFS_UNLOCK(lfs->cfg);
     return err;
 }
-#endif
 
 int lfs_file_opencfg(lfs_t *lfs, lfs_file_t *file,
         const char *path, int flags,
@@ -6207,20 +5368,6 @@ int lfs_dir_rewind(lfs_t *lfs, lfs_dir_t *dir) {
     return err;
 }
 
-int lfs_fs_stat(lfs_t *lfs, struct lfs_fsinfo *fsinfo) {
-    int err = LFS_LOCK(lfs->cfg);
-    if (err) {
-        return err;
-    }
-    LFS_TRACE("lfs_fs_stat(%p, %p)", (void*)lfs, (void*)fsinfo);
-
-    err = lfs_fs_rawstat(lfs, fsinfo);
-
-    LFS_TRACE("lfs_fs_stat -> %d", err);
-    LFS_UNLOCK(lfs->cfg);
-    return err;
-}
-
 lfs_ssize_t lfs_fs_size(lfs_t *lfs) {
     int err = LFS_LOCK(lfs->cfg);
     if (err) {
@@ -6250,54 +5397,6 @@ int lfs_fs_traverse(lfs_t *lfs, int (*cb)(void *, lfs_block_t), void *data) {
     return err;
 }
 
-#ifndef LFS_READONLY
-int lfs_fs_gc(lfs_t *lfs) {
-    int err = LFS_LOCK(lfs->cfg);
-    if (err) {
-        return err;
-    }
-    LFS_TRACE("lfs_fs_gc(%p)", (void*)lfs);
-
-    err = lfs_fs_rawgc(lfs);
-
-    LFS_TRACE("lfs_fs_gc -> %d", err);
-    LFS_UNLOCK(lfs->cfg);
-    return err;
-}
-#endif
-
-#ifndef LFS_READONLY
-int lfs_fs_mkconsistent(lfs_t *lfs) {
-    int err = LFS_LOCK(lfs->cfg);
-    if (err) {
-        return err;
-    }
-    LFS_TRACE("lfs_fs_mkconsistent(%p)", (void*)lfs);
-
-    err = lfs_fs_rawmkconsistent(lfs);
-
-    LFS_TRACE("lfs_fs_mkconsistent -> %d", err);
-    LFS_UNLOCK(lfs->cfg);
-    return err;
-}
-#endif
-
-#ifndef LFS_READONLY
-int lfs_fs_grow(lfs_t *lfs, lfs_size_t block_count) {
-    int err = LFS_LOCK(lfs->cfg);
-    if (err) {
-        return err;
-    }
-    LFS_TRACE("lfs_fs_grow(%p, %"PRIu32")", (void*)lfs, block_count);
-
-    err = lfs_fs_rawgrow(lfs, block_count);
-
-    LFS_TRACE("lfs_fs_grow -> %d", err);
-    LFS_UNLOCK(lfs->cfg);
-    return err;
-}
-#endif
-
 #ifdef LFS_MIGRATE
 int lfs_migrate(lfs_t *lfs, const struct lfs_config *cfg) {
     int err = LFS_LOCK(cfg);
@@ -6328,4 +5427,3 @@ int lfs_migrate(lfs_t *lfs, const struct lfs_config *cfg) {
     return err;
 }
 #endif
-
